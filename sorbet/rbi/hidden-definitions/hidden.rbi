# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class AbstractController::ActionNotFound
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*_); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ClassMethods
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::ConfigMethods
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

module AbstractController::Caching::Fragments::ClassMethods
end

module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
end

module AbstractController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module AbstractController::Callbacks
  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def gzip(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def m4a(*args, &block); end

  def mp3(*args, &block); end

  def mp4(*args, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def ogg(*args, &block); end

  def otf(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def svg(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def ttf(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def vtt(*args, &block); end

  def webm(*args, &block); end

  def woff(*args, &block); end

  def woff2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*meths); end

  def inherited(klass); end

  def modules_for_helpers(args); end
end

module AbstractController::Helpers::ClassMethods
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
end

module AbstractController::Logger
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
end

module AbstractController::Translation
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module AbstractController::Translation
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
end

module AbstractController
  extend ::ActiveSupport::Autoload
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel
end

class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*args, &block); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(val); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcast_to(*args, &block); end

  def broadcasting_for(*args, &block); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
end

module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Callbacks
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::Callbacks::ClassMethods
end

module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Naming
  def channel_name(*args, &block); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

module ActionCable::Channel::Naming::ClassMethods
end

module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::PeriodicTimers
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
end

module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Streams
  def pubsub(*args, &block); end

  def stop_all_streams(); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end
end

module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def _channel_class(); end

  def _channel_class=(val); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
end

module ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  def self._channel_class(); end

  def self._channel_class=(val); end

  def self._channel_class?(); end
end

module ActionCable::Channel
  extend ::ActiveSupport::Autoload
end

module ActionCable::Connection
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Assertions
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

module ActionCable::Connection::Authorization
end

class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*args, &block); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*args, &block); end

  def receive(websocket_message); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

module ActionCable::Connection::Identification::ClassMethods
end

module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
end

module ActionCable::Connection::InternalChannel
end

module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def _connection_class(); end

  def _connection_class=(val); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
end

module ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::TestCase
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  def self._connection_class(); end

  def self._connection_class=(val); end

  def self._connection_class?(); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::Connection::WebSocket
end

module ActionCable::Connection
  extend ::ActiveSupport::Autoload
end

class ActionCable::Engine
end

class ActionCable::Engine
end

module ActionCable::Helpers
end

module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag(); end
end

module ActionCable::Helpers::ActionCableHelper
end

module ActionCable::Helpers
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server
end

class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*args, &block); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(obj); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Broadcasting::Broadcaster
end

module ActionCable::Server::Broadcasting
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

class ActionCable::Server::Configuration
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Server::Connections
end

class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern
end

class ActionCable::Server::Worker
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

module ActionCable::Server
  extend ::ActiveSupport::Autoload
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*_); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

class ActionCable::SubscriptionAdapter::Test
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

class ActionCable::TestCase
  include ::ActionCable::TestHelper
end

class ActionCable::TestCase
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data); end

  def assert_broadcasts(stream, number); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*args, &block); end

  def clear_messages(*args, &block); end

  def pubsub_adapter(); end
end

module ActionCable::TestHelper
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
end

module ActionCable
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.server(); end

  def self.version(); end
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::ForceSSL
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::ExplicitParameters::Controller
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Rails::Timeago::Helper
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.without_modules(*modules); end
end

class ActionController::ActionControllerError
end

class ActionController::ActionControllerError
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
end

class ActionController::BadRequest
  def initialize(msg=T.unsafe(nil)); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::Serialization
  include ::ActionController::RespondWith
  include ::ExplicitParameters::Controller
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Rails::Timeago::Helper
  include ::Shipit::ActiveModelSerializersPatch
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _serialization_scope(); end

  def _serialization_scope=(val); end

  def _serialization_scope?(); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(val); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Serialization::ClassMethods
  extend ::Responders::ControllerMethod
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(val); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._serialization_scope(); end

  def self._serialization_scope=(val); end

  def self._serialization_scope?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::BasicImplicitRender
end

module ActionController::Caching
end

module ActionController::Caching
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ConditionalGet::ClassMethods
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
end

module ActionController::ContentSecurityPolicy
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::DefaultHeaders
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::DefaultHeaders::ClassMethods
end

module ActionController::DefaultHeaders
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithFlash
end

module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
end

module ActionController::ForceSSL
  def force_ssl_redirect(host_or_options=T.unsafe(nil)); end
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL::ClassMethods
  def force_ssl(options=T.unsafe(nil)); end
end

module ActionController::ForceSSL::ClassMethods
end

module ActionController::ForceSSL
  extend ::ActiveSupport::Concern
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::FormBuilder::ClassMethods
end

module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def helpers(); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers::ClassMethods
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
end

module ActionController::HttpAuthentication
end

module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::ImplicitRender
end

module ActionController::Instrumentation
  def process_action(*args); end

  def redirect_to(*args); end

  def render(*args); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Instrumentation::ClassMethods
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end
end

class ActionController::Live::Buffer
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

module ActionController::Live::ClassMethods
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
  extend ::ActiveSupport::Concern
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LiveTestResponse
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

class ActionController::Metal
  include ::ActionController::Testing::Functional
  def content_type(*args, &block); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*args, &block); end

  def location(*args, &block); end

  def location=(arg); end

  def media_type(*args, &block); end

  def middleware_stack(); end

  def middleware_stack=(val); end

  def middleware_stack?(); end

  def params=(val); end

  def request=(request); end

  def reset_session(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*args, &block); end

  def session(*args, &block); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*args, &block); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.binary_params_for?(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(val); end

  def self.middleware_stack?(); end

  def self.use(*args, &block); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

module ActionController::ParameterEncoding
end

module ActionController::ParameterEncoding::ClassMethods
  def binary_params_for?(action); end

  def inherited(klass); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

module ActionController::ParameterEncoding::ClassMethods
end

module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern
end

class ActionController::ParameterMissing
  def initialize(param); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  def converted_arrays(); end

  def each_key(*args, &block); end

  def each_value(&block); end

  def fields_for_style?(); end

  def init_with(coder); end

  def stringify_keys(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  def self.hook_into_yaml_loading(); end
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
end

module ActionController::Railties
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def with_defaults(defaults); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers::ClassMethods
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def process_action(*_); end

  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*_); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*args, &block); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::Rendering::ClassMethods
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  def skip_forgery_protection(options=T.unsafe(nil)); end
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*_); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
end

class ActionController::RespondToMismatchError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
end

module ActionController::RespondWith
  def collect_mimes_from_class_level(); end

  def respond_with(*resources, &block); end

  def verify_request_format!(); end

  def verify_requested_format!(); end
end

module ActionController::RespondWith::ClassMethods
  def clear_respond_to(); end

  def respond_to(*mimes); end
end

module ActionController::RespondWith::ClassMethods
end

module ActionController::RespondWith
  extend ::ActiveSupport::Concern
end

class ActionController::Responder
  def api_behavior(); end

  def api_location(); end

  def controller(); end

  def default_action(); end

  def default_render(); end

  def delete?(*args, &block); end

  def display(resource, given_options=T.unsafe(nil)); end

  def display_errors(); end

  def format(); end

  def get?(*args, &block); end

  def has_errors?(); end

  def has_renderer?(); end

  def has_view_rendering?(); end

  def head(*args, &block); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def json_resource_errors(); end

  def navigation_behavior(error); end

  def navigation_location(); end

  def options(); end

  def patch?(*args, &block); end

  def post?(*args, &block); end

  def put?(*args, &block); end

  def redirect_to(*args, &block); end

  def render(*args, &block); end

  def rendering_options(); end

  def request(); end

  def resource(); end

  def resource_errors(); end

  def resource_location(); end

  def resources(); end

  def respond(); end

  def response_overridden?(); end

  def to_format(); end

  def to_html(); end

  def to_js(); end
  DEFAULT_ACTIONS_FOR_VERBS = ::T.let(nil, ::T.untyped)
end

class ActionController::Responder
  def self.call(*args); end
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

module ActionController::Serialization
  def _render_option_json(resource, options); end

  def _render_with_renderer_json(resource, options); end
end

module ActionController::Serialization::ClassMethods
  def serialization_scope(scope); end
end

module ActionController::Serialization::ClassMethods
end

module ActionController::Serialization
  extend ::ActiveSupport::Concern
  def self.enabled(); end

  def self.enabled=(enabled); end
end

module ActionController::SerializationAssertions
  def assert_serializer(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def process(*args); end

  def setup_serialization_subscriptions(); end

  def teardown_serialization_subscriptions(); end
end

module ActionController::SerializationAssertions
  extend ::ActiveSupport::Concern
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
end

module ActionController::Streaming
  extend ::ActiveSupport::Concern
end

module ActionController::StrongParameters
  def params=(value); end
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::TemplateAssertions
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::SerializationAssertions
  def _controller_class(); end

  def _controller_class=(val); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
end

module ActionController::Testing
end

module ActionController::Testing::Functional
  def recycle!(); end
end

module ActionController::Testing::Functional
end

module ActionController::Testing
  extend ::ActiveSupport::Concern
end

class ActionController::UnfilteredParameters
  def initialize(); end
end

class ActionController::UnfilteredParameters
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
end

class ActionController::UrlGenerationError
end

class ActionController::UrlGenerationError
end

module ActionController
  extend ::ActiveSupport::Autoload
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

module ActionDispatch
  def test_app(); end

  def test_app=(obj); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(obj); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(obj); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def setup(); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil), nonce_directives=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def prefetch_src(*sources); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def sandbox(*values); end

  def script_src(*sources); end

  def style_src(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(generator); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*_); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*_); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(obj); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(obj); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def match?(path); end

  def serve(request); end
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, response_app=T.unsafe(nil)); end
  DEFAULT_RESPONSE_APP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

class ActionDispatch::HostAuthorization::Permissions
end

class ActionDispatch::HostAuthorization
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

class ActionDispatch::Http::ContentDisposition
  def ascii_filename(); end

  def disposition(); end

  def filename(); end

  def initialize(disposition:, filename:); end

  def utf8_filename(); end
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  def self.format(disposition:, filename:); end
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end

  def to_path(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(**args); end

  def get(path, **args); end

  def head(path, *args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def app(); end

  def assigns(*args); end

  def before_setup(); end

  def cookies(*args); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args); end

  def follow_redirect!(*args); end

  def get(*args); end

  def head(*args); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*args); end

  def post(*args); end

  def put(*args); end

  def remove!(); end

  def reset!(); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*args, &block); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def host(); end

  def host!(_); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*args, &block); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*args, &block); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*args, &block); end

  def status_message(*args, &block); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  def self.===(regex); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def named_captures(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.build(path, requirements, separators, anchored); end

  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, scope_options, internal=T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def scope_options(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route
  def self.build(name, app, path, constraints, required_defaults, defaults); end

  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authenticated_encrypted_cookie_salt(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def have_cookie_jar?(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def key_generator(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_script_name(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def secret_key_base(); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::RequestEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def initialize(mime_name, param_encoder, response_parser); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
end

class ActionDispatch::RequestEncoder
  def self.encoder(name); end

  def self.parser(content_type); end

  def self.register_encoder(mime_name, param_encoder: T.unsafe(nil), response_parser: T.unsafe(nil)); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(obj); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(obj); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Base
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*_); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, scope_options, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def nested(); end

  def new(); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

module ActionDispatch::Routing::PolymorphicRoutes
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def finalize!(); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def _shipit(); end

  def main_app(); end

  def shipit(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

module ActionDispatch::Session
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  def self.test_app(); end

  def self.test_app=(obj); end
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(obj); end

  def incinerate_after(); end

  def incinerate_after=(obj); end

  def ingress(); end

  def ingress=(obj); end

  def logger(); end

  def logger=(obj); end

  def queues(); end

  def queues=(obj); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*args, &block); end

  def delivered!(*args, &block); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*args, &block); end

  def mail(*args, &block); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

class ActionMailbox::BaseController
end

class ActionMailbox::BaseController
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::GeneratedAttributeMethods
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  include ::ActionMailbox::InboundEmail::Incineratable
  def autosave_associated_records_for_raw_email_attachment(); end

  def autosave_associated_records_for_raw_email_blob(); end

  def mail(); end

  def processed?(); end

  def source(); end

  def typed_status(); end

  def typed_status=(value); end
end

class ActionMailbox::InboundEmail::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
  def build_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment!(*args, &block); end

  def reload_raw_email_attachment(); end

  def reload_raw_email_blob(); end
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  def bounced(*args, &block); end

  def delivered(*args, &block); end

  def failed(*args, &block); end

  def not_bounced(*args, &block); end

  def not_delivered(*args, &block); end

  def not_failed(*args, &block); end

  def not_pending(*args, &block); end

  def not_processing(*args, &block); end

  def pending(*args, &block); end

  def processing(*args, &block); end

  def with_attached_raw_email(*args, &block); end
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
end

module ActionMailbox::InboundEmail::Incineratable
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::MessageId
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
end

module ActionMailbox::InboundEmail::MessageId
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

module ActionMailbox::InboundEmail::Routable
  extend ::ActiveSupport::Concern
end

class ActionMailbox::InboundEmail::Status
  Bounced = ::T.let(nil, ::T.untyped)
  Delivered = ::T.let(nil, ::T.untyped)
  Failed = ::T.let(nil, ::T.untyped)
  Pending = ::T.let(nil, ::T.untyped)
  Processing = ::T.let(nil, ::T.untyped)
end

class ActionMailbox::InboundEmail::Status
  extend ::T::Helpers
end

class ActionMailbox::InboundEmail
  extend ::ActionMailbox::InboundEmail::MessageId::ClassMethods
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

module ActionMailbox::Ingresses
end

module ActionMailbox::Ingresses::Mailgun
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
end

module ActionMailbox::Ingresses::Mailgun
end

module ActionMailbox::Ingresses::Mandrill
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
end

module ActionMailbox::Ingresses::Mandrill
end

module ActionMailbox::Ingresses::Postmark
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
end

module ActionMailbox::Ingresses::Postmark
end

module ActionMailbox::Ingresses::Relay
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
end

module ActionMailbox::Ingresses::Relay
end

module ActionMailbox::Ingresses::Sendgrid
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
end

module ActionMailbox::Ingresses::Sendgrid
end

module ActionMailbox::Ingresses
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

class ActionMailbox::RoutingJob
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.incinerate(); end

  def self.incinerate=(obj); end

  def self.incinerate_after(); end

  def self.incinerate_after=(obj); end

  def self.ingress(); end

  def self.ingress=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActiveSupport::Rescuable
  include ::ActionMailer::Rescuable
  include ::ActionMailer::Parameterized
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(val); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(obj); end

  def delivery_job(); end

  def delivery_job=(val); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(val); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(val); end

  def delivery_methods?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(val); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(val); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(val); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(val); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
end

class ActionMailer::Base::LateAttachmentsProxy
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base::NullMail
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Parameterized::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(val); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(obj); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(val); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.receive(raw_mail); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*args, &block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::DeliveryMethods::ClassMethods
end

module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, params: T.unsafe(nil)); end
end

class ActionMailer::MailDeliveryJob
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args); end

  def message(); end

  def processed?(); end
end

class ActionMailer::MessageDelivery
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

module ActionMailer::Parameterized::ClassMethods
end

class ActionMailer::Parameterized::DeliveryJob
  def perform(mailer, mail_method, delivery_method, params, *args); end
end

class ActionMailer::Parameterized::DeliveryJob
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::Mailer
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args); end
end

class ActionMailer::Parameterized::MessageDelivery
end

module ActionMailer::Parameterized
  extend ::ActiveSupport::Concern
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
end

class ActionMailer::Railtie
end

class ActionMailer::Railtie
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(val); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
end

module ActionPack
  def self.gem_version(); end

  def self.version(); end
end

module ActionText::Attachable
  def as_json(*_); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

module ActionText::Attachables
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*args, &block); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*args, &block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, &block); end

  def node(); end

  def to_html(); end

  def to_param(*args, &block); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*args, &block); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end
end

module ActionText::Attachments
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::Caching
end

module ActionText::Attachments::Minification
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attribute
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*_); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*args, &block); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*args, &block); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def renderer(); end

  def renderer=(obj); end

  def to_html(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(obj); end

  def allowed_tags(); end

  def allowed_tags=(obj); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(obj); end

  def scrubber(); end

  def scrubber=(obj); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(obj); end

  def self.allowed_tags(); end

  def self.allowed_tags=(obj); end

  def self.sanitizer(); end

  def self.sanitizer=(obj); end

  def self.scrubber(); end

  def self.scrubber=(obj); end
end

class ActionText::Engine
end

class ActionText::Engine
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

class ActionText::RichText
  include ::ActionText::RichText::GeneratedAttributeMethods
  def after_add_for_embeds_attachments(); end

  def after_add_for_embeds_attachments=(val); end

  def after_add_for_embeds_attachments?(); end

  def after_add_for_embeds_blobs(); end

  def after_add_for_embeds_blobs=(val); end

  def after_add_for_embeds_blobs?(); end

  def after_remove_for_embeds_attachments(); end

  def after_remove_for_embeds_attachments=(val); end

  def after_remove_for_embeds_attachments?(); end

  def after_remove_for_embeds_blobs(); end

  def after_remove_for_embeds_blobs=(val); end

  def after_remove_for_embeds_blobs?(); end

  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def before_add_for_embeds_attachments(); end

  def before_add_for_embeds_attachments=(val); end

  def before_add_for_embeds_attachments?(); end

  def before_add_for_embeds_blobs(); end

  def before_add_for_embeds_blobs=(val); end

  def before_add_for_embeds_blobs?(); end

  def before_remove_for_embeds_attachments(); end

  def before_remove_for_embeds_attachments=(val); end

  def before_remove_for_embeds_attachments?(); end

  def before_remove_for_embeds_blobs(); end

  def before_remove_for_embeds_blobs=(val); end

  def before_remove_for_embeds_blobs?(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def nil?(*args, &block); end

  def present?(*args, &block); end

  def to_plain_text(); end

  def to_s(*args, &block); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

class ActionText::RichText::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
  def purge(); end

  def purge_later(); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds_attachment_ids(); end

  def embeds_attachment_ids=(ids); end

  def embeds_blob_ids(); end

  def embeds_blob_ids=(ids); end

  def reload_record(); end
end

module ActionText::RichText::GeneratedAttributeMethods
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::RichText::GeneratedRelationMethods
  def with_attached_embeds(*args, &block); end
end

module ActionText::RichText::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionText::RichText
  def self.after_add_for_embeds_attachments(); end

  def self.after_add_for_embeds_attachments=(val); end

  def self.after_add_for_embeds_attachments?(); end

  def self.after_add_for_embeds_blobs(); end

  def self.after_add_for_embeds_blobs=(val); end

  def self.after_add_for_embeds_blobs?(); end

  def self.after_remove_for_embeds_attachments(); end

  def self.after_remove_for_embeds_attachments=(val); end

  def self.after_remove_for_embeds_attachments?(); end

  def self.after_remove_for_embeds_blobs(); end

  def self.after_remove_for_embeds_blobs=(val); end

  def self.after_remove_for_embeds_blobs?(); end

  def self.before_add_for_embeds_attachments(); end

  def self.before_add_for_embeds_attachments=(val); end

  def self.before_add_for_embeds_attachments?(); end

  def self.before_add_for_embeds_blobs(); end

  def self.before_add_for_embeds_blobs=(val); end

  def self.before_add_for_embeds_blobs?(); end

  def self.before_remove_for_embeds_attachments(); end

  def self.before_remove_for_embeds_attachments=(val); end

  def self.before_remove_for_embeds_attachments?(); end

  def self.before_remove_for_embeds_blobs(); end

  def self.before_remove_for_embeds_blobs=(val); end

  def self.before_remove_for_embeds_blobs?(); end
end

module ActionText::Serialization
  def _dump(*_); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText::Serialization
  extend ::ActiveSupport::Concern
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(obj); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText
  extend ::ActiveSupport::Autoload
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*args, &block); end

  def formats(*args, &block); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*args, &block); end
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, layout, template); end

  def layout(); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::Rails::Timeago::Helper
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::Sprockets::Rails::Utils
  def _routes(); end

  def _routes=(val); end

  def _routes?(); end

  def _run(method, template, locals, buffer, &block); end

  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(obj); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_formats(); end

  def default_formats=(obj); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def in_rendering_context(options); end

  def initialize(lookup_context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(val); end

  def logger?(); end

  def lookup_context(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(obj); end

  def self.build_lookup_context(context); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry
  def clear_cache(); end

  def clear_cache_if_necessary(); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
  def before(target); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
end

class ActionView::CacheExpiry
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FallbackFileSystemResolver
  def build_unbound_template(template, _); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path, pattern=T.unsafe(nil)); end

  def path(); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), virtual_path: T.unsafe(nil), digest_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def digest_path_from_template(template); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*args, &block); end

  def session(*args, &block); end
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(**options); end
end

module ActionView::Helpers::CspHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def rich_text_area(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def default_enforce_utf8(); end

  def default_enforce_utf8=(obj); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.default_enforce_utf8(); end

  def self.default_enforce_utf8=(obj); end

  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def auto_link(text, *args, &block); end

  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
  AUTO_EMAIL_LOCAL_RE = ::T.let(nil, ::T.untyped)
  AUTO_EMAIL_RE = ::T.let(nil, ::T.untyped)
  AUTO_LINK_CRE = ::T.let(nil, ::T.untyped)
  AUTO_LINK_RE = ::T.let(nil, ::T.untyped)
  BRACKETS = ::T.let(nil, ::T.untyped)
  WORD_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def _filtered_referrer(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*args, &block); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*_); end
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def fallbacks(); end

  def fallbacks=(obj); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(obj); end

  def rendered_format(*args, &block); end

  def rendered_format=(*args, &block); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_file(*args, &block); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(obj); end

  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(obj); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

class ActionView::OptimizedFileSystemResolver
  def initialize(path); end
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialIteration
  def first?(); end

  def index(); end

  def initialize(size); end

  def iterate!(); end

  def last?(); end

  def size(); end
end

class ActionView::PartialIteration
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_cache(); end

  def collection_cache=(obj); end

  def initialize(*_); end

  def render(context, options, block); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(obj); end
end

class ActionView::PathResolver
  def initialize(pattern=T.unsafe(nil)); end
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*args, &block); end

  def compact(); end

  def concat(*args); end

  def each(*args, &block); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_all_with_query(query); end

  def find_file(*args, &block); end

  def include?(*args, &block); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*args, &block); end

  def push(*args); end

  def size(*args, &block); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
  NULL_OPTION = ::T.let(nil, ::T.untyped)
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def caching(); end

  def caching=(obj); end

  def caching?(*args, &block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_anywhere(*args, &block); end

  def find_all_with_query(query); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def cache_query(query); end

  def clear(); end

  def size(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(obj); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def formats(*args, &block); end

  def formats=(*args, &block); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, format: T.unsafe(nil), variant: T.unsafe(nil), locals: T.unsafe(nil), virtual_path: T.unsafe(nil), updated_at: T.unsafe(nil)); end

  def locals(); end

  def locals=(*args, &block); end

  def marshal_dump(); end

  def marshal_load(array); end

  def original_encoding(*args, &block); end

  def refresh(*args, &block); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(*args, &block); end

  def variable(); end

  def variant(); end

  def variants(*args, &block); end

  def variants=(*args, &block); end

  def virtual_path(); end

  def virtual_path=(*args, &block); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(val); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(val); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(val); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(val); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(val); end

  def escape_ignore_list?(); end

  def escape_whitelist(*args, &block); end

  def escape_whitelist=(*args, &block); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(val); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(val); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(val); end

  def self.escape_ignore_list?(); end

  def self.escape_whitelist(*args, &block); end

  def self.escape_whitelist=(*args, &block); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
  def call(view, source); end
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
end

class ActionView::Template::LegacyTemplate
  def initialize(template, source); end

  def source(); end
end

class ActionView::Template::LegacyTemplate
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::RawFile
end

module ActionView::Template::Sources
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

module ActionView::Template::Sources
  extend ::ActiveSupport::Autoload
end

class ActionView::Template::Text
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(obj); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(obj); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
  def self.finalize_compiled_template_methods(); end

  def self.finalize_compiled_template_methods=(_); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def initialize(source, identifer, handler, options); end
end

class ActionView::UnboundTemplate
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*args, &block); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*args, &block); end

  def formats=(arg); end

  def locale(*args, &block); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*args, &block); end

  def view_paths(*args, &block); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveJob
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
end

class ActiveJob::Base
  include ::ActiveJob::Core
  include ::ActiveJob::QueueAdapter
  include ::ActiveJob::QueueName
  include ::ActiveJob::QueuePriority
  include ::ActiveJob::Enqueuing
  include ::ActiveSupport::Rescuable
  include ::ActiveJob::Execution
  include ::ActiveSupport::Callbacks
  include ::ActiveJob::Callbacks
  include ::ActiveJob::Exceptions
  include ::ActiveJob::Logging
  include ::ActiveJob::Timezones
  include ::ActiveJob::Translation
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(obj); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(val); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(val); end

  def self._test_adapter(); end

  def self._test_adapter=(val); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.priority(); end

  def self.priority=(val); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.return_false_on_aborted_enqueue(); end

  def self.return_false_on_aborted_enqueue=(val); end
end

module ActiveJob::Callbacks
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def timezone(); end

  def timezone=(timezone); end
end

module ActiveJob::Core
  extend ::ActiveSupport::Concern
end

class ActiveJob::DeserializationError
  def initialize(); end
end

class ActiveJob::DeserializationError
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Enqueuing
  extend ::ActiveSupport::Concern
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  extend ::ActiveSupport::Concern
end

module ActiveJob::Execution
  def perform(*_); end

  def perform_now(); end
end

module ActiveJob::Execution
  extend ::ActiveSupport::Concern
end

module ActiveJob::Logging
end

module ActiveJob::Logging
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapter
end

module ActiveJob::QueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapters
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
end

class ActiveJob::QueueAdapters::AsyncAdapter
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueueName
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::QueuePriority
  extend ::ActiveSupport::Concern
end

class ActiveJob::Railtie
end

class ActiveJob::Railtie
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(obj); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateSerializer
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::DateTimeSerializer
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::DurationSerializer
end

class ActiveJob::Serializers::ObjectSerializer
  include ::Singleton
  def deserialize(_argument); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  extend ::Singleton::SingletonClassMethods
  def self.deserialize(*args, &block); end

  def self.instance(); end

  def self.serialize(*args, &block); end

  def self.serialize?(*args, &block); end
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::SymbolSerializer
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeSerializer
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
end

module ActiveJob::Serializers
  extend ::ActiveSupport::Autoload
  def self._additional_serializers(); end

  def self._additional_serializers=(obj); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*args, &block); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def performed_jobs(*args, &block); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::TestHelper
end

module ActiveJob::Timezones
end

module ActiveJob::Timezones
  extend ::ActiveSupport::Concern
end

module ActiveJob::Translation
end

module ActiveJob::Translation
  extend ::ActiveSupport::Concern
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
end

module ActiveJob
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveModel::ArraySerializer
  include ::ActiveModel::Serializable
  def context(); end

  def context=(context); end

  def initialize(object, options=T.unsafe(nil)); end

  def json_key(); end

  def key_format(); end

  def key_format=(key_format); end

  def meta(); end

  def meta=(meta); end

  def meta_key(); end

  def meta_key=(meta_key); end

  def object(); end

  def object=(object); end

  def root(); end

  def root=(root); end

  def scope(); end

  def scope=(scope); end

  def serializable_array(options=T.unsafe(nil)); end

  def serializable_object(options=T.unsafe(nil)); end

  def serializer_for(item); end
end

class ActiveModel::ArraySerializer
  extend ::ActiveModel::Serializable::Utils
  def self._root(); end

  def self._root=(_root); end

  def self.root(_); end

  def self.root=(root); end
end

class ActiveModel::Attribute
  def ==(other); end

  def came_from_user?(); end

  def changed?(); end

  def changed_in_place?(); end

  def encode_with(coder); end

  def eql?(other); end

  def forgetting_assignment(); end

  def has_been_read?(); end

  def init_with(coder); end

  def initialize(name, value_before_type_cast, type, original_attribute=T.unsafe(nil)); end

  def initialized?(); end

  def name(); end

  def original_value(); end

  def original_value_for_database(); end

  def type(); end

  def type_cast(*_); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end

  def with_cast_value(value); end

  def with_type(type); end

  def with_value_from_database(value); end

  def with_value_from_user(value); end
end

class ActiveModel::Attribute::FromUser
  def type_cast(value); end
end

class ActiveModel::Attribute::FromUser
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end
end

class ActiveModel::Attribute::UserProvidedDefault
end

class ActiveModel::Attribute
  def self.from_database(name, value, type); end

  def self.from_user(name, value, type, original_attribute=T.unsafe(nil)); end

  def self.null(name); end

  def self.uninitialized(name, type); end

  def self.with_cast_value(name, value, type); end
end

module ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeAssignment
end

module ActiveModel::AttributeMethods
  def attribute_missing(match, *args, &block); end

  def method_missing(method, *args, &block); end

  def respond_to?(method, include_private_methods=T.unsafe(nil)); end

  def respond_to_without_attributes?(*_); end
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forget_change(attr_name); end

  def initialize(attributes, forced_changes=T.unsafe(nil)); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
end

class ActiveModel::AttributeSet
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def accessed(); end

  def attributes(); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def fetch_value(name, &block); end

  def initialize(attributes); end

  def key?(name); end

  def keys(); end

  def map(&block); end

  def reset(key); end

  def to_h(); end

  def to_hash(); end

  def values_before_type_cast(); end

  def write_cast_value(name, value); end

  def write_from_database(name, value); end

  def write_from_user(name, value); end
end

class ActiveModel::AttributeSet::Builder
  def build_from_database(values=T.unsafe(nil), additional_types=T.unsafe(nil)); end

  def default_attributes(); end

  def initialize(types, default_attributes=T.unsafe(nil)); end

  def types(); end
end

class ActiveModel::AttributeSet::Builder
end

class ActiveModel::AttributeSet::YAMLEncoder
  def decode(coder); end

  def encode(attribute_set, coder); end

  def initialize(default_types); end
end

class ActiveModel::AttributeSet::YAMLEncoder
end

class ActiveModel::AttributeSet
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

class ActiveModel::BlockValidator
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Conversion
  extend ::ActiveSupport::Concern
end

class ActiveModel::DefaultSerializer
  include ::ActiveModel::Serializable
  def initialize(object, options=T.unsafe(nil)); end

  def object(); end

  def serializable_hash(options=T.unsafe(nil)); end

  def serializable_object(options=T.unsafe(nil)); end
end

class ActiveModel::DefaultSerializer
  extend ::ActiveModel::Serializable::Utils
end

module ActiveModel::Dirty
  def attribute_was(attr_name); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def previous_changes(); end

  def restore_attributes(attr_names=T.unsafe(nil)); end
end

module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::EachValidator
end

class ActiveModel::Errors
  include ::Enumerable
  def [](attribute); end

  def clear(); end

  def copy!(other); end

  def count(); end

  def delete(key); end

  def details(); end

  def each(&blk); end

  def empty?(); end

  def full_message(attribute, message); end

  def full_messages_for(attribute); end

  def generate_message(attribute, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def has_key?(attribute); end

  def include?(attribute); end

  def init_with(coder); end

  def initialize(base); end

  def key?(attribute); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge!(other); end

  def messages(); end

  def size(); end

  def slice!(*keys); end

  def to_a(); end

  def to_hash(full_messages=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def values(); end
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  def self.i18n_customize_full_message(); end

  def self.i18n_customize_full_message=(i18n_customize_full_message); end
end

class ActiveModel::ForbiddenAttributesError
end

class ActiveModel::ForbiddenAttributesError
end

module ActiveModel::ForbiddenAttributesProtection
end

module ActiveModel::ForbiddenAttributesProtection
end

class ActiveModel::ForcedMutationTracker
  def finalize_changes(); end
end

class ActiveModel::ForcedMutationTracker
end

class ActiveModel::LazyAttributeHash
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def each_key(*args, &block); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def initialize(types, values, additional_types, default_attributes, delegate_hash=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(values); end

  def materialize(); end

  def select(); end

  def transform_values(*args, &block); end
end

class ActiveModel::LazyAttributeHash
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::MissingAttributeError
end

class ActiveModel::MissingAttributeError
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
end

class ActiveModel::Name
  include ::Comparable
  def !~(*args, &block); end

  def ==(arg); end

  def ===(arg); end

  def =~(*args, &block); end

  def as_json(*args, &block); end

  def cache_key(); end

  def collection(); end

  def element(); end

  def eql?(*args, &block); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil)); end

  def match?(*args, &block); end

  def name(); end

  def param_key(); end

  def plural(); end

  def route_key(); end

  def singular(); end

  def singular_route_key(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end
end

class ActiveModel::Name
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  include ::Singleton
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, **_); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def original_value(attr_name); end
end

class ActiveModel::NullMutationTracker
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class ActiveModel::Railtie
end

class ActiveModel::Railtie
end

class ActiveModel::RangeError
end

class ActiveModel::RangeError
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serializable
  def as_json(options=T.unsafe(nil)); end

  def embedded_in_root_associations(); end

  def namespace(); end

  def serializable_data(); end

  def serializable_object_with_notification(options=T.unsafe(nil)); end
  INSTRUMENTATION_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Serializable::Utils
  def _const_get(const); end
end

module ActiveModel::Serializable::Utils
  extend ::ActiveModel::Serializable::Utils
end

module ActiveModel::Serializable
  def self.included(base); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*_); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serialization
end

class ActiveModel::Serializer
  include ::ActiveModel::Serializable
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def association_options_for_serializer(association); end

  def associations(options=T.unsafe(nil)); end

  def attributes(); end

  def build_serializer(association); end

  def context(); end

  def context=(context); end

  def convert_keys(hash); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def filter(keys); end

  def format_key(key); end

  def initialize(object, options=T.unsafe(nil)); end

  def json_key(); end

  def key_format(); end

  def key_format=(key_format); end

  def meta(); end

  def meta=(meta); end

  def meta_key(); end

  def meta_key=(meta_key); end

  def object(); end

  def object=(object); end

  def polymorphic(); end

  def polymorphic=(polymorphic); end

  def root(); end

  def root=(root); end

  def scope(); end

  def scope=(scope); end

  def serializable_hash(options=T.unsafe(nil)); end

  def serializable_object(options=T.unsafe(nil)); end

  def serialization_options(); end

  def serialization_options=(serialization_options); end

  def serialize(association, options=T.unsafe(nil)); end

  def serialize_id(elem, association); end

  def serialize_ids(association); end

  def type_name(elem); end
  CONFIG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Association
  def build_serializer(object, options=T.unsafe(nil)); end

  def default_serializer(); end

  def embed=(embed); end

  def embed_ids(); end

  def embed_ids?(); end

  def embed_in_root(); end

  def embed_in_root=(embed_in_root); end

  def embed_in_root?(); end

  def embed_in_root_key(); end

  def embed_in_root_key=(embed_in_root_key); end

  def embed_in_root_key?(); end

  def embed_key(); end

  def embed_key=(embed_key); end

  def embed_namespace(); end

  def embed_namespace=(embed_namespace); end

  def embed_namespace?(); end

  def embed_objects(); end

  def embed_objects?(); end

  def embedded_key(); end

  def embedded_key=(embedded_key); end

  def initialize(name, options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def key_format(); end

  def key_format=(key_format); end

  def name(); end

  def options(); end

  def options=(options); end

  def polymorphic(); end

  def polymorphic?(); end

  def root_key(); end

  def root_key=(root_key); end

  def serializer_from_object(object, options=T.unsafe(nil)); end

  def serializer_from_options(); end

  def serializer_from_options=(serializer_from_options); end
end

class ActiveModel::Serializer::Association::HasMany
  def initialize(name, *args); end

  def serializer_class(object, _); end
end

class ActiveModel::Serializer::Association::HasMany
end

class ActiveModel::Serializer::Association::HasOne
  def initialize(name, *args); end

  def serializer_class(object, options=T.unsafe(nil)); end
end

class ActiveModel::Serializer::Association::HasOne
end

class ActiveModel::Serializer::Association
end

class ActiveModel::Serializer::Config
  def clear(); end

  def each(&block); end

  def initialize(data=T.unsafe(nil)); end

  def method_missing(name, *args); end
end

class ActiveModel::Serializer::Config
end

class ActiveModel::Serializer
  extend ::ActiveModel::Serializable::Utils
  def self._associations(); end

  def self._associations=(_associations); end

  def self._attributes(); end

  def self._attributes=(_attributes); end

  def self._root(); end

  def self._root=(_root); end

  def self._routes(); end

  def self.attributes(*attrs); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.embed(type, options=T.unsafe(nil)); end

  def self.format_keys(format); end

  def self.has_many(*attrs); end

  def self.has_one(*attrs); end

  def self.inherited(base); end

  def self.key_format(); end

  def self.root(_); end

  def self.root=(root); end

  def self.root_name(); end

  def self.serializer_for(resource, options=T.unsafe(nil)); end

  def self.serializers_cache(); end

  def self.setup(); end
end

module ActiveModel::SerializerSupport
  def read_attribute_for_serialization(*_); end
end

module ActiveModel::SerializerSupport
end

module ActiveModel::Serializers
end

module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::StrictValidationFailed
end

module ActiveModel::Translation
  include ::ActiveModel::Naming
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveModel::Translation
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Binary::Data
end

class ActiveModel::Type::Binary
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  include ::ActiveModel::Type::Helpers::Timezone
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
end

class ActiveModel::Type::DateTime
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::DateTime
end

class ActiveModel::Type::Decimal
  include ::ActiveModel::Type::Helpers::Numeric
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
end

class ActiveModel::Type::Float
  include ::ActiveModel::Type::Helpers::Numeric
end

class ActiveModel::Type::Float
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end
end

module ActiveModel::Type::Helpers::Mutable
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def serialize(value); end
end

module ActiveModel::Type::Helpers::Numeric
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
end

module ActiveModel::Type::Helpers::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveModel::Type::Helpers::Timezone
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Integer
  include ::ActiveModel::Type::Helpers::Numeric
  def initialize(*_); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
end

class ActiveModel::Type::Registration
  def call(_registry, *args, **kwargs); end

  def initialize(name, block, **_); end

  def matches?(type_name, *args, **kwargs); end
end

class ActiveModel::Type::Registration
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end
end

class ActiveModel::Type::Registry
end

class ActiveModel::Type::Time
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::Time
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(*_); end

  def binary?(); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def limit(); end

  def map(value); end

  def precision(); end

  def scale(); end

  def serialize(value); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*args, **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveModel::UnknownAttributeError
  def attribute(); end

  def initialize(record, attribute); end

  def record(); end
end

class ActiveModel::UnknownAttributeError
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

class ActiveModel::ValidationError
end

module ActiveModel::Validations
  def invalid?(context=T.unsafe(nil)); end

  def read_attribute_for_validation(*_); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::Callbacks
end

module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveModel
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveRecord::Aggregations
  def reload(*_); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations::ClassMethods
end

module ActiveRecord::Aggregations
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError
  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end

  def reload(*_); end
end

class ActiveRecord::Associations::CollectionProxy
  def <<(*records); end

  def _select!(*args, &block); end

  def annotate(*args, &block); end

  def annotate!(*args, &block); end

  def annotate_values(*args, &block); end

  def annotate_values=(arg); end

  def append(*records); end

  def arel(*args, &block); end

  def clear(); end

  def concat(*records); end

  def construct_join_dependency(*args, &block); end

  def create_with(*args, &block); end

  def create_with!(*args, &block); end

  def create_with_value(*args, &block); end

  def create_with_value=(arg); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def distinct(*args, &block); end

  def distinct!(*args, &block); end

  def distinct_value(*args, &block); end

  def distinct_value=(arg); end

  def eager_load(*args, &block); end

  def eager_load!(*args, &block); end

  def eager_load_values(*args, &block); end

  def eager_load_values=(arg); end

  def except(*args, &block); end

  def extending(*args, &block); end

  def extending!(*args, &block); end

  def extending_values(*args, &block); end

  def extending_values=(arg); end

  def extensions(*args, &block); end

  def extract_associated(*args, &block); end

  def from(*args, &block); end

  def from!(*args, &block); end

  def from_clause(*args, &block); end

  def from_clause=(arg); end

  def group(*args, &block); end

  def group!(*args, &block); end

  def group_values(*args, &block); end

  def group_values=(arg); end

  def having(*args, &block); end

  def having!(*args, &block); end

  def having_clause(*args, &block); end

  def having_clause=(arg); end

  def include?(record); end

  def includes(*args, &block); end

  def includes!(*args, &block); end

  def includes_values(*args, &block); end

  def includes_values=(arg); end

  def initialize(klass, association); end

  def joins(*args, &block); end

  def joins!(*args, &block); end

  def joins_values(*args, &block); end

  def joins_values=(arg); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def left_outer_joins!(*args, &block); end

  def left_outer_joins_values(*args, &block); end

  def left_outer_joins_values=(arg); end

  def limit(*args, &block); end

  def limit!(*args, &block); end

  def limit_value(*args, &block); end

  def limit_value=(arg); end

  def load_target(); end

  def lock(*args, &block); end

  def lock!(*args, &block); end

  def lock_value(*args, &block); end

  def lock_value=(arg); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def none(*args, &block); end

  def none!(*args, &block); end

  def offset(*args, &block); end

  def offset!(*args, &block); end

  def offset_value(*args, &block); end

  def offset_value=(arg); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def optimizer_hints!(*args, &block); end

  def optimizer_hints_values(*args, &block); end

  def optimizer_hints_values=(arg); end

  def or(*args, &block); end

  def or!(*args, &block); end

  def order(*args, &block); end

  def order!(*args, &block); end

  def order_values(*args, &block); end

  def order_values=(arg); end

  def preload(*args, &block); end

  def preload!(*args, &block); end

  def preload_values(*args, &block); end

  def preload_values=(arg); end

  def prepend(*args); end

  def proxy_association(); end

  def push(*records); end

  def readonly(*args, &block); end

  def readonly!(*args, &block); end

  def readonly_value(*args, &block); end

  def readonly_value=(arg); end

  def references(*args, &block); end

  def references!(*args, &block); end

  def references_values(*args, &block); end

  def references_values=(arg); end

  def reorder(*args, &block); end

  def reorder!(*args, &block); end

  def reordering_value(*args, &block); end

  def reordering_value=(arg); end

  def replace(other_array); end

  def reselect(*args, &block); end

  def reselect!(*args, &block); end

  def reset_scope(); end

  def reverse_order(*args, &block); end

  def reverse_order!(*args, &block); end

  def reverse_order_value(*args, &block); end

  def reverse_order_value=(arg); end

  def rewhere(*args, &block); end

  def scope(); end

  def scoping(*args, &block); end

  def select_values(*args, &block); end

  def select_values=(arg); end

  def skip_preloading!(*args, &block); end

  def skip_query_cache!(*args, &block); end

  def skip_query_cache_value(*args, &block); end

  def skip_query_cache_value=(arg); end

  def spawn(*args, &block); end

  def target(); end

  def unscope(*args, &block); end

  def unscope!(*args, &block); end

  def unscope_values(*args, &block); end

  def unscope_values=(arg); end

  def values(*args, &block); end

  def where(*args, &block); end

  def where!(*args, &block); end

  def where_clause(*args, &block); end

  def where_clause=(arg); end
end

class ActiveRecord::Associations::CollectionProxy
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

module ActiveRecord::AttributeAssignment
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeDecorators
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*_); end

  def saved_change_to_attribute(attr_name); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name, &block); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Attributes
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Sanitization
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::DefineCallbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::Suppressor
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveRecord::Translation
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::Validations::HelperMethods
  extend ::SorbetRails::CustomFinderMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(val); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(val); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(obj); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(val); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.inherited(child); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.reading_role(); end

  def self.reading_role=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end

  def self.writing_role(); end

  def self.writing_role=(obj); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Batches
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(column_name=T.unsafe(nil)); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*_); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value, klass); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*_); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(*args, &block); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_multi_insert?(*args, &block); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def truncate(*_); end

  def truncate_tables(*_); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def set_schema_cache(cache); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def limit(*args, &block); end

  def name(); end

  def null(); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def sql_type(*args, &block); end

  def sql_type_metadata(); end

  def type(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::Column
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(); end

  def clear_active_connections!(); end

  def clear_all_connections!(); end

  def clear_reloadable_connections!(); end

  def connected?(spec_name); end

  def connection_pool_list(); end

  def connection_pools(); end

  def establish_connection(config); end

  def flush_idle_connections!(); end

  def prevent_writes(); end

  def prevent_writes=(prevent_writes); end

  def remove_connection(spec_name); end

  def retrieve_connection(spec_name); end

  def retrieve_connection_pool(spec_name); end

  def while_preventing_writes(enabled=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def self.create_owner_to_pool(); end

  def self.discard_unowned_pools(pid_map); end

  def self.unowned_pool_finalizer(pid_map); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def discard!(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(spec); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def size(); end

  def spec(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config_or_env, pool_name=T.unsafe(nil)); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(*args, &block); end

  def columns_per_multicolumn_index(*args, &block); end

  def columns_per_table(*args, &block); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(*args, &block); end

  def joins_per_query(*args, &block); end

  def max_identifier_length(); end

  def sql_query_length(*args, &block); end

  def table_alias_length(); end

  def table_name_length(*args, &block); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*args, &block); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*args, &block); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def materialize_transactions(*args, &block); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*args, &block); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(object, collector); end

  def preparable(); end

  def preparable=(preparable); end

  def visit_Arel_Nodes_In(o, collector); end

  def visit_Arel_Nodes_NotIn(o, collector); end

  def visit_Arel_Nodes_SqlLiteral(o, collector); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def defined_for?(to_table: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name); end
end

class ActiveRecord::ConnectionAdapters::NullColumn
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::NullPool
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value, column=T.unsafe(nil)); end

  def type_cast_from_column(column, value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

module ActiveRecord::ConnectionAdapters::SQLite3
end

module ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
  def begin_db_transaction(); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::SQLite3::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::SQLite3::ExplainPrettyPrinter
end

module ActiveRecord::ConnectionAdapters::SQLite3::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def quote_column_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::Quoting
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
  def add_foreign_key(from_table, to_table, **options); end

  def create_schema_dumper(options); end

  def indexes(table_name); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SQLite3::TableDefinition
end

class ActiveRecord::ConnectionAdapters::SQLite3::TableDefinition
end

module ActiveRecord::ConnectionAdapters::SQLite3
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  include ::ActiveRecord::ConnectionAdapters::SQLite3::Quoting
  include ::ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def encoding(); end

  def explain(arel, binds=T.unsafe(nil)); end

  def initialize(connection, logger, connection_options, config); end

  def primary_keys(table_name); end

  def supports_insert_on_conflict?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COLLATE_REGEX = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::SQLite3Integer
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::SQLite3Integer
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  def self.represent_boolean_as_integer=(value); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, *args); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_foreign_key(from_table, to_table, options=T.unsafe(nil)); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, options=T.unsafe(nil)); end

  def assume_migrated_upto_version(version, migrations_paths=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Table
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(table_name, options=T.unsafe(nil)); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_column_definition(name, type, **options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end

  def clear_all_connections!(*args, &block); end

  def clear_cache!(); end

  def clear_query_caches_for_current_thread(); end

  def clear_reloadable_connections!(*args, &block); end

  def connected?(); end

  def connected_to(database: T.unsafe(nil), role: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end

  def connected_to?(role:); end

  def connection(); end

  def connection_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def connects_to(database: T.unsafe(nil)); end

  def current_role(); end

  def establish_connection(config_or_env=T.unsafe(nil)); end

  def flush_idle_connections!(*args, &block); end

  def lookup_connection_handler(handler_key); end

  def primary_class?(); end

  def remove_connection(name=T.unsafe(nil)); end

  def resolve_config_for_connection(config_or_env); end

  def retrieve_connection(); end

  def sqlite3_connection(config); end

  def with_handler(handler_key, &blk); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def blank?(); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder, &block); end

  def init_with_attributes(attributes, new_record=T.unsafe(nil)); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def present?(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
end

module ActiveRecord::CounterCache
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DatabaseConfigurations
  def [](env=T.unsafe(nil)); end

  def any?(*args, &block); end

  def configs_for(env_name: T.unsafe(nil), spec_name: T.unsafe(nil), include_replicas: T.unsafe(nil)); end

  def configurations(); end

  def default_hash(env=T.unsafe(nil)); end

  def each(&blk); end

  def empty?(); end

  def find_db_config(env); end

  def first(); end

  def initialize(configurations=T.unsafe(nil)); end

  def to_h(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  def env_name(); end

  def for_current_env?(); end

  def initialize(env_name, spec_name); end

  def migrations_paths(); end

  def replica?(); end

  def spec_name(); end

  def to_legacy_hash(); end

  def url_config?(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
end

class ActiveRecord::DatabaseConfigurations::HashConfig
  def config(); end

  def initialize(env_name, spec_name, config); end
end

class ActiveRecord::DatabaseConfigurations::HashConfig
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
  def config(); end

  def initialize(env_name, spec_name, url, config=T.unsafe(nil)); end

  def url(); end
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
end

class ActiveRecord::DatabaseConfigurations
end

module ActiveRecord::DefineCallbacks
end

module ActiveRecord::DefineCallbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def compact(*args, &block); end

  def connection(*args, &block); end

  def each(*args, &block); end

  def encode_with(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def index(*args, &block); end

  def join(*args, &block); end

  def length(*args, &block); end

  def primary_key(*args, &block); end

  def reverse(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def sample(*args, &block); end

  def shuffle(*args, &block); end

  def slice(*args, &block); end

  def split(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def |(*args, &block); end
end

module ActiveRecord::Delegation::ClassSpecificRelation
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

module ActiveRecord::Enum
  include ::Kernel
  def _define_enum(*args, &blk); end

  def _define_typed_enum(*args, &blk); end

  def enum(*args, &blk); end

  def extract_enum_values(*args, &blk); end

  def gen_typed_enum_values(*args, &blk); end

  def inherited(base); end

  def old_enum(definitions); end

  def typed_enum(*args, &blk); end

  def typed_enum_reflections(*args, &blk); end
  SR_ENUM_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Enum::ConflictTypedEnumNameError
end

class ActiveRecord::Enum::ConflictTypedEnumNameError
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def type(*args, &block); end
end

class ActiveRecord::Enum::EnumType
end

class ActiveRecord::Enum::MultipleEnumsDefinedError
end

class ActiveRecord::Enum::MultipleEnumsDefinedError
end

module ActiveRecord::Enum
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::Explain
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def queries=(queries); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.collect?(*args, &block); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::Fixture
  include ::Enumerable
  def [](key); end

  def class_name(); end

  def each(&blk); end

  def find(); end

  def fixture(); end

  def initialize(fixture, model_class); end

  def model_class(); end

  def to_hash(); end
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture
end

class ActiveRecord::FixtureSet
  def [](x); end

  def []=(k, v); end

  def all_loaded_fixtures(); end

  def all_loaded_fixtures=(obj); end

  def config(); end

  def each(&block); end

  def fixtures(); end

  def initialize(_, name, class_name, path, config=T.unsafe(nil)); end

  def model_class(); end

  def name(); end

  def size(); end

  def table_name(); end

  def table_rows(); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet::ClassCache
  def [](fs_name); end

  def initialize(class_names, config); end
end

class ActiveRecord::FixtureSet::ClassCache
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable
  def each(&block); end

  def initialize(file); end

  def model_class(); end
end

class ActiveRecord::FixtureSet::File
  def self.open(file); end
end

class ActiveRecord::FixtureSet::ModelMetadata
  def has_primary_key_column?(); end

  def inheritance_column_name(); end

  def initialize(model_class); end

  def primary_key_name(); end

  def primary_key_type(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::ModelMetadata
end

class ActiveRecord::FixtureSet::RenderContext
end

class ActiveRecord::FixtureSet::RenderContext
  def self.create_subclass(); end
end

class ActiveRecord::FixtureSet::TableRow
  def initialize(fixture, table_rows:, label:, now:); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
  def lhs_key(); end

  def rhs_key(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  def initialize(association); end

  def join_table(); end

  def name(); end

  def primary_key_type(); end
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
end

class ActiveRecord::FixtureSet::TableRow
end

class ActiveRecord::FixtureSet::TableRows
  def initialize(table_name, model_class:, fixtures:, config:); end

  def model_class(); end

  def model_metadata(); end

  def tables(); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRows
end

class ActiveRecord::FixtureSet
  def self.all_loaded_fixtures(); end

  def self.all_loaded_fixtures=(obj); end

  def self.cache_fixtures(connection, fixtures_map); end

  def self.cache_for_connection(connection); end

  def self.cached_fixtures(connection, keys_to_fetch=T.unsafe(nil)); end

  def self.context_class(); end

  def self.create_fixtures(fixtures_directory, fixture_set_names, class_names=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.default_fixture_model_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.default_fixture_table_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.fixture_is_cached?(connection, table_name); end

  def self.identify(label, column_type=T.unsafe(nil)); end

  def self.instantiate_all_loaded_fixtures(object, load_instances=T.unsafe(nil)); end

  def self.instantiate_fixtures(object, fixture_set, load_instances=T.unsafe(nil)); end

  def self.reset_cache(); end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InsertAll
  def connection(); end

  def execute(); end

  def initialize(model, inserts, on_duplicate:, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  def inserts(); end

  def keys(); end

  def map_key_with_value(); end

  def model(); end

  def on_duplicate(); end

  def primary_keys(); end

  def returning(); end

  def skip_duplicates?(); end

  def unique_by(); end

  def updatable_columns(); end

  def update_duplicates?(); end
end

class ActiveRecord::InsertAll::Builder
  def conflict_target(); end

  def initialize(insert_all); end

  def into(); end

  def keys(*args, &block); end

  def model(); end

  def returning(); end

  def skip_duplicates?(*args, &block); end

  def updatable_columns(); end

  def update_duplicates?(*args, &block); end

  def values_list(); end
end

class ActiveRecord::InsertAll::Builder
end

class ActiveRecord::InsertAll
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  def created_at_before_last_save(*args); end

  def created_at_before_type_cast(*args); end

  def created_at_came_from_user?(*args); end

  def created_at_change(*args); end

  def created_at_change_to_be_saved(*args); end

  def created_at_changed?(*args); end

  def created_at_in_database(*args); end

  def created_at_previous_change(*args); end

  def created_at_previously_changed?(*args); end

  def created_at_was(*args); end

  def created_at_will_change!(*args); end

  def key_before_last_save(*args); end

  def key_before_type_cast(*args); end

  def key_came_from_user?(*args); end

  def key_change(*args); end

  def key_change_to_be_saved(*args); end

  def key_changed?(*args); end

  def key_in_database(*args); end

  def key_previous_change(*args); end

  def key_previously_changed?(*args); end

  def key_was(*args); end

  def key_will_change!(*args); end

  def restore_created_at!(*args); end

  def restore_key!(*args); end

  def restore_updated_at!(*args); end

  def restore_value!(*args); end

  def saved_change_to_created_at(*args); end

  def saved_change_to_created_at?(*args); end

  def saved_change_to_key(*args); end

  def saved_change_to_key?(*args); end

  def saved_change_to_updated_at(*args); end

  def saved_change_to_updated_at?(*args); end

  def saved_change_to_value(*args); end

  def saved_change_to_value?(*args); end

  def updated_at_before_last_save(*args); end

  def updated_at_before_type_cast(*args); end

  def updated_at_came_from_user?(*args); end

  def updated_at_change(*args); end

  def updated_at_change_to_be_saved(*args); end

  def updated_at_changed?(*args); end

  def updated_at_in_database(*args); end

  def updated_at_previous_change(*args); end

  def updated_at_previously_changed?(*args); end

  def updated_at_was(*args); end

  def updated_at_will_change!(*args); end

  def value_before_last_save(*args); end

  def value_before_type_cast(*args); end

  def value_came_from_user?(*args); end

  def value_change(*args); end

  def value_change_to_be_saved(*args); end

  def value_changed?(*args); end

  def value_in_database(*args); end

  def value_previous_change(*args); end

  def value_previously_changed?(*args); end

  def value_was(*args); end

  def value_will_change!(*args); end

  def will_save_change_to_created_at?(*args); end

  def will_save_change_to_key?(*args); end

  def will_save_change_to_updated_at?(*args); end

  def will_save_change_to_value?(*args); end
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::InternalMetadata
  def self.[](key); end

  def self.[]=(key, value); end

  def self.create_table(); end

  def self.drop_table(); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(val); end

  def backtrace_cleaner?(); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(val); end

  def self.backtrace_cleaner?(); end

  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module ActiveRecord::Middleware
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, **options); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationContext
  def any_migrations?(); end

  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil)); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration); end

  def last_migration(); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil)); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def basename(); end

  def disable_ddl_transaction(*args, &block); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*args, &block); end

  def mtime(); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, schema_migration, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_); end

  def touch_later(*_); end
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(val); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(val); end

  def self._actions?(); end
end

module ActiveRecord::Persistence
  def delete(); end

  def destroy(); end

  def destroy!(); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::PredicateBuilder
  def build(attribute, value); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes); end

  def expand_from_hash(attributes); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BaseHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BaseHandler
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

class ActiveRecord::QueryCache
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

module ActiveRecord::QueryCache::ClassMethods
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def annotate(*args, &block); end

  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_or_find_by(*args, &block); end

  def create_or_find_by!(*args, &block); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def delete_by(*args, &block); end

  def destroy_all(*args, &block); end

  def destroy_by(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def extract_associated(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def reselect(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def touch_all(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_with_template(*_); end

  def collection_without_template(*_); end

  def relation_from_options(cached: T.unsafe(nil), partial: T.unsafe(nil), collection: T.unsafe(nil), **_); end

  def setup(context, options, as, block); end
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

module ActiveRecord::ReadonlyAttributes
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

module ActiveRecord::Reflection
end

class ActiveRecord::Reflection::AbstractReflection
  def actual_source_reflection(); end

  def alias_candidate(name); end

  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder=T.unsafe(nil)); end

  def chain(); end

  def check_validity_of_inverse!(); end

  def class_name(); end

  def constraints(); end

  def counter_cache_column(); end

  def counter_must_be_updated_by_has_many?(); end

  def get_join_keys(association_klass); end

  def has_cached_counter?(); end

  def inverse_of(); end

  def inverse_updates_counter_cache?(); end

  def inverse_updates_counter_in_memory?(); end

  def inverse_which_updates_counter_cache(); end

  def join_foreign_key(); end

  def join_keys(); end

  def join_primary_key(*_); end

  def join_scope(table, foreign_table, foreign_klass); end

  def join_scopes(table, predicate_builder); end

  def klass_join_scope(table, predicate_builder); end

  def scopes(); end

  def table_name(); end

  def through_reflection?(); end
end

class ActiveRecord::Reflection::AbstractReflection
end

class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end

  def active_record(); end

  def autosave=(autosave); end

  def compute_class(name); end

  def initialize(name, scope, options, active_record); end

  def klass(); end

  def name(); end

  def options(); end

  def plural_name(); end

  def scope(); end

  def scope_for(relation, owner=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::MacroReflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::ActiveStorage::Reflection::ReflectionExtension
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  include ::SorbetRails::CustomFinderMethods
  def ==(other); end

  def _deprecated_scope_source(); end

  def _deprecated_scope_source=(_deprecated_scope_source); end

  def _exec_scope(name, *args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def arel_attribute(name); end

  def bind_attribute(name, value); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def records(); end

  def reload(); end

  def reset(); end

  def scope_for_create(); end

  def scoping(); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(&blk); end

  def empty?(); end

  def first(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end

  def to_hash(); end
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  def define(info, &block); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(obj); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(obj); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  def version(); end
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::SecureToken
end

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def value(); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

module ActiveRecord::Store
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Suppressor
  def save(*_); end

  def save!(*_); end
end

module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern
end

class ActiveRecord::SuppressorRegistry
  def suppressed(); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.suppressed(*args, &block); end
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_attribute(column_name); end

  def associated_table(table_name); end

  def associated_with?(association_name); end

  def association_foreign_key(*args, &block); end

  def association_foreign_type(*args, &block); end

  def association_join_foreign_key(*args, &block); end

  def association_join_primary_key(*args, &block); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, association=T.unsafe(nil), types=T.unsafe(nil)); end

  def polymorphic_association?(); end

  def reflect_on_aggregation(aggregation_name); end

  def resolve_column_aliases(hash); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

module ActiveRecord::Tasks
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(namespace); end

  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_filename(namespace, format=T.unsafe(nil)); end

  def dump_schema(configuration, format=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrate_status(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def schema_file_type(format=T.unsafe(nil)); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def spec(); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(obj); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(obj); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

module ActiveRecord::Timestamp
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::TouchLater
  def touch(*names, time: T.unsafe(nil)); end

  def touch_later(*names); end
end

module ActiveRecord::TouchLater
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_); end

  def save!(*_); end

  def touch(*_); end

  def transaction(options=T.unsafe(nil), &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveRecord::Translation
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

class ActiveRecord::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::DecorationRegistration
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::Type::Internal
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveRecord::Type::Internal::Timezone
end

module ActiveRecord::Type::Internal
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

module ActiveRecord::Type
  def self.add_modifier(*args, &block); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::TypeCaster::Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(attr_name); end
end

class ActiveRecord::TypeCaster::Connection
end

class ActiveRecord::TypeCaster::Map
  def initialize(types); end

  def type_cast_for_database(attr_name, value); end
end

class ActiveRecord::TypeCaster::Map
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def save(options=T.unsafe(nil)); end

  def save!(options=T.unsafe(nil)); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveRecordOverrides
  include ::Singleton
  def enum_calls(); end

  def get_enum_call(klass, enum_sym); end

  def store_enum_call(klass, kwargs); end
end

class ActiveRecordOverrides
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(obj); end

  def binary_content_type(); end

  def binary_content_type=(obj); end

  def content_types_allowed_inline(); end

  def content_types_allowed_inline=(obj); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(obj); end

  def logger(); end

  def logger=(obj); end

  def paths(); end

  def paths=(obj); end

  def previewers(); end

  def previewers=(obj); end

  def queues(); end

  def queues=(obj); end

  def replace_on_assign_to_many(); end

  def replace_on_assign_to_many=(obj); end

  def routes_prefix(); end

  def routes_prefix=(obj); end

  def service_urls_expire_in(); end

  def service_urls_expire_in=(obj); end

  def variable_content_types(); end

  def variable_content_types=(obj); end

  def variant_processor(); end

  def variant_processor=(obj); end

  def verifier(); end

  def verifier=(obj); end
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::AnalyzeJob
end

class ActiveStorage::Analyzer
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Changes
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def reload(*_); end
end

module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, &block); end
end

class ActiveStorage::Attachment
  include ::ActiveStorage::Attachment::GeneratedAttributeMethods
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def purge(); end

  def purge_later(); end
end

class ActiveStorage::Attachment::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def build_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def reload_blob(); end

  def reload_record(); end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Attachment::GeneratedRelationMethods
end

module ActiveStorage::Attachment::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::BaseController
  include ::ActiveStorage::SetCurrent
end

class ActiveStorage::BaseController
end

class ActiveStorage::BaseJob
end

class ActiveStorage::BaseJob
end

class ActiveStorage::Blob
  include ::ActiveStorage::Blob::GeneratedAttributeMethods
  include ::ActiveStorage::Blob::Analyzable
  include ::ActiveStorage::Blob::Identifiable
  include ::ActionText::Attachable
  def after_add_for_attachments(); end

  def after_add_for_attachments=(val); end

  def after_add_for_attachments?(); end

  def after_remove_for_attachments(); end

  def after_remove_for_attachments=(val); end

  def after_remove_for_attachments?(); end

  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(); end

  def autosave_associated_records_for_preview_image_blob(); end

  def before_add_for_attachments(); end

  def before_add_for_attachments=(val); end

  def before_add_for_attachments?(); end

  def before_remove_for_attachments(); end

  def before_remove_for_attachments=(val); end

  def before_remove_for_attachments?(); end

  def download(&block); end

  def filename(); end

  def image?(); end

  def key(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service=(val); end

  def service?(); end

  def service_headers_for_direct_upload(); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def signed_id(); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def validate_associated_records_for_attachments(*args); end

  def video?(); end
end

class ActiveStorage::Blob::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::Analyzable
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids(); end

  def attachment_ids=(ids); end

  def build_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment!(*args, &block); end

  def reload_preview_image_attachment(); end

  def reload_preview_image_blob(); end
end

module ActiveStorage::Blob::GeneratedAttributeMethods
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::GeneratedRelationMethods
  def unattached(*args, &block); end

  def with_attached_preview_image(*args, &block); end
end

module ActiveStorage::Blob::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end
end

module ActiveStorage::Blob::Identifiable
end

module ActiveStorage::Blob::Representable
  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

module ActiveStorage::Blob::Representable
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Blob
  extend ::ActionText::Attachable::ClassMethods
  def self.after_add_for_attachments(); end

  def self.after_add_for_attachments=(val); end

  def self.after_add_for_attachments?(); end

  def self.after_remove_for_attachments(); end

  def self.after_remove_for_attachments=(val); end

  def self.after_remove_for_attachments?(); end

  def self.before_add_for_attachments(); end

  def self.before_add_for_attachments=(val); end

  def self.before_add_for_attachments?(); end

  def self.before_remove_for_attachments(); end

  def self.before_remove_for_attachments=(val); end

  def self.before_remove_for_attachments?(); end

  def self.build_after_unfurling(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.build_after_upload(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_after_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.find_signed(id); end

  def self.service(); end

  def self.service=(val); end

  def self.service?(); end
end

class ActiveStorage::BlobsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::BlobsController
end

class ActiveStorage::Current
end

class ActiveStorage::Current
  def self.host(); end

  def self.host=(attribute); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DirectUploadsController
end

class ActiveStorage::DiskController
  def show(); end

  def update(); end
end

class ActiveStorage::DiskController
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::Error
end

class ActiveStorage::Error
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::Filename
  include ::Comparable
  def as_json(*_); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::Preview
  def blob(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def processed(); end

  def service_url(**options); end

  def variation(); end
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview
end

class ActiveStorage::Previewer
  def blob(); end

  def initialize(blob); end

  def preview(); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

class ActiveStorage::PurgeJob
end

module ActiveStorage::Reflection
end

module ActiveStorage::Reflection::ActiveRecordExtensions
end

module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Reflection::HasManyAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasManyAttachedReflection
end

class ActiveStorage::Reflection::HasOneAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasOneAttachedReflection
end

module ActiveStorage::Reflection::ReflectionExtension
  def add_attachment_reflection(model, name, reflection); end
end

module ActiveStorage::Reflection::ReflectionExtension
end

module ActiveStorage::Reflection
end

class ActiveStorage::RepresentationsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::RepresentationsController
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def open(*args, &block); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end
end

module ActiveStorage::SetBlob
end

module ActiveStorage::SetBlob
  extend ::ActiveSupport::Concern
end

module ActiveStorage::SetCurrent
end

module ActiveStorage::SetCurrent
  extend ::ActiveSupport::Concern
end

module ActiveStorage::Transformers
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*args, &block); end

  def filename(*args, &block); end

  def format(*args, &block); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*args, &block); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
  WEB_IMAGE_CONTENT_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant
end

class ActiveStorage::Variation
  def initialize(transformations); end

  def key(); end

  def transform(file, format: T.unsafe(nil), &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  def self.analyzers(); end

  def self.analyzers=(obj); end

  def self.binary_content_type(); end

  def self.binary_content_type=(obj); end

  def self.content_types_allowed_inline(); end

  def self.content_types_allowed_inline=(obj); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.paths(); end

  def self.paths=(obj); end

  def self.previewers(); end

  def self.previewers=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.replace_on_assign_to_many(); end

  def self.replace_on_assign_to_many=(obj); end

  def self.routes_prefix(); end

  def self.routes_prefix=(obj); end

  def self.service_urls_expire_in(); end

  def self.service_urls_expire_in=(obj); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(obj); end

  def self.variant_processor(); end

  def self.variant_processor=(obj); end

  def self.verifier(); end

  def self.verifier=(obj); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end

  def test_order(); end

  def test_order=(obj); end
end

module ActiveSupport::ActionableError
end

module ActiveSupport::ActionableError
  extend ::ActiveSupport::Concern
  def self.actions(error); end

  def self.dispatch(error, name); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def autoloads(); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
  def self.extended(base); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::ConnectionPoolLike
  def with(); end
end

module ActiveSupport::Cache::ConnectionPoolLike
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def size(); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  def initialize(namespace: T.unsafe(nil), compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def mget_capable?(); end

  def mset_capable?(); end

  def redis(); end

  def redis_options(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end

  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

class ActiveSupport::CachingKeyGenerator
  def generate_key(*args); end

  def initialize(key_generator); end
end

class ActiveSupport::CachingKeyGenerator
end

module ActiveSupport::Callbacks
  def run_callbacks(kind); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::CompareWithRange
  def ===(value); end

  def cover?(value); end

  def include?(value); end
end

module ActiveSupport::CompareWithRange
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

module ActiveSupport::Concern
  def self.extended(base); end
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  def _eager_load_paths(); end

  def _eager_load_paths=(obj); end

  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def interlock(); end

  def interlock=(obj); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def log(message); end

  def logger(); end

  def logger=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def verbose(); end

  def verbose=(obj); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  def self.exclude_from(base); end

  def self.include_into(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end

  def self.include_into(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching(); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def autoloaded?(object); end

  def autoloaded_constants(); end

  def clear(); end

  def constantize(cpath); end

  def safe_constantize(cpath); end

  def unhook!(); end

  def verbose=(verbose); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
  def self.camelize(basename, _abspath); end

  def self.inflect(overrides); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def require_dependency(filename); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
  def self.take_over(enable_reloading:); end
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def self.load_interlock(); end

  def self.run_interlock(); end

  def self.unload_interlock(); end

  def self.verbose=(obj); end
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::InstanceDelegator
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

class ActiveSupport::DeprecationException
end

class ActiveSupport::DeprecationException
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
  include ::Enumerable
  def <<(klass); end

  def cleanup!(); end

  def each(&blk); end

  def refs_size(); end

  def reject!(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def -@(); end

  def after(time=T.unsafe(nil)); end

  def ago(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def from_now(time=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*args, &block); end

  def to_i(*args, &block); end

  def to_s(*args, &block); end

  def value(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

module ActiveSupport::EachTimeWithZone
end

class ActiveSupport::EncryptedConfiguration
  def [](*args, &block); end

  def config(); end

  def fetch(*args, &block); end

  def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:); end

  def method_missing(method, *args, &block); end
end

class ActiveSupport::EncryptedConfiguration
end

class ActiveSupport::EncryptedFile
  def change(&block); end

  def content_path(); end

  def env_key(); end

  def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:); end

  def key(); end

  def key_path(); end

  def raise_if_missing_key(); end

  def read(); end

  def write(contents); end
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile::MissingContentError
  def initialize(content_path); end
end

class ActiveSupport::EncryptedFile::MissingContentError
end

class ActiveSupport::EncryptedFile::MissingKeyError
  def initialize(key_path:, env_key:); end
end

class ActiveSupport::EncryptedFile::MissingKeyError
end

class ActiveSupport::EncryptedFile
  def self.generate_key(); end
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete!(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active(); end

  def self.active=(active); end

  def self.active?(); end

  def self.inherited(other); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*keys); end

  def without(*keys); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::IncludeTimeWithZone
  def include?(value); end
end

module ActiveSupport::IncludeTimeWithZone
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel
  def initialize(*args); end

  def silencer(); end

  def silencer=(obj); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.broadcast(logger); end

  def self.local_levels(); end

  def self.local_levels=(obj); end

  def self.logger_outputs_to?(logger, *sources); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerSilence
  def silence(temporary_level=T.unsafe(nil)); end
end

module ActiveSupport::LoggerSilence
  extend ::ActiveSupport::Concern
end

module ActiveSupport::LoggerThreadSafeLevel
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def after_initialize(); end

  def debug?(); end

  def error?(); end

  def fatal?(); end

  def info?(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def local_log_id(); end

  def unknown?(); end

  def warn?(); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
end

module ActiveSupport::MarshalWithAutoloading
  def load(source, proc=T.unsafe(nil)); end
end

module ActiveSupport::MarshalWithAutoloading
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def encrypt_and_sign(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

module ActiveSupport::MessageEncryptor::NullVerifier
end

module ActiveSupport::MessageEncryptor::NullVerifier
  def self.generate(value); end

  def self.verify(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(obj); end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def valid_message?(signed_message); end

  def verify(*args); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Messages
end

class ActiveSupport::Messages::Metadata
  def initialize(message, expires_at=T.unsafe(nil), purpose=T.unsafe(nil)); end

  def verify(purpose); end
end

class ActiveSupport::Messages::Metadata
  def self.verify(message, purpose); end

  def self.wrap(message, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::Messages::RotationConfiguration
  def encrypted(); end

  def rotate(kind, *args); end

  def signed(); end
end

class ActiveSupport::Messages::RotationConfiguration
end

module ActiveSupport::Messages::Rotator
  def initialize(*_, **options); end

  def rotate(*secrets, **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def verified(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Verifier
end

module ActiveSupport::Messages::Rotator
end

module ActiveSupport::Messages
end

module ActiveSupport::Multibyte
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORM_ALIASES = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def allocations(); end

  def children(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def end=(ending); end

  def finish!(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), &block); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(*_); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def pattern(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.event_object_subscriber(pattern, block); end

  def self.new(pattern, listener); end

  def self.wrap_all(pattern, subscriber); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(*args, &block); end

  def self.subscribed(callback, *args, &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
end

module ActiveSupport::NumericWithFormat
  def to_s(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::NumericWithFormat
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

class ActiveSupport::ParameterFilter
  def filter(params); end

  def filter_param(key, value); end

  def initialize(filters=T.unsafe(nil), mask: T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(params, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks, mask:); end

  def regexps(); end

  def value_for_key(key, value, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def self.compile(filters, mask:); end
end

class ActiveSupport::ParameterFilter
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Railtie
end

class ActiveSupport::Railtie
end

module ActiveSupport::RangeWithFormat
  def to_default_s(format=T.unsafe(nil)); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(val); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(val); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(val); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(val); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.detach_from(namespace, notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveRecord::TestDatabases
  include ::ActiveRecord::TestFixtures
  include ::ActiveJob::TestHelper
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def config(); end

  def config=(val); end

  def config?(); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def fixture_class_names(); end

  def fixture_class_names=(val); end

  def fixture_class_names?(); end

  def fixture_path(); end

  def fixture_path?(); end

  def fixture_table_names(); end

  def fixture_table_names=(val); end

  def fixture_table_names?(); end

  def lock_threads(); end

  def lock_threads=(val); end

  def lock_threads?(); end

  def method_name(); end

  def pre_loaded_fixtures(); end

  def pre_loaded_fixtures=(val); end

  def pre_loaded_fixtures?(); end

  def use_instantiated_fixtures(); end

  def use_instantiated_fixtures=(val); end

  def use_instantiated_fixtures?(); end

  def use_transactional_tests(); end

  def use_transactional_tests=(val); end

  def use_transactional_tests?(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  extend ::Rails::LineFiltering
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.config(); end

  def self.config=(val); end

  def self.config?(); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.fixture_class_names(); end

  def self.fixture_class_names=(val); end

  def self.fixture_class_names?(); end

  def self.fixture_path(); end

  def self.fixture_path=(val); end

  def self.fixture_path?(); end

  def self.fixture_table_names(); end

  def self.fixture_table_names=(val); end

  def self.fixture_table_names?(); end

  def self.lock_threads(); end

  def self.lock_threads=(val); end

  def self.lock_threads?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.pre_loaded_fixtures(); end

  def self.pre_loaded_fixtures=(val); end

  def self.pre_loaded_fixtures?(); end

  def self.test_order=(new_order); end

  def self.use_instantiated_fixtures(); end

  def self.use_instantiated_fixtures=(val); end

  def self.use_instantiated_fixtures?(); end

  def self.use_transactional_tests(); end

  def self.use_transactional_tests=(val); end

  def self.use_transactional_tests?(); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork(worker); end

  def after_fork_hooks(); end

  def initialize(queue_size); end

  def run_cleanup(worker); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
  def <<(o); end

  def length(); end

  def pop(); end

  def record(reporter, result); end
end

class ActiveSupport::Testing::Parallelization::Server
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::Stream
end

module ActiveSupport::Testing::Stream
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

module ActiveSupport::Testing
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def +(other); end

  def -(other); end

  def acts_like_time?(); end

  def advance(options); end

  def after?(_); end

  def ago(other); end

  def before?(_); end

  def between?(min, max); end

  def change(options); end

  def comparable_time(); end

  def day(); end

  def dst?(); end

  def encode_with(coder); end

  def eql?(other); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def future?(); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def hour(); end

  def httpdate(); end

  def in(other); end

  def in_time_zone(new_zone=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def mday(); end

  def method_missing(sym, *args, &block); end

  def min(); end

  def mon(); end

  def month(); end

  def nsec(); end

  def past?(); end

  def period(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc2822(); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def sec(); end

  def since(other); end

  def strftime(format); end

  def time(); end

  def time_zone(); end

  def to_a(); end

  def to_date(); end

  def to_datetime(); end

  def to_f(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_i(); end

  def to_r(); end

  def to_s(format=T.unsafe(nil)); end

  def to_time(); end

  def today?(); end

  def tv_sec(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def wday(); end

  def xmlschema(fraction_digits=T.unsafe(nil)); end

  def yday(); end

  def year(); end

  def zone(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(*args); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local(*args); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def today(); end

  def tomorrow(); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end

  def yesterday(); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.[](arg); end

  def self.all(); end

  def self.clear(); end

  def self.country_zones(country_code); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end

  def self.us_zones(); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(method_name=T.unsafe(nil), *args, &b); end

  def try!(method_name=T.unsafe(nil), *args, &b); end
end

module ActiveSupport::Tryable
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types=T.unsafe(nil)); end

  def to_h(); end
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter::DisallowedType
  def initialize(type); end
end

class ActiveSupport::XMLConverter::DisallowedType
end

class ActiveSupport::XMLConverter
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*args, &block); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.test_order(); end

  def self.test_order=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end

  def self.version(); end
end

class AddAllowConcurrencyToTasks
end

class AddBranchToPullRequests
end

class AddConfirmationsToTasks
end

class AddContinuousDeliveryDelayedSinceToStacks
end

class AddEncryptedTokenToUsers
end

class AddEnvToTasks
end

class AddEstimatedDeployDurationToStacks
end

class AddIgnoreCiToStack
end

class AddInaccessibleSinceToStacks
end

class AddIndexForStackActiveTask
end

class AddIndexesOnDeliveries
end

class AddLastDeployedAtToStack
end

class AddLastRevalidatedAtOnPullRequests
end

class AddLockedSinceToStacks
end

class AddLockedToCommits
end

class AddMergeQueueEnabledToStacks
end

class AddMergedAtOnPullRequests
end

class AddOutputColumnToTasks
end

class AddPullRequestNumberAndTitleToCommits
end

class AddRollbackWhenCompleteOnTask
end

class AddStartedAtAndEndedAtOnTasks
end

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
end

module Addressable
end

module AnsiStream
  VERSION = ::T.let(nil, ::T.untyped)
end

module AnsiStream::Rails
end

class AnsiStream::Rails::Engine
end

class AnsiStream::Rails::Engine
end

module AnsiStream::Rails
end

module AnsiStream
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def initialize(left, right); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def initialize(quoter, delegate_collector); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  include ::Arel::TreeManager::StatementMethods
  def from(relation); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def coalesce(*exprs); end

  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

class Arel::InsertManager
  def columns(); end

  def create_values(values); end

  def create_values_list(rows); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def infinite?(); end

  def initialize(value); end

  def unboundable?(); end

  def value(); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  def ==(other); end

  def case(); end

  def case=(_); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(values); end

  def values(); end
end

class Arel::Nodes::Comment
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def ==(other); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def left(); end

  def left=(left); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def right(); end

  def right=(right); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::NodeExpression
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::NodeExpression
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def infinite?(); end

  def val(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def comment(); end

  def comment=(comment); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def optimizer_hints(); end

  def optimizer_hints=(optimizer_hints); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(*args); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::ValuesList
  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def is_distinct_from(other); end

  def is_not_distinct_from(other); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def when(right); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def comment(*values); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def lateral(table_name=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def optimizer_hints(*hints); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attribute_name, value); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end

  def where(expr); end
end

module Arel::TreeManager::StatementMethods
  def key(); end

  def key=(key); end

  def offset(offset); end

  def order(*expr); end

  def take(limit); end

  def where(expr); end

  def wheres=(exprs); end
end

module Arel::TreeManager::StatementMethods
end

class Arel::TreeManager
end

class Arel::UpdateManager
  include ::Arel::TreeManager::StatementMethods
  def set(values); end

  def table(table); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
  def initialize(*_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object, collector=T.unsafe(nil)); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
  def initialize(inner_visitor, *args, &block); end
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Mocha::ArrayMethods
  def bsearch(); end

  def bsearch_index(); end

  def butfirst(); end

  def butlast(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_default_s(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

class AsciiOnlyValidator
end

module AttrEncrypted
  def attr_encrypted(*attributes); end

  def attr_encrypted?(attribute); end

  def attr_encrypted_options(); end

  def attr_encryptor(*attributes); end

  def attribute_instance_methods_as_symbols(); end

  def attribute_instance_methods_as_symbols_available?(); end

  def decrypt(attribute, encrypted_value, options=T.unsafe(nil)); end

  def encrypt(attribute, value, options=T.unsafe(nil)); end

  def encrypted_attributes(); end

  def method_missing(method, *arguments, &block); end

  def not_empty?(value); end
end

module AttrEncrypted::InstanceMethods
  def decode_salt_if_encoded(salt, encoding); end

  def decrypt(attribute, encrypted_value); end

  def encrypt(attribute, value); end

  def encrypted_attributes(); end

  def evaluate_attr_encrypted_option(option); end

  def evaluated_attr_encrypted_options_for(attribute); end

  def generate_iv(algorithm); end

  def load_iv_for_attribute(attribute, options); end

  def load_salt_for_attribute(attribute, options); end

  def prefix_and_encode_salt(salt, encoding); end
end

module AttrEncrypted::InstanceMethods
end

module AttrEncrypted::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
end

module AttrEncrypted::Version
  def self.string(); end
end

module AttrEncrypted
  def self.extended(base); end
end

module AutoprefixerRails
  VERSION = ::T.let(nil, ::T.untyped)
end

class AutoprefixerRails::Processor
  def info(); end

  def initialize(params=T.unsafe(nil)); end

  def parse_config(config); end

  def process(css, opts=T.unsafe(nil)); end
end

class AutoprefixerRails::Processor
end

class AutoprefixerRails::Result
  def css(); end

  def initialize(css, map, warnings); end

  def map(); end

  def warnings(); end
end

class AutoprefixerRails::Result
end

class AutoprefixerRails::Sprockets
  def initialize(filename, &block); end

  def render(_, _); end
end

class AutoprefixerRails::Sprockets
  def self.call(input); end

  def self.install(env); end

  def self.register_processor(processor); end

  def self.run(filename, css); end

  def self.uninstall(env); end
end

module AutoprefixerRails
  def self.install(assets, params=T.unsafe(nil)); end

  def self.process(css, opts=T.unsafe(nil)); end

  def self.processor(params=T.unsafe(nil)); end

  def self.uninstall(assets); end
end

module Axiom
end

module Axiom::Types
  Contradiction = ::T.let(nil, ::T.untyped)
  Tautology = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Axiom::Types::Array
end

class Axiom::Types::Array
end

class Axiom::Types::Boolean
end

class Axiom::Types::Boolean
end

class Axiom::Types::Class
end

class Axiom::Types::Class
end

class Axiom::Types::Collection
end

class Axiom::Types::Collection
  def self.member_type(*args); end
end

class Axiom::Types::Date
end

class Axiom::Types::Date
  extend ::Axiom::Types::ValueComparable
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::DateTime
  MAXIMUM_SECONDS = ::T.let(nil, ::T.untyped)
end

class Axiom::Types::DateTime
  extend ::Axiom::Types::ValueComparable
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::Decimal
end

class Axiom::Types::Decimal
end

module Axiom::Types::Encodable
  def finalize(); end
end

module Axiom::Types::Encodable
end

class Axiom::Types::Float
end

class Axiom::Types::Float
end

class Axiom::Types::Hash
end

class Axiom::Types::Hash
  def self.key_type(*args); end

  def self.value_type(*args); end
end

class Axiom::Types::Infinity
  include ::Singleton
  include ::Comparable
  def coerce(other); end

  def succ(); end
end

class Axiom::Types::Infinity
  extend ::DescendantsTracker
  extend ::Axiom::Types::Options
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end

  def self.inverse(*args); end

  def self.number(*args); end
end

class Axiom::Types::Integer
end

class Axiom::Types::Integer
end

module Axiom::Types::LengthComparable
  def finalize(); end

  def range(); end
end

module Axiom::Types::LengthComparable
  def self.extended(descendant); end
end

class Axiom::Types::NegativeInfinity
end

class Axiom::Types::NegativeInfinity
end

class Axiom::Types::Numeric
end

class Axiom::Types::Numeric
  extend ::Axiom::Types::ValueComparable
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::Object
end

class Axiom::Types::Object
  def self.coercion_method(*args); end

  def self.primitive(*args); end
end

module Axiom::Types::Options
  def accept_options(*new_options); end

  def setup_option(new_option); end
end

class Axiom::Types::Options::ReservedMethodError
end

class Axiom::Types::Options::ReservedMethodError
end

module Axiom::Types::Options
end

class Axiom::Types::Set
end

class Axiom::Types::Set
end

class Axiom::Types::String
end

class Axiom::Types::String
  extend ::Axiom::Types::Encodable
  extend ::Axiom::Types::LengthComparable
  def self.encoding(*args); end

  def self.maximum_length(*args); end

  def self.minimum_length(*args); end
end

class Axiom::Types::Symbol
end

class Axiom::Types::Symbol
  extend ::Axiom::Types::Encodable
  extend ::Axiom::Types::LengthComparable
  def self.encoding(*args); end

  def self.maximum_length(*args); end

  def self.minimum_length(*args); end
end

class Axiom::Types::Time
  MAXIMUM_SECONDS = ::T.let(nil, ::T.untyped)
  MINIMUM_SECONDS = ::T.let(nil, ::T.untyped)
end

class Axiom::Types::Time
  extend ::Axiom::Types::ValueComparable
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::Type
end

class Axiom::Types::Type
  extend ::DescendantsTracker
  extend ::Axiom::Types::Options
  def self.base(); end

  def self.base?(); end

  def self.constraint(constraint=T.unsafe(nil), &block); end

  def self.finalize(); end

  def self.include?(object); end

  def self.includes(*members); end

  def self.infer(object); end

  def self.new(*args, &block); end
end

module Axiom::Types::ValueComparable
  def finalize(); end

  def range(); end
end

module Axiom::Types::ValueComparable
  def self.extended(descendant); end
end

module Axiom::Types
  def self.finalize(); end

  def self.infer(object); end
end

module Axiom
end

class BackfillMergeCommits
end

class BackfillStackIdOnStatuses
end

class BasicObject
  def __binding__(); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

class BooleanString
end

class BooleanString
  def self.===(other); end
end

module BooleanStringImpl
  def _is_a_boolean_string?(); end

  def instance_of?(type); end

  def is_a?(type); end

  def kind_of?(type); end
end

module BooleanStringImpl
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  include ::Mocha::ClassMethods
  include ::StateMachines::MacroMethods
  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
end

class CodeRay::Scanners::Java
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Ruby
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def to_s(); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

class CodeRay::WordList::CaseIgnoring
end

class CodeRay::WordList
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

module Coercible
  EXTRA_CONST_ARGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer
  def [](klass); end

  def coercers(); end

  def config(); end

  def initialize(config, coercers=T.unsafe(nil)); end
end

class Coercible::Coercer::Array
  def to_set(value); end
  TIME_SEGMENTS = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer::Array
end

module Coercible::Coercer::Configurable
  def config(&block); end

  def config_name(); end

  def configuration_class(); end
end

module Coercible::Coercer::Configurable
  def self.extended(coercer); end
end

class Coercible::Coercer::Date
  include ::Coercible::Coercer::TimeCoercions
end

class Coercible::Coercer::Date
end

class Coercible::Coercer::DateTime
  include ::Coercible::Coercer::TimeCoercions
end

class Coercible::Coercer::DateTime
end

class Coercible::Coercer::Decimal
  FLOAT_FORMAT = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer::Decimal
end

class Coercible::Coercer::FalseClass
end

class Coercible::Coercer::FalseClass
end

class Coercible::Coercer::Float
  def to_datetime(value); end
end

class Coercible::Coercer::Float
end

class Coercible::Coercer::Hash
  def to_date(value); end

  def to_datetime(value); end

  def to_time(value); end
  TIME_SEGMENTS = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer::Hash
end

class Coercible::Coercer::Integer
  def boolean_map(); end

  def datetime_format(); end

  def datetime_proc(); end

  def initialize(coercer=T.unsafe(nil), config=T.unsafe(nil)); end

  def to_boolean(value); end

  def to_datetime(value); end
end

class Coercible::Coercer::Integer
  extend ::Coercible::Coercer::Configurable
  def self.config(); end

  def self.config_keys(value=T.unsafe(nil)); end
end

class Coercible::Coercer::Numeric
  def to_decimal(value); end

  def to_float(value); end
end

class Coercible::Coercer::Numeric
end

class Coercible::Coercer::Object
  def coerced?(value); end

  def coercers(); end

  def initialize(coercers=T.unsafe(nil)); end

  def to_array(value); end

  def to_hash(value); end

  def to_integer(value); end

  def to_string(value); end
  COERCION_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer::Object
  extend ::Coercible::Options
  extend ::DescendantsTracker
  extend ::Coercible::TypeLookup
  def self.primitive(value=T.unsafe(nil)); end
end

class Coercible::Coercer::String
  def boolean_map(); end

  def initialize(coercer=T.unsafe(nil), config=T.unsafe(nil)); end

  def to_boolean(value); end

  def to_constant(value); end

  def to_date(value); end

  def to_datetime(value); end

  def to_decimal(value); end

  def to_float(value); end

  def to_symbol(value); end

  def to_time(value); end
  BOOLEAN_MAP = ::T.let(nil, ::T.untyped)
  EXPONENT_REGEXP = ::T.let(nil, ::T.untyped)
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  FRACTIONAL_REGEXP = ::T.let(nil, ::T.untyped)
  INTEGER_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

class Coercible::Coercer::String
  extend ::Coercible::Coercer::Configurable
  def self.config(); end

  def self.config_keys(value=T.unsafe(nil)); end
end

class Coercible::Coercer::Symbol
end

class Coercible::Coercer::Symbol
end

class Coercible::Coercer::Time
  include ::Coercible::Coercer::TimeCoercions
end

class Coercible::Coercer::Time
end

module Coercible::Coercer::TimeCoercions
  def to_date(value); end

  def to_datetime(value); end

  def to_string(value); end

  def to_time(value); end
end

module Coercible::Coercer::TimeCoercions
end

class Coercible::Coercer::TrueClass
end

class Coercible::Coercer::TrueClass
end

class Coercible::Coercer
  def self.new(&block); end
end

class Coercible::Configuration
end

class Coercible::Configuration
  def self.build(keys, &block); end
end

module Coercible::Options
  def accept_options(*new_options); end

  def accepted_options(); end

  def add_accepted_options(new_options); end

  def define_option_method(option); end

  def options(); end

  def set_options(new_options); end
end

class Coercible::Options::Undefined
end

class Coercible::Options::Undefined
end

module Coercible::Options
  def self.extended(descendant); end
end

module Coercible::TypeLookup
  def determine_type(class_or_name); end

  def primitive(); end
  TYPE_FORMAT = ::T.let(nil, ::T.untyped)
end

module Coercible::TypeLookup
  def self.extended(model); end
end

class Coercible::UnsupportedCoercion
end

class Coercible::UnsupportedCoercion
end

module Coercible
  def self.rbx?(); end
end

module Coffee
end

module Coffee::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class Coffee::Rails::Engine
end

class Coffee::Rails::Engine
end

module Coffee::Rails::JsHook
end

module Coffee::Rails::JsHook
  extend ::ActiveSupport::Concern
end

class Coffee::Rails::TemplateHandler
end

class Coffee::Rails::TemplateHandler
  def self.call(template, source=T.unsafe(nil)); end

  def self.erb_handler(); end
end

module Coffee::Rails
end

module Coffee
end

module CoffeeScript
end

CoffeeScript::CompilationError = ExecJS::ProgramError

CoffeeScript::EngineError = ExecJS::RuntimeError

CoffeeScript::Error = ExecJS::Error

module CoffeeScript::Source
  COMPILE_FUNCTION_SOURCE = ::T.let(nil, ::T.untyped)
end

module CoffeeScript::Source
  def self.bare_option(); end

  def self.bundled_path(); end

  def self.contents(); end

  def self.context(); end

  def self.path(); end

  def self.path=(path); end

  def self.version(); end
end

module CoffeeScript
  def self.compile(script, options=T.unsafe(nil)); end

  def self.engine(); end

  def self.engine=(engine); end

  def self.version(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class CompositeReadIO
  def initialize(*ios); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class CompositeReadIO
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(*args, &block); end

  def kill(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(array); end

  def self.threadlocal_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::RbxAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

class ConvertStacksLockReasonToText
end

class ConvertStiColumns
end

module Coverage
  def self.peek_result(); end

  def self.running?(); end
end

module Crack
end

class Crack::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class Crack::JSON
  def self.convert_json_to_yaml(json); end

  def self.format_dates(output, date_starts, date_ends); end

  def self.parse(json); end

  def self.parser_exceptions(); end

  def self.unescape(str); end
end

class Crack::ParseError
end

class Crack::ParseError
end

class Crack::REXMLParser
end

class Crack::REXMLParser
  def self.parse(xml); end
end

module Crack::Util
  def snake_case(str); end

  def to_xml_attributes(hash); end
end

module Crack::Util
  extend ::Crack::Util
end

class Crack::XML
end

class Crack::XML
  def self.parse(xml); end

  def self.parser(); end

  def self.parser=(parser); end
end

module Crack
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

class CreateBaseline
end

class CreateShipitCommitDeploymentStatuses
end

class CreateShipitCommitDeployments
end

class CreateShipitPullRequests
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::Mocha::DateMethods
  def acts_like_date?(); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

module DateAndTime
end

module DateAndTime::Calculations
  def after?(date_or_time); end

  def all_day(); end

  def all_month(); end

  def all_quarter(); end

  def all_week(start_day=T.unsafe(nil)); end

  def all_year(); end

  def at_beginning_of_month(); end

  def at_beginning_of_quarter(); end

  def at_beginning_of_week(start_day=T.unsafe(nil)); end

  def at_beginning_of_year(); end

  def at_end_of_month(); end

  def at_end_of_quarter(); end

  def at_end_of_week(start_day=T.unsafe(nil)); end

  def at_end_of_year(); end

  def before?(date_or_time); end

  def beginning_of_month(); end

  def beginning_of_quarter(); end

  def beginning_of_week(start_day=T.unsafe(nil)); end

  def beginning_of_year(); end

  def days_ago(days); end

  def days_since(days); end

  def days_to_week_start(start_day=T.unsafe(nil)); end

  def end_of_month(); end

  def end_of_quarter(); end

  def end_of_week(start_day=T.unsafe(nil)); end

  def end_of_year(); end

  def future?(); end

  def last_month(); end

  def last_quarter(); end

  def last_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def last_weekday(); end

  def last_year(); end

  def monday(); end

  def months_ago(months); end

  def months_since(months); end

  def next_occurring(day_of_week); end

  def next_quarter(); end

  def next_week(given_day_in_next_week=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def next_weekday(); end

  def on_weekday?(); end

  def on_weekend?(); end

  def past?(); end

  def prev_occurring(day_of_week); end

  def prev_quarter(); end

  def prev_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def prev_weekday(); end

  def sunday(); end

  def today?(); end

  def tomorrow(); end

  def weeks_ago(weeks); end

  def weeks_since(weeks); end

  def years_ago(years); end

  def years_since(years); end

  def yesterday(); end
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
end

module DateAndTime::Compatibility
  def preserve_timezone(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(obj); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

module DateAndTime
end

class DateTime
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DeleteOrphanStatuses
end

class DenormalizeStackIdOnStatuses
end

module DescendantsTracker
  def add_descendant(descendant); end

  def descendants(); end
end

module DescendantsTracker
  def self.setup(descendant); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::DeprecatedIgnoredCallers
  def +(*_); end

  def <<(*_); end
end

class DidYouMean::DeprecatedIgnoredCallers
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_PREDEFINED_OBJECTS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.uuid_from_hash(hash_class, uuid_namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, &block); end

  def self.dsl_eval_immutable(dsl, *args, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, &block); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

Emitter = Psych::Stream::Emitter

module Emoji
  def all(); end

  def create(name); end

  def data_file(); end

  def edit_emoji(emoji); end

  def find_by_alias(name); end

  def find_by_unicode(unicode); end

  def images_path(); end
  VARIATION_SELECTOR_16 = ::T.let(nil, ::T.untyped)
end

class Emoji::Character
  def add_alias(name); end

  def add_tag(tag); end

  def add_unicode_alias(str); end

  def aliases(); end

  def custom?(); end

  def hex_inspect(); end

  def image_filename(); end

  def initialize(name); end

  def name(); end

  def raw(); end

  def tags(); end

  def unicode_aliases(); end
end

class Emoji::Character
  def self.hex_inspect(str); end
end

module Emoji
  extend ::Emoji
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Encryptor
  def crypt(cipher_method, *args); end

  def decrypt(*args, &block); end

  def default_options(); end

  def encrypt(*args, &block); end

  def encryption?(cipher_method); end

  def extract_auth_tag(value); end

  def extract_cipher_text(value); end
end

module Encryptor::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
end

module Encryptor::Version
end

module Encryptor
  extend ::Encryptor
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def average(default=T.unsafe(nil)); end

  def chunk(); end

  def chunk_while(); end

  def drop_last(n); end

  def drop_last_while(); end

  def each_entry(*_); end

  def exactly?(n); end

  def exclude?(object); end

  def excluding(*elements); end

  def frequencies(); end

  def grep_v(_); end

  def including(*elements); end

  def index_with(default=T.unsafe(nil)); end

  def many?(); end

  def pluck(*keys); end

  def several?(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def take_last(n); end

  def take_last_while(); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def without(*elements); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Equalizer
  def initialize(*keys); end
end

module Equalizer::Methods
  def ==(other); end

  def eql?(other); end
end

module Equalizer::Methods
end

class Equalizer
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
end

class Erubi::Engine
end

module Erubi
  def self.h(value); end
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  def __bb_context(); end

  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module ExecJS
  VERSION = ::T.let(nil, ::T.untyped)
end

class ExecJS::DisabledRuntime
end

class ExecJS::DisabledRuntime
end

class ExecJS::DuktapeRuntime
end

class ExecJS::DuktapeRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::DuktapeRuntime::Context
end

class ExecJS::DuktapeRuntime
end

module ExecJS::Encoding
  def encode(string); end
end

module ExecJS::Encoding
end

class ExecJS::Error
end

class ExecJS::Error
end

class ExecJS::ExternalRuntime
  def encode_source(source); end

  def encode_unicode_codepoints(str); end

  def exec_runtime(filename); end

  def exec_runtime_error(output); end

  def generate_compile_method(path); end

  def initialize(options); end

  def json2_source(); end

  def which(command); end
end

class ExecJS::ExternalRuntime::Context
  def call(identifier, *args); end

  def create_tempfile(basename); end

  def extract_result(output, filename); end

  def write_to_tempfile(contents); end
end

class ExecJS::ExternalRuntime::Context
end

class ExecJS::ExternalRuntime
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::MiniRacerRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::MiniRacerRuntime::Context
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::ProgramError
end

class ExecJS::ProgramError
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRacerRuntime::Context
  def unbox(value); end
end

class ExecJS::RubyRacerRuntime::Context
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::RubyRhinoRuntime::Context
  def unbox(value); end

  def wrap_error(e); end
end

class ExecJS::RubyRhinoRuntime::Context
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::Runtime
  def available?(); end

  def compile(source, options=T.unsafe(nil)); end

  def context_class(); end

  def deprecated?(); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def name(); end
end

class ExecJS::Runtime::Context
  include ::ExecJS::Encoding
  def call(properties, *args); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def initialize(runtime, source=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ExecJS::Runtime::Context
end

class ExecJS::Runtime
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeUnavailable
end

class ExecJS::RuntimeUnavailable
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  def self.autodetect(); end

  def self.best_available(); end

  def self.from_environment(); end

  def self.names(); end

  def self.runtimes(); end
end

module ExecJS
  def self.compile(source, options=T.unsafe(nil)); end

  def self.cygwin?(); end

  def self.eval(source, options=T.unsafe(nil)); end

  def self.exec(source, options=T.unsafe(nil)); end

  def self.root(); end

  def self.runtime(); end

  def self.runtime=(runtime); end

  def self.runtimes(); end

  def self.windows?(); end
end

class ExitCalledError
end

class ExitCalledError
end

module ExplicitParameters
  IS_RAILS5 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ExplicitParameters::BaseError
end

class ExplicitParameters::BaseError
end

module ExplicitParameters::Controller
  def params(); end
end

module ExplicitParameters::Controller
  extend ::ActiveSupport::Concern
  def self.last_parameters(); end

  def self.last_parameters=(last_parameters); end
end

class ExplicitParameters::InvalidParameters
end

class ExplicitParameters::InvalidParameters
end

class ExplicitParameters::Parameters
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::Enumerable
  def [](*args, &block); end

  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def each(*args, &block); end

  def model_name(*args, &block); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def stringify_keys(*args, &block); end

  def validate!(); end

  def validate_attribute_coercion!(attribute_name, value); end

  def validate_attribute_provided!(attribute_name, value); end

  def validation_context(); end
end

class ExplicitParameters::Parameters::CoercionValidator
end

class ExplicitParameters::Parameters::CoercionValidator
end

class ExplicitParameters::Parameters::RequiredValidator
end

class ExplicitParameters::Parameters::RequiredValidator
end

class ExplicitParameters::Parameters
  extend ::Virtus::ClassMethods
  extend ::Virtus::Extensions::Methods
  extend ::Virtus::ConstMissingExtensions
  extend ::Virtus::Extensions::AllowedWriterMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.accepts(name, type=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.define(name=T.unsafe(nil), &block); end

  def self.optional_attributes(); end

  def self.parse!(params); end

  def self.requires(name, type=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class ExplicitParameters::Railtie
end

class ExplicitParameters::Railtie
end

module ExplicitParameters
end

module Faker
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faker::Address
end

class Faker::Address
  def self.building_number(); end

  def self.city(legacy_options=T.unsafe(nil), options: T.unsafe(nil)); end

  def self.city_prefix(); end

  def self.city_suffix(); end

  def self.community(); end

  def self.country(); end

  def self.country_by_code(legacy_code=T.unsafe(nil), code: T.unsafe(nil)); end

  def self.country_code(); end

  def self.country_code_long(); end

  def self.country_name_to_code(legacy_name=T.unsafe(nil), name: T.unsafe(nil)); end

  def self.full_address(); end

  def self.latitude(); end

  def self.longitude(); end

  def self.postcode(legacy_state_abbreviation=T.unsafe(nil), state_abbreviation: T.unsafe(nil)); end

  def self.secondary_address(); end

  def self.state(); end

  def self.state_abbr(); end

  def self.street_address(legacy_include_secondary=T.unsafe(nil), include_secondary: T.unsafe(nil)); end

  def self.street_name(); end

  def self.street_suffix(); end

  def self.time_zone(); end

  def self.zip(legacy_state_abbreviation=T.unsafe(nil), state_abbreviation: T.unsafe(nil)); end

  def self.zip_code(legacy_state_abbreviation=T.unsafe(nil), state_abbreviation: T.unsafe(nil)); end
end

class Faker::Alphanumeric
  ALPHANUMS = ::T.let(nil, ::T.untyped)
end

class Faker::Alphanumeric
  def self.alpha(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.alphanumeric(legacy_number=T.unsafe(nil), number: T.unsafe(nil), min_alpha: T.unsafe(nil), min_numeric: T.unsafe(nil)); end
end

class Faker::Ancient
end

class Faker::Ancient
  def self.god(); end

  def self.hero(); end

  def self.primordial(); end

  def self.titan(); end
end

class Faker::App
end

class Faker::App
  def self.author(); end

  def self.semantic_version(legacy_major=T.unsafe(nil), legacy_minor=T.unsafe(nil), legacy_patch=T.unsafe(nil), major: T.unsafe(nil), minor: T.unsafe(nil), patch: T.unsafe(nil)); end

  def self.version(); end
end

class Faker::Appliance
end

class Faker::Appliance
  def self.brand(); end

  def self.equipment(); end
end

class Faker::Artist
end

class Faker::Artist
end

class Faker::Avatar
end

class Faker::Avatar
  def self.image(legacy_slug=T.unsafe(nil), legacy_size=T.unsafe(nil), legacy_format=T.unsafe(nil), legacy_set=T.unsafe(nil), legacy_bgset=T.unsafe(nil), slug: T.unsafe(nil), size: T.unsafe(nil), format: T.unsafe(nil), set: T.unsafe(nil), bgset: T.unsafe(nil)); end
end

class Faker::Bank
end

class Faker::Bank
  def self.account_number(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end

  def self.iban(legacy_country_code=T.unsafe(nil), country_code: T.unsafe(nil)); end

  def self.routing_number(); end

  def self.routing_number_with_format(); end

  def self.swift_bic(); end
end

class Faker::Base
  LLetters = ::T.let(nil, ::T.untyped)
  Letters = ::T.let(nil, ::T.untyped)
  Numbers = ::T.let(nil, ::T.untyped)
  ULetters = ::T.let(nil, ::T.untyped)
end

class Faker::Base
  def self.bothify(string); end

  def self.disable_enforce_available_locales(); end

  def self.fetch(key); end

  def self.fetch_all(key); end

  def self.flexible(key); end

  def self.letterify(letter_string); end

  def self.method_missing(mth, *args, &block); end

  def self.numerify(number_string, leading_zero: T.unsafe(nil)); end

  def self.parse(key); end

  def self.rand(max=T.unsafe(nil)); end

  def self.rand_in_range(from, to); end

  def self.regexify(reg); end

  def self.resolve(value); end

  def self.respond_to_missing?(method_name, include_private=T.unsafe(nil)); end

  def self.sample(list); end

  def self.shuffle(list); end

  def self.translate(*args); end

  def self.unique(max_retries=T.unsafe(nil)); end

  def self.with_locale(tmp_locale=T.unsafe(nil)); end
end

module Faker::Base58
end

module Faker::Base58
  def self.encode(str); end
end

class Faker::Beer
end

class Faker::Beer
  def self.alcohol(); end

  def self.blg(); end

  def self.hop(); end

  def self.ibu(); end

  def self.malts(); end

  def self.style(); end

  def self.yeast(); end
end

class Faker::Blockchain
end

class Faker::Blockchain::Bitcoin
end

class Faker::Blockchain::Bitcoin
  def self.address(); end

  def self.address_for(network); end

  def self.testnet_address(); end
end

class Faker::Blockchain::Ethereum
end

class Faker::Blockchain::Ethereum
  def self.address(); end
end

class Faker::Blockchain::Tezos
end

class Faker::Blockchain::Tezos
  def self.account(); end

  def self.block(); end

  def self.contract(); end

  def self.encode_tz(prefix, payload_size); end

  def self.operation(); end

  def self.signature(); end
end

class Faker::Blockchain
end

class Faker::Book
end

class Faker::Book
  def self.author(); end

  def self.genre(); end

  def self.publisher(); end

  def self.title(); end
end

class Faker::Books
end

class Faker::Books::CultureSeries
end

class Faker::Books::CultureSeries
  def self.book(); end

  def self.civ(); end

  def self.culture_ship(); end

  def self.culture_ship_class(); end

  def self.culture_ship_class_abv(); end

  def self.planet(); end
end

class Faker::Books::Dune
end

class Faker::Books::Dune
  def self.character(); end

  def self.planet(); end

  def self.quote(legacy_character=T.unsafe(nil), character: T.unsafe(nil)); end

  def self.saying(legacy_source=T.unsafe(nil), source: T.unsafe(nil)); end

  def self.title(); end
end

class Faker::Books::Lovecraft
end

class Faker::Books::Lovecraft
  def self.deity(); end

  def self.fhtagn(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.location(); end

  def self.paragraph(legacy_sentence_count=T.unsafe(nil), legacy_random_sentences_to_add=T.unsafe(nil), sentence_count: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil)); end

  def self.paragraph_by_chars(legacy_characters=T.unsafe(nil), characters: T.unsafe(nil)); end

  def self.paragraphs(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.sentence(legacy_word_count=T.unsafe(nil), legacy_random_words_to_add=T.unsafe(nil), word_count: T.unsafe(nil), random_words_to_add: T.unsafe(nil)); end

  def self.sentences(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.tome(); end

  def self.word(); end

  def self.words(legacy_number=T.unsafe(nil), legacy_spaces_allowed=T.unsafe(nil), number: T.unsafe(nil), spaces_allowed: T.unsafe(nil)); end
end

class Faker::Books
end

class Faker::Boolean
end

class Faker::Boolean
  def self.boolean(legacy_true_ratio=T.unsafe(nil), true_ratio: T.unsafe(nil)); end
end

class Faker::BossaNova
end

class Faker::BossaNova
  def self.artist(); end

  def self.song(); end
end

class Faker::Business
end

class Faker::Business
  def self.credit_card_expiry_date(); end

  def self.credit_card_number(); end

  def self.credit_card_type(); end
end

class Faker::Cannabis
end

class Faker::Cannabis
  def self.brand(); end

  def self.buzzword(); end

  def self.cannabinoid(); end

  def self.cannabinoid_abbreviation(); end

  def self.category(); end

  def self.health_benefit(); end

  def self.medical_use(); end

  def self.strain(); end

  def self.terpene(); end

  def self.type(); end
end

module Faker::Char
end

module Faker::Char
  def self.fix_umlauts(string); end

  def self.prepare(string); end

  def self.romanize_cyrillic(string); end
end

class Faker::ChileRut
end

class Faker::ChileRut
  def self.check_digit(); end

  def self.dv(); end

  def self.full_rut(legacy_min_rut=T.unsafe(nil), legacy_fixed=T.unsafe(nil), min_rut: T.unsafe(nil), fixed: T.unsafe(nil)); end

  def self.last_rut(); end

  def self.rut(legacy_min_rut=T.unsafe(nil), legacy_fixed=T.unsafe(nil), min_rut: T.unsafe(nil), fixed: T.unsafe(nil)); end
end

class Faker::ChuckNorris
end

class Faker::ChuckNorris
  def self.fact(); end
end

class Faker::Code
end

class Faker::Code
  def self.asin(); end

  def self.ean(legacy_base=T.unsafe(nil), base: T.unsafe(nil)); end

  def self.imei(); end

  def self.isbn(legacy_base=T.unsafe(nil), base: T.unsafe(nil)); end

  def self.npi(); end

  def self.nric(legacy_min_age=T.unsafe(nil), legacy_max_age=T.unsafe(nil), min_age: T.unsafe(nil), max_age: T.unsafe(nil)); end

  def self.rut(); end

  def self.sin(); end
end

class Faker::Coffee
end

class Faker::Coffee
  def self.blend_name(); end

  def self.intensifier(); end

  def self.notes(); end

  def self.origin(); end

  def self.variety(); end
end

class Faker::Coin
end

class Faker::Coin
  def self.flip(); end
end

class Faker::Color
end

class Faker::Color
  def self.color_name(); end

  def self.hex_color(); end

  def self.hsl_color(); end

  def self.hsla_color(); end

  def self.rgb_color(); end

  def self.single_rgb_color(); end
end

class Faker::Commerce
end

class Faker::Commerce
  def self.color(); end

  def self.department(legacy_max=T.unsafe(nil), legacy_fixed_amount=T.unsafe(nil), max: T.unsafe(nil), fixed_amount: T.unsafe(nil)); end

  def self.material(); end

  def self.price(legacy_range=T.unsafe(nil), legacy_as_string=T.unsafe(nil), range: T.unsafe(nil), as_string: T.unsafe(nil)); end

  def self.product_name(); end

  def self.promotion_code(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end
end

class Faker::Company
end

class Faker::Company
  def self.australian_business_number(); end

  def self.brazilian_company_number(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.bs(); end

  def self.buzzword(); end

  def self.catch_phrase(); end

  def self.czech_organisation_number(); end

  def self.duns_number(); end

  def self.ein(); end

  def self.french_siren_number(); end

  def self.french_siret_number(); end

  def self.industry(); end

  def self.logo(); end

  def self.norwegian_organisation_number(); end

  def self.polish_register_of_national_economy(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end

  def self.polish_taxpayer_identification_number(); end

  def self.profession(); end

  def self.sic_code(); end

  def self.south_african_close_corporation_registration_number(); end

  def self.south_african_listed_company_registration_number(); end

  def self.south_african_pty_ltd_registration_number(); end

  def self.south_african_trust_registration_number(); end

  def self.spanish_organisation_number(); end

  def self.suffix(); end

  def self.swedish_organisation_number(); end

  def self.type(); end
end

class Faker::Compass
end

class Faker::Compass
  def self.abbreviation(); end

  def self.azimuth(); end

  def self.cardinal(); end

  def self.cardinal_abbreviation(); end

  def self.cardinal_azimuth(); end

  def self.direction(); end

  def self.half_wind(); end

  def self.half_wind_abbreviation(); end

  def self.half_wind_azimuth(); end

  def self.ordinal(); end

  def self.ordinal_abbreviation(); end

  def self.ordinal_azimuth(); end

  def self.quarter_wind(); end

  def self.quarter_wind_abbreviation(); end

  def self.quarter_wind_azimuth(); end
end

class Faker::Config
end

class Faker::Config
  def self.locale(); end

  def self.locale=(locale); end

  def self.own_locale(); end

  def self.random(); end

  def self.random=(random); end
end

class Faker::Construction
end

class Faker::Construction
  def self.heavy_equipment(); end

  def self.material(); end

  def self.role(); end

  def self.standard_cost_code(); end

  def self.subcontract_category(); end

  def self.trade(); end
end

class Faker::Cosmere
end

class Faker::Cosmere
  def self.allomancer(); end

  def self.aon(); end

  def self.feruchemist(); end

  def self.herald(); end

  def self.knight_radiant(); end

  def self.metal(); end

  def self.shard(); end

  def self.shard_world(); end

  def self.spren(); end

  def self.surge(); end
end

class Faker::Creature
end

class Faker::Creature::Animal
end

class Faker::Creature::Animal
end

class Faker::Creature::Cat
end

class Faker::Creature::Cat
  def self.breed(); end

  def self.registry(); end
end

class Faker::Creature::Dog
end

class Faker::Creature::Dog
  def self.age(); end

  def self.breed(); end

  def self.coat_length(); end

  def self.gender(); end

  def self.meme_phrase(); end

  def self.size(); end

  def self.sound(); end
end

class Faker::Creature::Horse
end

class Faker::Creature::Horse
  def self.breed(); end
end

class Faker::Creature
end

class Faker::Crypto
end

class Faker::Crypto
  def self.md5(); end

  def self.sha1(); end

  def self.sha256(); end
end

class Faker::CryptoCoin
end

class Faker::CryptoCoin
  def self.acronym(legacy_coin=T.unsafe(nil), coin: T.unsafe(nil)); end

  def self.coin_array(); end

  def self.coin_hash(); end

  def self.coin_name(legacy_coin=T.unsafe(nil), coin: T.unsafe(nil)); end

  def self.url_logo(legacy_coin=T.unsafe(nil), coin: T.unsafe(nil)); end
end

class Faker::Currency
end

class Faker::Currency
  def self.code(); end

  def self.symbol(); end
end

class Faker::Date
end

class Faker::Date
  def self.backward(legacy_days=T.unsafe(nil), days: T.unsafe(nil)); end

  def self.between(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from:, to:); end

  def self.between_except(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), legacy_excepted=T.unsafe(nil), from:, to:, excepted:); end

  def self.birthday(legacy_min_age=T.unsafe(nil), legacy_max_age=T.unsafe(nil), min_age: T.unsafe(nil), max_age: T.unsafe(nil)); end

  def self.forward(legacy_days=T.unsafe(nil), days: T.unsafe(nil)); end
end

class Faker::DcComics
end

class Faker::DcComics
  def self.hero(); end

  def self.heroine(); end

  def self.title(); end

  def self.villain(); end
end

class Faker::Demographic
end

class Faker::Demographic
  def self.demonym(); end

  def self.educational_attainment(); end

  def self.height(legacy_unit=T.unsafe(nil), unit: T.unsafe(nil)); end

  def self.marital_status(); end

  def self.race(); end

  def self.sex(); end
end

class Faker::Dessert
end

class Faker::Dessert
  def self.flavor(); end

  def self.topping(); end

  def self.variety(); end
end

class Faker::Device
end

class Faker::Device
  def self.build_number(); end

  def self.manufacturer(); end

  def self.model_name(); end

  def self.platform(); end

  def self.serial(); end

  def self.version(); end
end

class Faker::DrivingLicence
  GB_PADDING = ::T.let(nil, ::T.untyped)
  NI_CHANCE = ::T.let(nil, ::T.untyped)
end

class Faker::DrivingLicence
  def self.british_driving_licence(legacy_last_name=T.unsafe(nil), legacy_initials=T.unsafe(nil), legacy_gender=T.unsafe(nil), legacy_date_of_birth=T.unsafe(nil), last_name: T.unsafe(nil), initials: T.unsafe(nil), gender: T.unsafe(nil), date_of_birth: T.unsafe(nil)); end

  def self.northern_irish_driving_licence(); end

  def self.uk_driving_licence(*args); end
end

class Faker::Educator
end

class Faker::Educator
  def self.campus(); end

  def self.course(); end

  def self.course_name(); end

  def self.degree(); end

  def self.secondary_school(); end

  def self.subject(); end

  def self.university(); end
end

class Faker::ElectricalComponents
end

class Faker::ElectricalComponents
  def self.active(); end

  def self.electromechanical(); end

  def self.passive(); end
end

class Faker::Esport
end

class Faker::Esport
  def self.event(); end

  def self.game(); end

  def self.league(); end

  def self.player(); end

  def self.team(); end
end

class Faker::File
end

class Faker::File
  def self.dir(legacy_segment_count=T.unsafe(nil), legacy_root=T.unsafe(nil), legacy_directory_separator=T.unsafe(nil), segment_count: T.unsafe(nil), root: T.unsafe(nil), directory_separator: T.unsafe(nil)); end

  def self.extension(); end

  def self.file_name(legacy_dir=T.unsafe(nil), legacy_name=T.unsafe(nil), legacy_ext=T.unsafe(nil), legacy_directory_separator=T.unsafe(nil), dir: T.unsafe(nil), name: T.unsafe(nil), ext: T.unsafe(nil), directory_separator: T.unsafe(nil)); end

  def self.mime_type(); end
end

class Faker::Fillmurray
end

class Faker::Fillmurray
  def self.image(legacy_grayscale=T.unsafe(nil), legacy_width=T.unsafe(nil), legacy_height=T.unsafe(nil), grayscale: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end
end

class Faker::Finance
  CREDIT_CARD_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::Finance
  def self.credit_card(*types); end

  def self.vat_number(legacy_country=T.unsafe(nil), country: T.unsafe(nil)); end

  def self.vat_number_keys(); end
end

class Faker::Food
end

class Faker::Food
  def self.description(); end

  def self.dish(); end

  def self.fruits(); end

  def self.ingredient(); end

  def self.measurement(); end

  def self.metric_measurement(); end

  def self.spice(); end

  def self.vegetables(); end
end

class Faker::FunnyName
end

class Faker::FunnyName
  def self.four_word_name(); end

  def self.name_with_initial(); end

  def self.three_word_name(); end

  def self.two_word_name(); end
end

class Faker::Game
end

class Faker::Game
  def self.genre(); end

  def self.platform(); end

  def self.title(); end
end

class Faker::Games
end

class Faker::Games::Dota
end

class Faker::Games::Dota
  def self.hero(); end

  def self.item(); end

  def self.player(); end

  def self.quote(legacy_hero=T.unsafe(nil), hero: T.unsafe(nil)); end

  def self.team(); end
end

class Faker::Games::ElderScrolls
end

class Faker::Games::ElderScrolls
  def self.city(); end

  def self.creature(); end

  def self.dragon(); end

  def self.first_name(); end

  def self.last_name(); end

  def self.race(); end

  def self.region(); end
end

class Faker::Games::Fallout
end

class Faker::Games::Fallout
  def self.character(); end

  def self.faction(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Games::HalfLife
end

class Faker::Games::HalfLife
  def self.character(); end

  def self.enemy(); end

  def self.location(); end
end

class Faker::Games::Heroes
end

class Faker::Games::Heroes
  def self.klass(); end

  def self.specialty(); end
end

class Faker::Games::HeroesOfTheStorm
end

class Faker::Games::HeroesOfTheStorm
  def self.battleground(); end

  def self.hero(); end

  def self.quote(); end
end

class Faker::Games::LeagueOfLegends
end

class Faker::Games::LeagueOfLegends
  def self.champion(); end

  def self.location(); end

  def self.masteries(); end

  def self.quote(); end

  def self.rank(); end

  def self.summoner_spell(); end
end

class Faker::Games::Myst
end

class Faker::Games::Myst
  def self.age(); end

  def self.character(); end

  def self.creature(); end

  def self.game(); end

  def self.quote(); end
end

class Faker::Games::Overwatch
end

class Faker::Games::Overwatch
  def self.hero(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Games::Pokemon
end

class Faker::Games::Pokemon
  def self.location(); end

  def self.move(); end
end

class Faker::Games::SonicTheHedgehog
end

class Faker::Games::SonicTheHedgehog
  def self.character(); end

  def self.game(); end

  def self.zone(); end
end

class Faker::Games::SuperSmashBros
end

class Faker::Games::SuperSmashBros
  def self.fighter(); end

  def self.stage(); end
end

class Faker::Games::Witcher
end

class Faker::Games::Witcher
  def self.character(); end

  def self.location(); end

  def self.monster(); end

  def self.quote(); end

  def self.school(); end

  def self.witcher(); end
end

class Faker::Games::WorldOfWarcraft
end

class Faker::Games::WorldOfWarcraft
  def self.hero(); end

  def self.quote(); end
end

class Faker::Games::Zelda
end

class Faker::Games::Zelda
  def self.character(); end

  def self.game(); end

  def self.item(); end

  def self.location(); end
end

class Faker::Games
end

class Faker::Gender
end

class Faker::Gender
  def self.binary_type(); end

  def self.type(); end
end

class Faker::GreekPhilosophers
end

class Faker::GreekPhilosophers
  def self.quote(); end
end

class Faker::Hacker
end

class Faker::Hacker
  def self.abbreviation(); end

  def self.adjective(); end

  def self.ingverb(); end

  def self.noun(); end

  def self.phrases(); end

  def self.say_something_smart(); end

  def self.verb(); end
end

class Faker::Hipster
end

class Faker::Hipster
  def self.paragraph(legacy_sentence_count=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_random_sentences_to_add=T.unsafe(nil), sentence_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil)); end

  def self.paragraph_by_chars(legacy_characters=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), characters: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.paragraphs(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.sentence(legacy_word_count=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_random_words_to_add=T.unsafe(nil), word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil)); end

  def self.sentences(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.word(); end

  def self.words(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_spaces_allowed=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil), spaces_allowed: T.unsafe(nil)); end
end

class Faker::House
end

class Faker::House
  def self.furniture(); end

  def self.room(); end
end

class Faker::IDNumber
  BRAZILIAN_ID_FORMAT = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_FROM = ::T.let(nil, ::T.untyped)
  BRAZILIAN_ID_TO = ::T.let(nil, ::T.untyped)
  CHECKS = ::T.let(nil, ::T.untyped)
  INVALID_SSN = ::T.let(nil, ::T.untyped)
  ZA_CITIZENSHIP_DIGITS = ::T.let(nil, ::T.untyped)
  ZA_RACE_DIGIT = ::T.let(nil, ::T.untyped)
end

class Faker::IDNumber
  def self.brazilian_citizen_number(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.brazilian_cpf(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.brazilian_id(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.brazilian_rg(legacy_formatted=T.unsafe(nil), formatted: T.unsafe(nil)); end

  def self.invalid(); end

  def self.invalid_south_african_id_number(); end

  def self.south_african_id_number(); end

  def self.spanish_citizen_number(); end

  def self.spanish_foreign_citizen_number(); end

  def self.ssn_valid(); end

  def self.valid(); end

  def self.valid_south_african_id_number(); end
end

class Faker::IndustrySegments
end

class Faker::IndustrySegments
  def self.industry(); end

  def self.sector(); end

  def self.sub_sector(); end

  def self.super_sector(); end
end

class Faker::Internet
end

class Faker::Internet
  def self.device_token(); end

  def self.domain_name(legacy_subdomain=T.unsafe(nil), subdomain: T.unsafe(nil)); end

  def self.domain_suffix(); end

  def self.domain_word(); end

  def self.email(legacy_name=T.unsafe(nil), legacy_separators=T.unsafe(nil), name: T.unsafe(nil), separators: T.unsafe(nil)); end

  def self.fix_umlauts(legacy_string=T.unsafe(nil), string: T.unsafe(nil)); end

  def self.free_email(legacy_name=T.unsafe(nil), name: T.unsafe(nil)); end

  def self.ip_v4_address(); end

  def self.ip_v4_cidr(); end

  def self.ip_v6_address(); end

  def self.ip_v6_cidr(); end

  def self.mac_address(legacy_prefix=T.unsafe(nil), prefix: T.unsafe(nil)); end

  def self.password(legacy_min_length=T.unsafe(nil), legacy_max_length=T.unsafe(nil), legacy_mix_case=T.unsafe(nil), legacy_special_characters=T.unsafe(nil), min_length: T.unsafe(nil), max_length: T.unsafe(nil), mix_case: T.unsafe(nil), special_characters: T.unsafe(nil)); end

  def self.private_ip_v4_address(); end

  def self.private_net_checker(); end

  def self.private_nets_regex(); end

  def self.public_ip_v4_address(); end

  def self.reserved_net_checker(); end

  def self.reserved_nets_regex(); end

  def self.safe_email(legacy_name=T.unsafe(nil), name: T.unsafe(nil)); end

  def self.slug(legacy_words=T.unsafe(nil), legacy_glue=T.unsafe(nil), words: T.unsafe(nil), glue: T.unsafe(nil)); end

  def self.url(legacy_host=T.unsafe(nil), legacy_path=T.unsafe(nil), legacy_scheme=T.unsafe(nil), host: T.unsafe(nil), path: T.unsafe(nil), scheme: T.unsafe(nil)); end

  def self.user_agent(legacy_vendor=T.unsafe(nil), vendor: T.unsafe(nil)); end

  def self.user_name(legacy_specifier=T.unsafe(nil), legacy_separators=T.unsafe(nil), specifier: T.unsafe(nil), separators: T.unsafe(nil)); end

  def self.username(legacy_specifier=T.unsafe(nil), legacy_separators=T.unsafe(nil), specifier: T.unsafe(nil), separators: T.unsafe(nil)); end

  def self.uuid(); end
end

class Faker::Invoice
end

class Faker::Invoice
  def self.amount_between(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.creditor_reference(legacy_ref=T.unsafe(nil), ref: T.unsafe(nil)); end

  def self.reference(legacy_ref=T.unsafe(nil), ref: T.unsafe(nil)); end
end

class Faker::JapaneseMedia
end

class Faker::JapaneseMedia::DragonBall
end

class Faker::JapaneseMedia::DragonBall
  def self.character(); end
end

class Faker::JapaneseMedia::OnePiece
end

class Faker::JapaneseMedia::OnePiece
  def self.akuma_no_mi(); end

  def self.character(); end

  def self.island(); end

  def self.location(); end

  def self.quote(); end

  def self.sea(); end
end

class Faker::JapaneseMedia::SwordArtOnline
end

class Faker::JapaneseMedia::SwordArtOnline
  def self.game_name(); end

  def self.item(); end

  def self.location(); end

  def self.real_name(); end
end

class Faker::JapaneseMedia
end

class Faker::Job
end

class Faker::Job
  def self.field(); end

  def self.key_skill(); end

  def self.position(); end

  def self.title(); end
end

class Faker::Json
end

class Faker::Json
  def self.add_depth_to_json(legacy_json=T.unsafe(nil), legacy_width=T.unsafe(nil), legacy_options=T.unsafe(nil), json: T.unsafe(nil), width: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.shallow_json(legacy_width=T.unsafe(nil), legacy_options=T.unsafe(nil), width: T.unsafe(nil), options: T.unsafe(nil)); end
end

class Faker::Kpop
end

class Faker::Kpop
  def self.boy_bands(); end

  def self.girl_groups(); end

  def self.i_groups(); end

  def self.ii_groups(); end

  def self.iii_groups(); end

  def self.solo(); end
end

class Faker::Lorem
end

class Faker::Lorem
  def self.character(); end

  def self.characters(legacy_number=T.unsafe(nil), number: T.unsafe(nil), min_alpha: T.unsafe(nil), min_numeric: T.unsafe(nil)); end

  def self.multibyte(); end

  def self.paragraph(legacy_sentence_count=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_random_sentences_to_add=T.unsafe(nil), sentence_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_sentences_to_add: T.unsafe(nil)); end

  def self.paragraph_by_chars(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.paragraphs(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.question(legacy_word_count=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_random_words_to_add=T.unsafe(nil), word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil)); end

  def self.questions(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.sentence(legacy_word_count=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), legacy_random_words_to_add=T.unsafe(nil), word_count: T.unsafe(nil), supplemental: T.unsafe(nil), random_words_to_add: T.unsafe(nil)); end

  def self.sentences(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end

  def self.word(); end

  def self.words(legacy_number=T.unsafe(nil), legacy_supplemental=T.unsafe(nil), number: T.unsafe(nil), supplemental: T.unsafe(nil)); end
end

class Faker::LoremFlickr
end

class Faker::LoremFlickr
  def self.colorized_image(legacy_size=T.unsafe(nil), legacy_color=T.unsafe(nil), legacy_search_terms=T.unsafe(nil), legacy_match_all=T.unsafe(nil), size: T.unsafe(nil), color: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.grayscale_image(legacy_size=T.unsafe(nil), legacy_search_terms=T.unsafe(nil), legacy_match_all=T.unsafe(nil), size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.image(legacy_size=T.unsafe(nil), legacy_search_terms=T.unsafe(nil), legacy_match_all=T.unsafe(nil), size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end

  def self.pixelated_image(legacy_size=T.unsafe(nil), legacy_search_terms=T.unsafe(nil), legacy_match_all=T.unsafe(nil), size: T.unsafe(nil), search_terms: T.unsafe(nil), match_all: T.unsafe(nil)); end
end

class Faker::LoremPixel
end

class Faker::LoremPixel
  def self.image(legacy_size=T.unsafe(nil), legacy_is_gray=T.unsafe(nil), legacy_category=T.unsafe(nil), legacy_number=T.unsafe(nil), legacy_text=T.unsafe(nil), legacy_secure=T.unsafe(nil), size: T.unsafe(nil), is_gray: T.unsafe(nil), category: T.unsafe(nil), number: T.unsafe(nil), text: T.unsafe(nil), secure: T.unsafe(nil)); end
end

class Faker::Markdown
end

class Faker::Markdown
  def self.block_code(); end

  def self.emphasis(); end

  def self.headers(); end

  def self.inline_code(); end

  def self.ordered_list(); end

  def self.random(*args); end

  def self.sandwich(legacy_sentences=T.unsafe(nil), legacy_repeat=T.unsafe(nil), sentences: T.unsafe(nil), repeat: T.unsafe(nil)); end

  def self.table(); end

  def self.unordered_list(); end
end

class Faker::Marketing
end

class Faker::Marketing
  def self.buzzwords(); end
end

class Faker::Measurement
end

class Faker::Measurement
  def self.height(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.length(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.metric_height(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.metric_length(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.metric_volume(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.metric_weight(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.volume(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end

  def self.weight(legacy_amount=T.unsafe(nil), amount: T.unsafe(nil)); end
end

class Faker::Military
end

class Faker::Military
  def self.air_force_rank(); end

  def self.army_rank(); end

  def self.dod_paygrade(); end

  def self.marines_rank(); end

  def self.navy_rank(); end
end

class Faker::Movie
end

class Faker::Movie
  def self.quote(); end
end

class Faker::Movies
end

class Faker::Movies::BackToTheFuture
end

class Faker::Movies::BackToTheFuture
  def self.character(); end

  def self.date(); end

  def self.quote(); end
end

class Faker::Movies::Ghostbusters
end

class Faker::Movies::Ghostbusters
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::HarryPotter
end

class Faker::Movies::HarryPotter
  def self.book(); end

  def self.character(); end

  def self.house(); end

  def self.location(); end

  def self.quote(); end

  def self.spell(); end
end

class Faker::Movies::HitchhikersGuideToTheGalaxy
end

class Faker::Movies::HitchhikersGuideToTheGalaxy
  def self.character(); end

  def self.location(); end

  def self.marvin_quote(); end

  def self.planet(); end

  def self.quote(); end

  def self.specie(); end

  def self.starship(); end
end

class Faker::Movies::Hobbit
end

class Faker::Movies::Hobbit
  def self.character(); end

  def self.location(); end

  def self.quote(); end

  def self.thorins_company(); end
end

class Faker::Movies::Lebowski
end

class Faker::Movies::Lebowski
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::LordOfTheRings
end

class Faker::Movies::LordOfTheRings
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::Movies::PrincessBride
end

class Faker::Movies::PrincessBride
  def self.character(); end

  def self.quote(); end
end

class Faker::Movies::StarWars
end

class Faker::Movies::StarWars
  def self.call_number(); end

  def self.call_numbers(); end

  def self.call_sign(); end

  def self.call_squadron(); end

  def self.call_squadrons(); end

  def self.character(); end

  def self.characters(); end

  def self.droid(); end

  def self.droids(); end

  def self.planet(); end

  def self.planets(); end

  def self.quote(legacy_character=T.unsafe(nil), character: T.unsafe(nil)); end

  def self.specie(); end

  def self.species(); end

  def self.vehicle(); end

  def self.vehicles(); end

  def self.wookie_sentence(); end

  def self.wookie_words(); end

  def self.wookiee_sentence(); end

  def self.wookiee_words(); end
end

class Faker::Movies::VForVendetta
end

class Faker::Movies::VForVendetta
  def self.character(); end

  def self.quote(); end

  def self.speech(); end
end

class Faker::Movies
end

class Faker::Music
end

class Faker::Music::GratefulDead
end

class Faker::Music::GratefulDead
  def self.player(); end

  def self.song(); end
end

class Faker::Music::Opera
end

class Faker::Music::Opera
  def self.bellini(); end

  def self.donizetti(); end

  def self.rossini(); end

  def self.verdi(); end
end

class Faker::Music::Phish
end

class Faker::Music::Phish
  def self.song(); end
end

class Faker::Music::RockBand
end

class Faker::Music::RockBand
end

class Faker::Music::UmphreysMcgee
end

class Faker::Music::UmphreysMcgee
  def self.song(); end
end

class Faker::Music
  def self.album(); end

  def self.band(); end

  def self.chord(); end

  def self.chord_types(); end

  def self.genre(); end

  def self.instrument(); end

  def self.key(); end

  def self.key_types(); end

  def self.key_variants(); end

  def self.keys(); end
end

class Faker::Name
end

class Faker::Name
  def self.female_first_name(); end

  def self.feminine_name(); end

  def self.first_name(); end

  def self.first_name_men(); end

  def self.first_name_women(); end

  def self.initials(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.last_name(); end

  def self.male_first_name(); end

  def self.masculine_name(); end

  def self.middle_name(); end

  def self.name_with_middle(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Nation
end

class Faker::Nation
  def self.capital_city(); end

  def self.flag(); end

  def self.language(); end

  def self.national_sport(); end

  def self.nationality(); end
end

class Faker::NationalHealthService
end

class Faker::NationalHealthService
  def self.british_number(); end

  def self.check_digit(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end
end

class Faker::NatoPhoneticAlphabet
end

class Faker::NatoPhoneticAlphabet
  def self.code_word(); end
end

class Faker::Number
end

class Faker::Number
  def self.between(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.decimal(legacy_l_digits=T.unsafe(nil), legacy_r_digits=T.unsafe(nil), l_digits: T.unsafe(nil), r_digits: T.unsafe(nil)); end

  def self.decimal_part(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end

  def self.digit(); end

  def self.hexadecimal(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end

  def self.leading_zero_number(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end

  def self.negative(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.non_zero_digit(); end

  def self.normal(legacy_mean=T.unsafe(nil), legacy_standard_deviation=T.unsafe(nil), mean: T.unsafe(nil), standard_deviation: T.unsafe(nil)); end

  def self.number(legacy_digits=T.unsafe(nil), digits: T.unsafe(nil)); end

  def self.positive(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.within(legacy_range=T.unsafe(nil), range: T.unsafe(nil)); end
end

class Faker::Omniauth
  def email(); end

  def first_name(); end

  def initialize(name: T.unsafe(nil), email: T.unsafe(nil)); end

  def last_name(); end

  def name(); end
end

class Faker::Omniauth
  def self.apple(name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.facebook(legacy_name=T.unsafe(nil), legacy_email=T.unsafe(nil), legacy_username=T.unsafe(nil), legacy_uid=T.unsafe(nil), name: T.unsafe(nil), email: T.unsafe(nil), username: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.github(legacy_name=T.unsafe(nil), legacy_email=T.unsafe(nil), legacy_uid=T.unsafe(nil), name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.google(legacy_name=T.unsafe(nil), legacy_email=T.unsafe(nil), legacy_uid=T.unsafe(nil), name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.linkedin(legacy_name=T.unsafe(nil), legacy_email=T.unsafe(nil), legacy_uid=T.unsafe(nil), name: T.unsafe(nil), email: T.unsafe(nil), uid: T.unsafe(nil)); end

  def self.twitter(legacy_name=T.unsafe(nil), legacy_nickname=T.unsafe(nil), legacy_uid=T.unsafe(nil), name: T.unsafe(nil), nickname: T.unsafe(nil), uid: T.unsafe(nil)); end
end

class Faker::PhoneNumber
end

class Faker::PhoneNumber
  def self.area_code(); end

  def self.cell_phone(); end

  def self.cell_phone_with_country_code(); end

  def self.country_code(); end

  def self.exchange_code(); end

  def self.extension(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end

  def self.phone_number(); end

  def self.phone_number_with_country_code(); end

  def self.subscriber_number(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end
end

class Faker::Placeholdit
end

class Faker::Placeholdit
  def self.image(legacy_size=T.unsafe(nil), legacy_format=T.unsafe(nil), legacy_background_color=T.unsafe(nil), legacy_text_color=T.unsafe(nil), legacy_text=T.unsafe(nil), size: T.unsafe(nil), format: T.unsafe(nil), background_color: T.unsafe(nil), text_color: T.unsafe(nil), text: T.unsafe(nil)); end
end

class Faker::ProgrammingLanguage
end

class Faker::ProgrammingLanguage
  def self.creator(); end
end

class Faker::Quote
end

class Faker::Quote
  def self.famous_last_words(); end

  def self.matz(); end

  def self.most_interesting_man_in_the_world(); end

  def self.robin(); end

  def self.singular_siegler(); end

  def self.yoda(); end
end

class Faker::Quotes
end

class Faker::Quotes::Shakespeare
end

class Faker::Quotes::Shakespeare
  def self.as_you_like_it(); end

  def self.as_you_like_it_quote(); end

  def self.hamlet(); end

  def self.hamlet_quote(); end

  def self.king_richard_iii(); end

  def self.king_richard_iii_quote(); end

  def self.romeo_and_juliet(); end

  def self.romeo_and_juliet_quote(); end
end

class Faker::Quotes
end

class Faker::Relationship
end

class Faker::Relationship
  def self.familial(legacy_connection=T.unsafe(nil), connection: T.unsafe(nil)); end

  def self.in_law(); end

  def self.sibling(); end

  def self.spouse(); end
end

class Faker::Restaurant
end

class Faker::Restaurant
end

class Faker::Science
end

class Faker::Science
  def self.element(); end

  def self.element_symbol(); end

  def self.scientist(); end
end

class Faker::SlackEmoji
end

class Faker::SlackEmoji
  def self.activity(); end

  def self.celebration(); end

  def self.custom(); end

  def self.emoji(); end

  def self.food_and_drink(); end

  def self.nature(); end

  def self.objects_and_symbols(); end

  def self.people(); end

  def self.travel_and_places(); end
end

class Faker::Source
end

class Faker::Source
  def self.hello_world(legacy_lang=T.unsafe(nil), lang: T.unsafe(nil)); end

  def self.print(legacy_str=T.unsafe(nil), legacy_lang=T.unsafe(nil), str: T.unsafe(nil), lang: T.unsafe(nil)); end

  def self.print_1_to_10(legacy_lang=T.unsafe(nil), lang: T.unsafe(nil)); end
end

class Faker::SouthAfrica
end

class Faker::SouthAfrica
  def self.cell_phone(); end

  def self.close_corporation_registration_number(); end

  def self.id_number(); end

  def self.invalid_id_number(); end

  def self.listed_company_registration_number(); end

  def self.phone_number(); end

  def self.pty_ltd_registration_number(); end

  def self.trust_registration_number(); end

  def self.valid_id_number(); end

  def self.vat_number(); end
end

class Faker::Space
end

class Faker::Space
  def self.agency(); end

  def self.agency_abv(); end

  def self.company(); end

  def self.constellation(); end

  def self.distance_measurement(); end

  def self.galaxy(); end

  def self.launch_vehicle(); end

  def self.meteorite(); end

  def self.moon(); end

  def self.nasa_space_craft(); end

  def self.nebula(); end

  def self.planet(); end

  def self.star(); end

  def self.star_cluster(); end
end

class Faker::Sports
end

class Faker::Sports::Basketball
end

class Faker::Sports::Basketball
  def self.coach(); end

  def self.player(); end

  def self.position(); end

  def self.team(); end
end

class Faker::Sports::Football
end

class Faker::Sports::Football
  def self.coach(); end

  def self.competition(); end

  def self.player(); end

  def self.position(); end

  def self.team(); end
end

class Faker::Sports
end

class Faker::String
end

class Faker::String
  def self.random(legacy_length=T.unsafe(nil), length: T.unsafe(nil)); end
end

class Faker::Stripe
end

class Faker::Stripe
  def self.ccv(legacy_card_type=T.unsafe(nil), card_type: T.unsafe(nil)); end

  def self.invalid_card(legacy_card_error=T.unsafe(nil), card_error: T.unsafe(nil)); end

  def self.month(); end

  def self.valid_card(legacy_card_type=T.unsafe(nil), card_type: T.unsafe(nil)); end

  def self.valid_token(legacy_card_type=T.unsafe(nil), card_type: T.unsafe(nil)); end

  def self.year(); end
end

class Faker::Subscription
end

class Faker::Subscription
  def self.payment_method(); end

  def self.payment_term(); end

  def self.plan(); end

  def self.status(); end

  def self.subscription_term(); end
end

class Faker::Superhero
end

class Faker::Superhero
  def self.descriptor(); end

  def self.power(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Team
end

class Faker::Team
  def self.creature(); end

  def self.mascot(); end

  def self.sport(); end

  def self.state(); end
end

class Faker::Time
  TIME_RANGES = ::T.let(nil, ::T.untyped)
end

class Faker::Time
  def self.backward(legacy_days=T.unsafe(nil), legacy_period=T.unsafe(nil), legacy_format=T.unsafe(nil), days: T.unsafe(nil), period: T.unsafe(nil), format: T.unsafe(nil)); end

  def self.between(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), legacy_format=T.unsafe(nil), from:, to:, format: T.unsafe(nil)); end

  def self.between_dates(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), legacy_period=T.unsafe(nil), legacy_format=T.unsafe(nil), from:, to:, period: T.unsafe(nil), format: T.unsafe(nil)); end

  def self.forward(legacy_days=T.unsafe(nil), legacy_period=T.unsafe(nil), legacy_format=T.unsafe(nil), days: T.unsafe(nil), period: T.unsafe(nil), format: T.unsafe(nil)); end
end

class Faker::TvShows
end

class Faker::TvShows::AquaTeenHungerForce
end

class Faker::TvShows::AquaTeenHungerForce
  def self.character(); end
end

class Faker::TvShows::BojackHorseman
end

class Faker::TvShows::BojackHorseman
  def self.character(); end

  def self.quote(); end

  def self.tongue_twister(); end
end

class Faker::TvShows::BreakingBad
end

class Faker::TvShows::BreakingBad
  def self.character(); end

  def self.episode(); end
end

class Faker::TvShows::Buffy
end

class Faker::TvShows::Buffy
  def self.big_bad(); end

  def self.celebrity(); end

  def self.character(); end

  def self.episode(); end

  def self.quote(); end
end

class Faker::TvShows::Community
end

class Faker::TvShows::Community
  def self.characters(); end

  def self.quotes(); end
end

class Faker::TvShows::DrWho
end

class Faker::TvShows::DrWho
  def self.actor(); end

  def self.catch_phrase(); end

  def self.character(); end

  def self.quote(); end

  def self.specie(); end

  def self.the_doctor(); end

  def self.villian(); end
end

class Faker::TvShows::DumbAndDumber
end

class Faker::TvShows::DumbAndDumber
  def self.actor(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::FamilyGuy
end

class Faker::TvShows::FamilyGuy
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::Friends
end

class Faker::TvShows::Friends
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::GameOfThrones
end

class Faker::TvShows::GameOfThrones
  def self.character(); end

  def self.city(); end

  def self.dragon(); end

  def self.house(); end

  def self.quote(); end
end

class Faker::TvShows::HeyArnold
end

class Faker::TvShows::HeyArnold
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::HowIMetYourMother
end

class Faker::TvShows::HowIMetYourMother
  def self.catch_phrase(); end

  def self.character(); end

  def self.high_five(); end

  def self.quote(); end
end

class Faker::TvShows::MichaelScott
end

class Faker::TvShows::MichaelScott
  def self.quote(); end
end

class Faker::TvShows::NewGirl
end

class Faker::TvShows::NewGirl
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::ParksAndRec
end

class Faker::TvShows::ParksAndRec
  def self.character(); end

  def self.city(); end
end

class Faker::TvShows::RickAndMorty
end

class Faker::TvShows::RickAndMorty
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::RuPaul
end

class Faker::TvShows::RuPaul
  def self.queen(); end

  def self.quote(); end
end

class Faker::TvShows::Seinfeld
end

class Faker::TvShows::Seinfeld
  def self.business(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::SiliconValley
end

class Faker::TvShows::SiliconValley
  def self.app(); end

  def self.character(); end

  def self.company(); end

  def self.email(); end

  def self.invention(); end

  def self.motto(); end

  def self.quote(); end

  def self.url(); end
end

class Faker::TvShows::Simpsons
end

class Faker::TvShows::Simpsons
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::SouthPark
end

class Faker::TvShows::SouthPark
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::StarTrek
end

class Faker::TvShows::StarTrek
  def self.character(); end

  def self.location(); end

  def self.specie(); end

  def self.villain(); end
end

class Faker::TvShows::Stargate
end

class Faker::TvShows::Stargate
  def self.character(); end

  def self.planet(); end

  def self.quote(); end
end

class Faker::TvShows::StrangerThings
end

class Faker::TvShows::StrangerThings
  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::TheExpanse
end

class Faker::TvShows::TheExpanse
  def self.character(); end

  def self.location(); end

  def self.quote(); end

  def self.ship(); end
end

class Faker::TvShows::TheFreshPrinceOfBelAir
end

class Faker::TvShows::TheFreshPrinceOfBelAir
  def self.celebrity(); end

  def self.character(); end

  def self.quote(); end
end

class Faker::TvShows::TheITCrowd
end

class Faker::TvShows::TheITCrowd
  def self.actor(); end

  def self.character(); end

  def self.email(); end

  def self.quote(); end
end

class Faker::TvShows::TheThickOfIt
end

class Faker::TvShows::TheThickOfIt
  def self.character(); end

  def self.department(); end

  def self.position(); end
end

class Faker::TvShows::TwinPeaks
end

class Faker::TvShows::TwinPeaks
  def self.character(); end

  def self.location(); end

  def self.quote(); end
end

class Faker::TvShows::VentureBros
end

class Faker::TvShows::VentureBros
  def self.character(); end

  def self.organization(); end

  def self.quote(); end

  def self.vehicle(); end
end

class Faker::TvShows
end

class Faker::Twitter
end

class Faker::Twitter
  def self.screen_name(); end

  def self.status(legacy_include_user=T.unsafe(nil), legacy_include_photo=T.unsafe(nil), include_user: T.unsafe(nil), include_photo: T.unsafe(nil)); end

  def self.user(legacy_include_status=T.unsafe(nil), legacy_include_email=T.unsafe(nil), include_status: T.unsafe(nil), include_email: T.unsafe(nil)); end
end

class Faker::Types
  CHARACTERS = ::T.let(nil, ::T.untyped)
  COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  SIMPLE_TYPES = ::T.let(nil, ::T.untyped)
end

class Faker::Types
  def self.character(); end

  def self.complex_rb_hash(legacy_number=T.unsafe(nil), number: T.unsafe(nil)); end

  def self.random_complex_type(); end

  def self.random_type(); end

  def self.rb_array(legacy_len=T.unsafe(nil), len: T.unsafe(nil)); end

  def self.rb_hash(legacy_number=T.unsafe(nil), legacy_type=T.unsafe(nil), number: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.rb_integer(legacy_from=T.unsafe(nil), legacy_to=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.rb_string(legacy_words=T.unsafe(nil), words: T.unsafe(nil)); end
end

class Faker::UniqueGenerator
  def clear(); end

  def exclude(name, arguments, values); end

  def initialize(generator, max_retries); end

  def method_missing(name, *arguments); end
end

class Faker::UniqueGenerator::RetryLimitExceeded
end

class Faker::UniqueGenerator::RetryLimitExceeded
end

class Faker::UniqueGenerator
  def self.clear(); end

  def self.marked_unique(); end
end

class Faker::University
end

class Faker::University
  def self.greek_alphabet(); end

  def self.greek_organization(); end

  def self.prefix(); end

  def self.suffix(); end
end

class Faker::Vehicle
  MILEAGE_MAX = ::T.let(nil, ::T.untyped)
  MILEAGE_MIN = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_CHARS = ::T.let(nil, ::T.untyped)
  SG_CHECKSUM_WEIGHTS = ::T.let(nil, ::T.untyped)
  VIN_LETTERS = ::T.let(nil, ::T.untyped)
  VIN_MAP = ::T.let(nil, ::T.untyped)
  VIN_REGEX = ::T.let(nil, ::T.untyped)
  VIN_WEIGHTS = ::T.let(nil, ::T.untyped)
end

class Faker::Vehicle
  def self.car_options(); end

  def self.car_type(); end

  def self.color(); end

  def self.door_count(); end

  def self.doors(); end

  def self.drive_type(); end

  def self.engine(); end

  def self.engine_size(); end

  def self.fuel_type(); end

  def self.kilometrage(legacy_min=T.unsafe(nil), legacy_max=T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.license_plate(legacy_state_abreviation=T.unsafe(nil), state_abreviation: T.unsafe(nil)); end

  def self.make(); end

  def self.make_and_model(); end

  def self.manufacture(); end

  def self.mileage(legacy_min=T.unsafe(nil), legacy_max=T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.model(legacy_make_of_model=T.unsafe(nil), make_of_model: T.unsafe(nil)); end

  def self.singapore_license_plate(); end

  def self.standard_specs(); end

  def self.style(); end

  def self.transmission(); end

  def self.vin(); end

  def self.year(); end
end

class Faker::Verb
end

class Faker::Verb
  def self.base(); end

  def self.ing_form(); end

  def self.past(); end

  def self.past_participle(); end

  def self.simple_present(); end
end

class Faker::WorldCup
end

class Faker::WorldCup
  def self.city(); end

  def self.group(legacy_group=T.unsafe(nil), group: T.unsafe(nil)); end

  def self.roster(legacy_country=T.unsafe(nil), legacy_type=T.unsafe(nil), country: T.unsafe(nil), type: T.unsafe(nil)); end

  def self.stadium(); end

  def self.team(); end
end

module Faker
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::SafeType::BooleanMixin
end

module Faraday
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  def call(env); end

  def initialize(app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(&block); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def create_connection(env, opts); end

  def read_body(env); end
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def client(); end

  def configure_client(); end

  def configure_proxy(proxy); end

  def configure_socket(bind); end

  def configure_ssl(ssl); end

  def configure_timeouts(req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
end

class Faraday::Adapter::NetHttpPersistent
end

class Faraday::Adapter::NetHttpPersistent
end

module Faraday::Adapter::Parallelism
  def inherited(subclass); end

  def supports_parallel=(supports_parallel); end

  def supports_parallel?(); end
end

module Faraday::Adapter::Parallelism
end

class Faraday::Adapter::Patron
  def configure_ssl(session, ssl); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def execute_request(env, rack_env); end

  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Adapter
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper
end

module Faraday::AutoloadHelper
  def all_loaded_constants(); end

  def autoload_all(prefix, options); end

  def load_autoloaded_constants(); end
end

module Faraday::AutoloadHelper
end

class Faraday::BadRequestError
end

class Faraday::BadRequestError
end

class Faraday::ClientError
end

class Faraday::ClientError
end

class Faraday::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::CompositeReadIO
end

class Faraday::ConflictError
end

class Faraday::ConflictError
end

class Faraday::Connection
  def adapter(*args, &block); end

  def app(*args, &block); end

  def authorization(type, token); end

  def basic_auth(login, pass); end

  def build(*args, &block); end

  def build_exclusive_url(url=T.unsafe(nil), params=T.unsafe(nil), params_encoder=T.unsafe(nil)); end

  def build_request(method); end

  def build_url(url=T.unsafe(nil), extra_params=T.unsafe(nil)); end

  def builder(); end

  def default_parallel_manager(); end

  def default_parallel_manager=(default_parallel_manager); end

  def delete(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def find_default_proxy(); end

  def get(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def head(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def headers(); end

  def headers=(hash); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def in_parallel(manager=T.unsafe(nil)); end

  def in_parallel?(); end

  def initialize(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def parallel_manager(); end

  def params(); end

  def params=(hash); end

  def patch(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def path_prefix(*args, &block); end

  def path_prefix=(value); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def post(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def proxy(arg=T.unsafe(nil)); end

  def proxy=(new_value); end

  def proxy_for_request(url); end

  def proxy_from_env(url); end

  def put(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def request(*args, &block); end

  def response(*args, &block); end

  def run_request(method, url, body, headers); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def set_authorization_header(header_type, *args); end

  def ssl(); end

  def token_auth(token, options=T.unsafe(nil)); end

  def url_prefix(); end

  def url_prefix=(url, encoder=T.unsafe(nil)); end

  def use(*args, &block); end

  def with_uri_credentials(uri); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Connection
  extend ::Forwardable
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionOptions
  def new_builder(block); end
end

class Faraday::ConnectionOptions
end

module Faraday::Deprecate
end

module Faraday::Deprecate
  def self.deprecate(name, repl, ver); end

  def self.skip(); end

  def self.skip=(value); end

  def self.skip_during(); end
end

module Faraday::DeprecatedClass
end

module Faraday::DeprecatedClass
  def self.proxy_class(origclass, ver=T.unsafe(nil)); end
end

class Faraday::Env
  def []=(key, value); end

  def clear_body(); end

  def custom_members(); end

  def in_member_set?(key); end

  def needs_body?(); end

  def parallel?(); end

  def params_encoder(*args, &block); end

  def parse_body?(); end

  def success?(); end
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  extend ::Forwardable
  def self.member_set(); end
end

class Faraday::Error
  def exc_msg_and_response(exc, response=T.unsafe(nil)); end

  def exc_msg_and_response!(exc, response=T.unsafe(nil)); end

  def initialize(exc, response=T.unsafe(nil)); end

  def response(); end

  def wrapped_exception(); end
end

class Faraday::Error::ClientError
end

class Faraday::Error::ClientError
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::ConnectionFailed
end

class Faraday::Error::ConnectionFailed
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::ParsingError
end

class Faraday::Error::ParsingError
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::ResourceNotFound
end

class Faraday::Error::ResourceNotFound
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::RetriableResponse
end

class Faraday::Error::RetriableResponse
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::SSLError
end

class Faraday::Error::SSLError
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error::TimeoutError
end

class Faraday::Error::TimeoutError
  def self.===(other); end

  def self._deprecated_new(*_); end

  def self.inherited(*args, &block); end

  def self.new(*args, &block); end
end

class Faraday::Error
end

module Faraday::FlatParamsEncoder
end

module Faraday::FlatParamsEncoder
  def self.decode(query); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::ForbiddenError
end

class Faraday::ForbiddenError
end

class Faraday::HttpCache
  def call(env); end

  def call!(env); end

  def create_storage(options); end

  def initialize(app, options=T.unsafe(nil)); end

  def request(); end

  def storage(); end
  CACHE_STATUSES = ::T.let(nil, ::T.untyped)
  ERROR_STATUSES = ::T.let(nil, ::T.untyped)
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  UNSAFE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache::CacheControl
  def initialize(header); end

  def max_age(); end

  def must_revalidate?(); end

  def no_cache?(); end

  def no_store?(); end

  def normalize_max_ages(age); end

  def private?(); end

  def proxy_revalidate?(); end

  def public?(); end

  def s_maxage(); end

  def shared_max_age(); end
end

class Faraday::HttpCache::CacheControl
end

class Faraday::HttpCache::MemoryStore
  def delete(key); end

  def read(key); end

  def write(key, value); end
end

class Faraday::HttpCache::MemoryStore
end

class Faraday::HttpCache::Request
  def cache_control(); end

  def cacheable?(); end

  def headers(); end

  def initialize(options); end

  def method(); end

  def no_cache?(); end

  def serializable_hash(); end

  def url(); end
end

class Faraday::HttpCache::Request
  def self.from_env(env); end
end

class Faraday::HttpCache::Response
  def age(); end

  def cacheable_in_private_cache?(); end

  def cacheable_in_shared_cache?(); end

  def date(); end

  def etag(); end

  def fresh?(); end

  def initialize(payload=T.unsafe(nil)); end

  def last_modified(); end

  def max_age(); end

  def not_modified?(); end

  def payload(); end

  def serializable_hash(); end

  def to_response(env); end

  def ttl(); end
  CACHEABLE_STATUS_CODES = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache::Response
end

class Faraday::HttpCache::Storage
  def cache(); end

  def delete(url); end

  def initialize(options=T.unsafe(nil)); end

  def read(request, klass=T.unsafe(nil)); end

  def write(request, response); end
end

class Faraday::HttpCache::Storage
end

class Faraday::HttpCache
end

class Faraday::Middleware
  def initialize(app=T.unsafe(nil)); end
end

class Faraday::Middleware
  extend ::Faraday::MiddlewareRegistry
  def self.dependency(lib=T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.load_error(); end

  def self.loaded?(); end
end

module Faraday::MiddlewareRegistry
  def fetch_middleware(key); end

  def load_middleware(key); end

  def lookup_middleware(key); end

  def middleware_mutex(&block); end

  def register_middleware(autoload_path=T.unsafe(nil), mapping=T.unsafe(nil)); end
end

module Faraday::MiddlewareRegistry
end

module Faraday::NestedParamsEncoder
end

module Faraday::NestedParamsEncoder
  def self.decode(query); end

  def self.dehash(hash, depth); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::NilStatusError
  def unwrap_resp(*args, &block); end
end

class Faraday::NilStatusError
  extend ::Faraday::Deprecate
end

class Faraday::Options
  def [](key); end

  def clear(); end

  def delete(key); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, *args); end

  def has_key?(key); end

  def has_value?(value); end

  def key?(key); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def symbolized_key_set(); end

  def to_hash(); end

  def update(obj); end

  def value?(value); end

  def values_at(*keys); end
end

class Faraday::Options
  def self.attribute_options(); end

  def self.fetch_error_class(); end

  def self.from(value); end

  def self.inherited(subclass); end

  def self.memoized(key, &block); end

  def self.memoized_attributes(); end

  def self.options(mapping); end

  def self.options_for(key); end
end

class Faraday::ParsingError
end

class Faraday::ParsingError
end

Faraday::Parts = Parts

class Faraday::ProxyAuthError
end

class Faraday::ProxyAuthError
end

class Faraday::ProxyOptions
  def host(*args, &block); end

  def host=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end
end

class Faraday::ProxyOptions
  extend ::Forwardable
end

class Faraday::RackBuilder
  def ==(other); end

  def [](idx); end

  def adapter(key, *args, &block); end

  def app(); end

  def build(options=T.unsafe(nil)); end

  def build_env(connection, request); end

  def build_response(connection, request); end

  def delete(handler); end

  def handlers(); end

  def handlers=(handlers); end

  def initialize(handlers=T.unsafe(nil), &block); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def lock!(); end

  def locked?(); end

  def request(key, *args, &block); end

  def response(key, *args, &block); end

  def swap(index, *args, &block); end

  def to_app(inner_app); end

  def use(klass, *args, &block); end
end

class Faraday::RackBuilder::Handler
  def ==(other); end

  def build(app); end

  def initialize(klass, *args, &block); end

  def klass(); end

  def name(); end
end

class Faraday::RackBuilder::Handler
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder
end

class Faraday::Request
  def [](key); end

  def []=(key, value); end

  def headers=(hash); end

  def marshal_dump(); end

  def marshal_load(serialised); end

  def params=(hash); end

  def to_env(connection); end

  def url(path, params=T.unsafe(nil)); end
end

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Multipart
end

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  def call(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  def self.mime_type(); end

  def self.mime_type=(mime_type); end
end

class Faraday::Request
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
  def self.create(request_method); end
end

class Faraday::RequestOptions
  def []=(key, value); end
end

class Faraday::RequestOptions
end

class Faraday::ResourceNotFound
end

class Faraday::ResourceNotFound
end

class Faraday::Response
  def [](*args, &block); end

  def apply_request(request_env); end

  def body(); end

  def env(); end

  def finish(env); end

  def finished?(); end

  def headers(); end

  def initialize(env=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(env); end

  def on_complete(&block); end

  def reason_phrase(); end

  def status(); end

  def success?(); end

  def to_hash(*args, &block); end
end

class Faraday::Response::Logger
  def debug(*args, &block); end

  def error(*args, &block); end

  def fatal(*args, &block); end

  def filter(filter_word, filter_replacement); end

  def info(*args, &block); end

  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end

  def warn(*args, &block); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  extend ::Forwardable
end

class Faraday::Response::Middleware
  def call(env); end

  def on_complete(env); end
end

class Faraday::Response::Middleware
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
end

class Faraday::RetriableResponse
end

class Faraday::RetriableResponse
end

class Faraday::SSLError
end

class Faraday::SSLError
end

class Faraday::SSLOptions
  def disable?(); end

  def verify?(); end
end

class Faraday::SSLOptions
end

class Faraday::ServerError
end

class Faraday::ServerError
end

class Faraday::TimeoutError
  def initialize(exc=T.unsafe(nil), response=T.unsafe(nil)); end
end

class Faraday::TimeoutError
end

Faraday::Timer = Timeout

class Faraday::UnauthorizedError
end

class Faraday::UnauthorizedError
end

class Faraday::UnprocessableEntityError
end

class Faraday::UnprocessableEntityError
end

Faraday::UploadIO = UploadIO

module Faraday::Utils
  def URI(url); end

  def build_nested_query(params); end

  def build_query(params); end

  def deep_merge(source, hash); end

  def deep_merge!(target, hash); end

  def default_params_encoder(); end

  def default_uri_parser(); end

  def default_uri_parser=(parser); end

  def escape(s); end

  def normalize_params(params, name, v=T.unsafe(nil)); end

  def normalize_path(url); end

  def parse_nested_query(query); end

  def parse_query(query); end

  def sort_query_params(query); end

  def unescape(s); end
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def fetch(k, *args, &block); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def initialize_names(); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def parse(header_string); end

  def replace(other); end

  def update(other); end
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def self.from(value); end
end

class Faraday::Utils::ParamsHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end

  def merge(params); end

  def merge!(params); end

  def merge_query(query, encoder=T.unsafe(nil)); end

  def replace(other); end

  def to_query(encoder=T.unsafe(nil)); end

  def update(params); end
end

class Faraday::Utils::ParamsHash
end

module Faraday::Utils
  extend ::Faraday::Utils
  def self.default_params_encoder=(default_params_encoder); end
end

module Faraday
  def self.const_missing(name); end

  def self.default_adapter(); end

  def self.default_adapter=(adapter); end

  def self.default_connection(); end

  def self.default_connection=(default_connection); end

  def self.default_connection_options(); end

  def self.default_connection_options=(options); end

  def self.ignore_env_proxy(); end

  def self.ignore_env_proxy=(ignore_env_proxy); end

  def self.lib_path(); end

  def self.lib_path=(lib_path); end

  def self.new(url=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.require_lib(*libs); end

  def self.require_libs(*libs); end

  def self.respond_to?(symbol, include_private=T.unsafe(nil)); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.probe_stat_in(dir); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

class Gem::Installer
  def verify_spec_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Specification
  extend ::Enumerable
end

module GeneratedUrlHelpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options=(obj); end

  def rails_info_path(*args); end

  def rails_info_properties_path(*args); end

  def rails_info_properties_url(*args); end

  def rails_info_routes_path(*args); end

  def rails_info_routes_url(*args); end

  def rails_info_url(*args); end

  def rails_mailers_path(*args); end

  def rails_mailers_url(*args); end
end

module GeneratedUrlHelpers
  def self._routes(); end

  def self.default_url_options=(obj); end
end

module GetText
end

class GetText::PoParser
  def _(x); end

  def _reduce_10(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def on_comment(comment); end

  def on_message(msgid, msgstr); end

  def parse(str, data, ignore_fuzzy=T.unsafe(nil)); end

  def unescape(orig); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class GetText::PoParser
end

module GetText
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def eql?(other); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Identification
  extend ::ActiveSupport::Concern
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID::Railtie
end

class GlobalID::Railtie
end

class GlobalID::Verifier
end

class GlobalID::Verifier
end

class GlobalID
  extend ::ActiveSupport::Autoload
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

class HTMLSelector
  def context(); end

  def css_selector(); end

  def initialize(values, previous_selection=T.unsafe(nil), &root_fallback); end

  def message(); end

  def select(); end

  def selecting_no_body?(); end

  def tests(); end
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  def self.context(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::Mocha::HashMethods
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def assert_exclusive_keys(*exclusive_keys); end

  def assert_valid_keys(*valid_keys); end

  def compact(); end

  def compact!(); end

  def deep_merge(other_hash, &block); end

  def deep_merge!(other_hash, &block); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def nested_under_indifferent_access(); end

  def replace(_); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice(*_); end

  def slice!(*keys); end

  def to_h(); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end

  def to_proc(); end

  def to_query(namespace=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values!(); end

  def update(_); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end

  def with_indifferent_access(); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.try_convert(_); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module Hashdiff
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hashdiff::CompareHashes
end

class Hashdiff::CompareHashes
  def self.call(obj1, obj2, opts=T.unsafe(nil)); end
end

class Hashdiff::LcsCompareArrays
end

class Hashdiff::LcsCompareArrays
  def self.call(obj1, obj2, opts=T.unsafe(nil)); end
end

class Hashdiff::LinearCompareArray
  def call(); end

  def initialize(old_array, new_array, options); end
end

class Hashdiff::LinearCompareArray
  def self.call(old_array, new_array, options=T.unsafe(nil)); end
end

module Hashdiff
  def self.best_diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.comparable?(obj1, obj2, strict=T.unsafe(nil)); end

  def self.compare_values(obj1, obj2, options=T.unsafe(nil)); end

  def self.count_diff(diffs); end

  def self.count_nodes(obj); end

  def self.custom_compare(method, key, obj1, obj2); end

  def self.decode_property_path(path, delimiter=T.unsafe(nil)); end

  def self.diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.diff_array_lcs(arraya, arrayb, options=T.unsafe(nil)); end

  def self.lcs(arraya, arrayb, options=T.unsafe(nil)); end

  def self.node(hash, parts); end

  def self.patch!(obj, changes, options=T.unsafe(nil)); end

  def self.prefix_append_array_index(prefix, array_index, opts); end

  def self.prefix_append_key(prefix, key, opts); end

  def self.similar?(obja, objb, options=T.unsafe(nil)); end

  def self.unpatch!(obj, changes, options=T.unsafe(nil)); end
end

module Hashie
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hashie::Array
  include ::Hashie::Extensions::Array::PrettyInspect
  include ::Hashie::Extensions::RubyVersionCheck
  def array_inspect(); end

  def dig(*indexes); end
end

class Hashie::Array
end

module Hashie::Extensions
end

module Hashie::Extensions::Array
end

module Hashie::Extensions::Array::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::Array::PrettyInspect
  def self.included(base); end
end

module Hashie::Extensions::Array
end

module Hashie::Extensions::KeyConflictWarning
  def disable_warnings(*method_keys); end

  def disable_warnings?(method_key=T.unsafe(nil)); end

  def disabled_warnings(); end

  def inherited(subclass); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings
  def initialize(); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings
end

module Hashie::Extensions::KeyConflictWarning
end

module Hashie::Extensions::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::PrettyInspect
  def self.included(base); end
end

class Hashie::Extensions::RubyVersion
  include ::Comparable
  def initialize(version); end

  def segments(); end

  def segments=(segments); end
end

class Hashie::Extensions::RubyVersion
end

module Hashie::Extensions::RubyVersionCheck
end

module Hashie::Extensions::RubyVersionCheck
  def self.included(base); end
end

module Hashie::Extensions::StringifyKeys
  def stringify_keys(); end

  def stringify_keys!(); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  def stringify_keys(hash); end

  def stringify_keys!(hash); end

  def stringify_keys_recursively!(object); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
end

module Hashie::Extensions::StringifyKeys
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods
end

module Hashie::Extensions
end

class Hashie::Hash
  include ::Hashie::Extensions::PrettyInspect
  include ::Hashie::Extensions::StringifyKeys
  def hash_inspect(); end

  def to_hash(options=T.unsafe(nil)); end

  def to_json(*args); end

  def to_mash(); end
end

class Hashie::Hash
end

class Hashie::Mash
  include ::Hashie::Extensions::RubyVersionCheck
  def [](key); end

  def []=(key, value, convert=T.unsafe(nil)); end

  def assign_property(name, value); end

  def convert_key(key); end

  def convert_value(val, duping=T.unsafe(nil)); end

  def custom_reader(key); end

  def custom_writer(key, value, convert=T.unsafe(nil)); end

  def deep_merge(other_hash, &blk); end

  def deep_merge!(other_hash, &blk); end

  def deep_update(other_hash, &blk); end

  def delete(key); end

  def dig(*keys); end

  def fetch(key, *args); end

  def has_key?(key); end

  def include?(key); end

  def initialize(source_hash=T.unsafe(nil), default=T.unsafe(nil), &blk); end

  def initializing_reader(key); end

  def key?(key); end

  def member?(key); end

  def merge(other_hash, &blk); end

  def merge!(other_hash, &blk); end

  def method_missing(method_name, *args, &blk); end

  def method_name_and_suffix(method_name); end

  def method_suffix(method_name); end

  def prefix_method?(method_name); end

  def regular_dup(); end

  def regular_key?(_); end

  def regular_reader(_); end

  def regular_writer(_, _1); end

  def reject(&blk); end

  def replace(other_hash); end

  def select(&blk); end

  def shallow_merge(other_hash); end

  def shallow_update(other_hash); end

  def slice(*keys); end

  def to_module(mash_method_name=T.unsafe(nil)); end

  def transform_keys(&blk); end

  def transform_values(&blk); end

  def underbang_reader(key); end

  def update(other_hash, &blk); end

  def values_at(*keys); end

  def with_accessors!(); end
  ALLOWED_SUFFIXES = ::T.let(nil, ::T.untyped)
end

class Hashie::Mash
  extend ::Hashie::Extensions::KeyConflictWarning
  def self.load(path, options=T.unsafe(nil)); end

  def self.quiet(*method_keys); end
end

module Hashie::Utils
end

module Hashie::Utils
  def self.integer_classes(); end

  def self.method_information(bound_method); end

  def self.safe_dup(value); end
end

module Hashie
  def self.logger(); end

  def self.logger=(logger); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil)); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, options=T.unsafe(nil)); end

  def translate(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, options=T.unsafe(nil)); end

  def transliterate(key, *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::HashRefinements
end

module I18n::HashRefinements
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

I18n::JSON = ActiveSupport::JSON

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::Railtie
end

class I18n::Railtie
  def self.include_fallbacks_module(); end

  def self.init_fallbacks(fallbacks); end

  def self.initialize_i18n(app); end

  def self.validate_fallbacks(fallbacks); end

  def self.watched_dirs_with_extensions(paths); end
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

module ITypeAssert
  def get_type(); end
end

module ITypeAssert
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module IceNine
  VERSION = ::T.let(nil, ::T.untyped)
end

class IceNine::Freezer
end

class IceNine::Freezer::Array
end

class IceNine::Freezer::Array
  def self.guarded_deep_freeze(array, recursion_guard); end
end

IceNine::Freezer::BasicObject = IceNine::Freezer::Object

class IceNine::Freezer::FalseClass
end

class IceNine::Freezer::FalseClass
end

class IceNine::Freezer::Hash
end

class IceNine::Freezer::Hash::State
end

class IceNine::Freezer::Hash::State
end

class IceNine::Freezer::Hash
  def self.guarded_deep_freeze(hash, recursion_guard); end
end

class IceNine::Freezer::Module
end

class IceNine::Freezer::Module
end

class IceNine::Freezer::NilClass
end

class IceNine::Freezer::NilClass
end

class IceNine::Freezer::NoFreeze
end

class IceNine::Freezer::NoFreeze
  def self.guarded_deep_freeze(object, _recursion_guard); end
end

class IceNine::Freezer::Numeric
end

class IceNine::Freezer::Numeric
end

class IceNine::Freezer::Object
end

class IceNine::Freezer::Object
end

class IceNine::Freezer::Range
end

class IceNine::Freezer::Range
  def self.guarded_deep_freeze(range, recursion_guard); end
end

class IceNine::Freezer::Rubinius
end

class IceNine::Freezer::Rubinius
end

class IceNine::Freezer::Struct
end

class IceNine::Freezer::Struct
end

class IceNine::Freezer::Symbol
end

class IceNine::Freezer::Symbol
end

class IceNine::Freezer::TrueClass
end

class IceNine::Freezer::TrueClass
end

class IceNine::Freezer
  def self.[](mod); end

  def self.const_lookup(namespace); end

  def self.deep_freeze(object); end

  def self.deep_freeze!(object); end

  def self.guarded_deep_freeze(object, recursion_guard); end
end

class IceNine::RecursionGuard
end

class IceNine::RecursionGuard::Frozen
  def guard(object); end
end

class IceNine::RecursionGuard::Frozen
end

class IceNine::RecursionGuard::ObjectSet
  def guard(object); end
end

class IceNine::RecursionGuard::ObjectSet
end

class IceNine::RecursionGuard
end

module IceNine
  def self.deep_freeze(object); end

  def self.deep_freeze!(object); end
end

class ImproveIndexesOnTasks
end

class ImproveTasksIndexing
end

class ImproveUsersIndexing
end

class IncreaseTasksTypeSizeBack
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def multiple_of?(number); end

  def nobits?(_); end

  def ordinal(); end

  def ordinalize(); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
end

class Integer
  def self.sqrt(_); end
end

class IntegerString
end

class IntegerString
  def self.===(other); end
end

module IntegerStringImpl
  def _is_a_integer_string?(); end

  def instance_of?(type); end

  def is_a?(type); end

  def kind_of?(type); end
end

module IntegerStringImpl
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module JWT
  include ::JWT::DefaultOptions
end

module JWT::Algos
end

module JWT::Algos::Ecdsa
  NAMED_CURVES = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ecdsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Eddsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Eddsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Hmac
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Hmac
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Ps
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ps
  def self.require_openssl!(); end

  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Rsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Rsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Unsupported
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Unsupported
  def self.sign(*_); end

  def self.verify(*_); end
end

module JWT::Algos
end

class JWT::Base64
end

class JWT::Base64
  def self.url_decode(str); end

  def self.url_encode(str); end
end

class JWT::ClaimsValidator
  def initialize(payload); end

  def validate!(); end
  INTEGER_CLAIMS = ::T.let(nil, ::T.untyped)
end

class JWT::ClaimsValidator
end

class JWT::Decode
  def decode_segments(); end

  def initialize(jwt, key, verify, options, &keyfinder); end
end

class JWT::Decode
end

class JWT::DecodeError
end

class JWT::DecodeError
end

module JWT::DefaultOptions
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module JWT::DefaultOptions
end

class JWT::Encode
  def initialize(options); end

  def segments(); end
  ALG_KEY = ::T.let(nil, ::T.untyped)
  ALG_NONE = ::T.let(nil, ::T.untyped)
end

class JWT::Encode
end

class JWT::EncodeError
end

class JWT::EncodeError
end

class JWT::ExpiredSignature
end

class JWT::ExpiredSignature
end

class JWT::ImmatureSignature
end

class JWT::ImmatureSignature
end

class JWT::IncorrectAlgorithm
end

class JWT::IncorrectAlgorithm
end

class JWT::InvalidAudError
end

class JWT::InvalidAudError
end

class JWT::InvalidIatError
end

class JWT::InvalidIatError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidJtiError
end

class JWT::InvalidJtiError
end

class JWT::InvalidPayload
end

class JWT::InvalidPayload
end

class JWT::InvalidSubError
end

class JWT::InvalidSubError
end

class JWT::JSON
end

class JWT::JSON
  def self.generate(data); end

  def self.parse(data); end
end

module JWT::JWK
  MAPPINGS = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::KeyFinder
  def initialize(options); end

  def key_for(kid); end
end

class JWT::JWK::KeyFinder
end

class JWT::JWK::RSA
  def export(); end

  def initialize(keypair); end

  def keypair(); end

  def kid(); end

  def private?(*args, &block); end

  def public_key(*args, &block); end
  BINARY = ::T.let(nil, ::T.untyped)
  KTY = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::RSA
  extend ::Forwardable
  def self.import(jwk_data); end
end

module JWT::JWK
  def self.create_from(keypair); end

  def self.import(jwk_data); end

  def self.new(keypair); end
end

class JWT::JWKError
end

class JWT::JWKError
end

class JWT::RequiredDependencyError
end

class JWT::RequiredDependencyError
end

module JWT::SecurityUtils
end

module JWT::SecurityUtils
  def self.asn1_to_raw(signature, public_key); end

  def self.raw_to_asn1(signature, private_key); end

  def self.rbnacl_fixup(algorithm, key); end

  def self.secure_compare(left, right); end

  def self.verify_ps(algorithm, public_key, signing_input, signature); end

  def self.verify_rsa(algorithm, public_key, signing_input, signature); end
end

module JWT::Signature
  def sign(algorithm, msg, key); end

  def verify(algorithm, key, signing_input, signature); end
  ALGOS = ::T.let(nil, ::T.untyped)
end

class JWT::Signature::ToSign
  def algorithm(); end

  def algorithm=(_); end

  def key(); end

  def key=(_); end

  def msg(); end

  def msg=(_); end
end

class JWT::Signature::ToSign
  def self.[](*_); end

  def self.members(); end
end

class JWT::Signature::ToVerify
  def algorithm(); end

  def algorithm=(_); end

  def public_key(); end

  def public_key=(_); end

  def signature(); end

  def signature=(_); end

  def signing_input(); end

  def signing_input=(_); end
end

class JWT::Signature::ToVerify
  def self.[](*_); end

  def self.members(); end
end

module JWT::Signature
  extend ::JWT::Signature
end

class JWT::VerificationError
end

class JWT::VerificationError
end

class JWT::Verify
  def initialize(payload, options); end

  def verify_aud(); end

  def verify_expiration(); end

  def verify_iat(); end

  def verify_iss(); end

  def verify_jti(); end

  def verify_not_before(); end

  def verify_sub(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class JWT::Verify
  def self.verify_aud(payload, options); end

  def self.verify_claims(payload, options); end

  def self.verify_expiration(payload, options); end

  def self.verify_iat(payload, options); end

  def self.verify_iss(payload, options); end

  def self.verify_jti(payload, options); end

  def self.verify_not_before(payload, options); end

  def self.verify_sub(payload, options); end
end

module JWT
  def self.decode(jwt, key=T.unsafe(nil), verify=T.unsafe(nil), options=T.unsafe(nil), &keyfinder); end

  def self.encode(payload, key, algorithm=T.unsafe(nil), header_fields=T.unsafe(nil)); end
end

module Jquery
end

module Jquery::Rails
  JQUERY_2_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_UJS_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Jquery::Rails::Engine
end

class Jquery::Rails::Engine
end

module Jquery::Rails
end

module Jquery
end

module Kernel
  def byebug(); end

  def class_eval(*args, &block); end

  def debugger(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

module LoDash
end

module LoDash::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class LoDash::Rails::Engine
end

class LoDash::Rails::Engine
end

module LoDash::Rails
end

module LoDash
end

class LoadError
  def is_missing?(location); end

  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module LoggerSilence
end

module LoggerSilence
  extend ::ActiveSupport::Concern
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::DocumentDecorator
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
end

module Loofah::HTML
end

class Loofah::HTML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::Document
end

class Loofah::HTML::DocumentFragment
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::DocumentFragment
end

module Loofah::HTML
end

module Loofah::HTML5
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  def self.allowed_element?(element_name); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::HTML5
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
end

module Loofah::MetaHelpers
end

module Loofah::MetaHelpers
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::Node
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
end

module Loofah::Scrubbers
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

module Loofah::TextBehavior
end

module Loofah::XML
end

class Loofah::XML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
end

class Loofah::XML::Document
end

class Loofah::XML::DocumentFragment
end

class Loofah::XML::DocumentFragment
end

module Loofah::XML
end

module Loofah
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other_address); end

  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(&blk); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(_); end

  def regular_writer(_, _1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addresses(); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addresses(); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_address(); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def recipients(); end

  def recipients_addresses(); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addresses(); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end

  def x_original_to_addresses(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::ParserTools
  def chars(data, from_bytes, to_bytes); end
end

module Mail::ParserTools
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  def self.version(); end
end

module Mail
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.from_source(source); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

class MakesStackIdNotNullOnStatuses
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.dump_with_mocks(*args); end

  def self.dump_without_mocks(*_); end

  def self.restore(*_); end
end

module Metaclass
  VERSION = ::T.let(nil, ::T.untyped)
end

module Metaclass::ObjectMethods
  def __metaclass__(); end
end

module Metaclass::ObjectMethods
end

module Metaclass
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&blk); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type::InvalidMimeType
end

class Mime::Type::InvalidMimeType
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*_); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args); end

  def must_be_close_to(*args); end

  def must_be_empty(*args); end

  def must_be_instance_of(*args); end

  def must_be_kind_of(*args); end

  def must_be_nil(*args); end

  def must_be_same_as(*args); end

  def must_be_silent(*args); end

  def must_be_within_delta(*args); end

  def must_be_within_epsilon(*args); end

  def must_equal(*args); end

  def must_include(*args); end

  def must_match(*args); end

  def must_output(*args); end

  def must_raise(*args); end

  def must_respond_to(*args); end

  def must_throw(*args); end

  def path_must_exist(*args); end

  def path_wont_exist(*args); end

  def wont_be(*args); end

  def wont_be_close_to(*args); end

  def wont_be_empty(*args); end

  def wont_be_instance_of(*args); end

  def wont_be_kind_of(*args); end

  def wont_be_nil(*args); end

  def wont_be_same_as(*args); end

  def wont_be_within_delta(*args); end

  def wont_be_within_epsilon(*args); end

  def wont_equal(*args); end

  def wont_include(*args); end

  def wont_match(*args); end

  def wont_respond_to(*args); end
end

module Minitest::Expectations
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  include ::Mocha::Integration::MiniTest::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  include ::WebMock::API
  include ::Spy::MiniTestAdapter
  include ::Spy::API
  def assert_request_not_requested(*args); end

  def assert_request_not_requested_with_assertions_count(*args); end

  def assert_request_requested(*args); end

  def assert_request_requested_with_assertions_count(*args); end

  def capture_exceptions(); end

  def teardown_with_webmock(); end

  def teardown_without_webmock(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

module Mocha
  PRE_RUBY_V19 = ::T.let(nil, ::T.untyped)
  RUBY_V2_PLUS = ::T.let(nil, ::T.untyped)
end

module Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  def mock(*arguments, &block); end

  def sequence(name); end

  def states(name); end

  def stub(*arguments, &block); end

  def stub_everything(*arguments, &block); end
end

module Mocha::API
  def self.included(_mod); end
end

class Mocha::AnyInstanceMethod
end

class Mocha::AnyInstanceMethod
end

class Mocha::AnyInstanceReceiver
  def initialize(klass); end

  def mocks(); end
end

class Mocha::AnyInstanceReceiver
end

class Mocha::ArgumentIterator
  def each(&blk); end

  def initialize(argument); end
end

class Mocha::ArgumentIterator
end

module Mocha::ArrayMethods
  def mocha_inspect(); end
end

module Mocha::ArrayMethods
end

class Mocha::BacktraceFilter
  def filtered(backtrace); end

  def initialize(lib_directory=T.unsafe(nil)); end
  LIB_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Mocha::BacktraceFilter
end

class Mocha::Cardinality
  def allowed_any_number_of_times?(); end

  def infinite?(number); end

  def initialize(required, maximum); end

  def invocations_allowed?(invocation_count); end

  def maximum(); end

  def needs_verifying?(); end

  def required(); end

  def satisfied?(invocations_so_far); end

  def times(number); end

  def used?(invocation_count); end

  def verified?(invocation_count); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class Mocha::Cardinality
  def self.at_least(count); end

  def self.at_most(count); end

  def self.exactly(count); end

  def self.times(range_or_count); end
end

class Mocha::Central
  def stub(method); end

  def stubba_methods(); end

  def stubba_methods=(stubba_methods); end

  def unstub(method); end

  def unstub_all(); end
end

class Mocha::Central::Null
  def initialize(&block); end

  def stub(*_); end

  def unstub(*_); end
end

class Mocha::Central::Null
end

class Mocha::Central
end

class Mocha::ChangeStateSideEffect
  def initialize(state); end

  def perform(); end
end

class Mocha::ChangeStateSideEffect
end

class Mocha::ClassMethod
  def define_new_method(); end

  def hide_original_method(); end

  def initialize(stubbee, method_name); end

  def matches?(other); end

  def method_defined_in_stubbee_or_in_ancestor_chain?(); end

  def method_name(); end

  def method_visibility(); end

  def mock(); end

  def remove_new_method(); end

  def restore_original_method(); end

  def stub(); end

  def stubbee(); end

  def unstub(); end
end

class Mocha::ClassMethod::PrependedModule
end

class Mocha::ClassMethod::PrependedModule
end

class Mocha::ClassMethod
end

module Mocha::ClassMethods
  def any_instance(); end

  def stubba_method(); end
end

module Mocha::ClassMethods
end

class Mocha::Configuration
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mocha::Configuration
  def self.allow(action, &block); end

  def self.allow?(action); end

  def self.prevent(action, &block); end

  def self.prevent?(action); end

  def self.reset_configuration(); end

  def self.warn_when(action, &block); end

  def self.warn_when?(action); end
end

module Mocha::DateMethods
  def mocha_inspect(); end
end

module Mocha::DateMethods
end

module Mocha::Debug
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Mocha::Debug
  def self.puts(message); end
end

class Mocha::DefaultName
  def initialize(mock); end
end

class Mocha::DefaultName
end

class Mocha::DefaultReceiver
  def initialize(mock); end

  def mocks(); end
end

class Mocha::DefaultReceiver
end

class Mocha::Deprecation
end

class Mocha::Deprecation
  def self.messages(); end

  def self.messages=(messages); end

  def self.mode(); end

  def self.mode=(mode); end

  def self.warning(message); end
end

module Mocha::Detection
end

module Mocha::Detection::MiniTest
end

module Mocha::Detection::MiniTest
  def self.testcase(); end

  def self.version(); end
end

module Mocha::Detection::TestUnit
end

module Mocha::Detection::TestUnit
  def self.testcase(); end

  def self.version(); end
end

module Mocha::Detection
end

class Mocha::ErrorWithFilteredBacktrace
  def initialize(message=T.unsafe(nil), backtrace=T.unsafe(nil)); end
end

class Mocha::ErrorWithFilteredBacktrace
end

class Mocha::ExceptionRaiser
  def evaluate(); end

  def initialize(exception, message); end
end

class Mocha::ExceptionRaiser
end

class Mocha::Expectation
  def add_in_sequence_ordering_constraint(sequence); end

  def add_ordering_constraint(ordering_constraint); end

  def add_side_effect(side_effect); end

  def at_least(minimum_number_of_times); end

  def at_least_once(); end

  def at_most(maximum_number_of_times); end

  def at_most_once(); end

  def backtrace(); end

  def in_correct_order?(); end

  def in_sequence(*sequences); end

  def initialize(mock, expected_method_name, backtrace=T.unsafe(nil)); end

  def invocations_allowed?(); end

  def invoke(); end

  def match?(actual_method_name, *actual_parameters); end

  def matches_method?(method_name); end

  def method_signature(); end

  def multiple_yields(*parameter_groups); end

  def never(); end

  def once(); end

  def perform_side_effects(); end

  def raises(exception=T.unsafe(nil), message=T.unsafe(nil)); end

  def returns(*values); end

  def satisfied?(); end

  def then(*parameters); end

  def throws(tag, object=T.unsafe(nil)); end

  def times(range); end

  def twice(); end

  def used?(); end

  def verified?(assertion_counter=T.unsafe(nil)); end

  def when(state_predicate); end

  def with(*expected_parameters, &matching_block); end

  def yields(*parameters); end
end

class Mocha::Expectation
end

class Mocha::ExpectationError
end

class Mocha::ExpectationError
end

class Mocha::ExpectationErrorFactory
end

class Mocha::ExpectationErrorFactory
  def self.build(message=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def self.exception_class(); end

  def self.exception_class=(exception_class); end
end

class Mocha::ExpectationList
  def +(other); end

  def add(expectation); end

  def any?(); end

  def initialize(expectations=T.unsafe(nil)); end

  def length(); end

  def match(method_name, *arguments); end

  def match_allowing_invocation(method_name, *arguments); end

  def matches_method?(method_name); end

  def remove_all_matching_method(method_name); end

  def to_a(); end

  def to_set(); end

  def verified?(assertion_counter=T.unsafe(nil)); end
end

class Mocha::ExpectationList
end

module Mocha::HashMethods
  def mocha_inspect(); end
end

module Mocha::HashMethods
end

module Mocha::Hooks
  def mocha_setup(); end

  def mocha_teardown(); end

  def mocha_verify(assertion_counter=T.unsafe(nil)); end
end

module Mocha::Hooks
end

class Mocha::ImpersonatingAnyInstanceName
  def initialize(klass); end
end

class Mocha::ImpersonatingAnyInstanceName
end

class Mocha::ImpersonatingName
  def initialize(object); end
end

class Mocha::ImpersonatingName
end

class Mocha::InStateOrderingConstraint
  def allows_invocation_now?(); end

  def initialize(state_predicate); end
end

class Mocha::InStateOrderingConstraint
end

class Mocha::InstanceMethod
end

class Mocha::InstanceMethod
end

module Mocha::Integration
end

class Mocha::Integration::AssertionCounter
  def increment(); end

  def initialize(test_case); end
end

class Mocha::Integration::AssertionCounter
end

module Mocha::Integration::MiniTest
end

module Mocha::Integration::MiniTest::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end
end

module Mocha::Integration::MiniTest::Adapter
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::MiniTest::Nothing
end

module Mocha::Integration::MiniTest::Nothing
  def self.applicable_to?(_test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::MiniTest::Version13
end

module Mocha::Integration::MiniTest::Version13::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version13::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version13
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version140
end

module Mocha::Integration::MiniTest::Version140::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version140::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version140
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version141
end

module Mocha::Integration::MiniTest::Version141::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version141::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version141
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version142To172
end

module Mocha::Integration::MiniTest::Version142To172::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version142To172::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version142To172
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version200
end

module Mocha::Integration::MiniTest::Version200::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version200::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version200
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version201To222
end

module Mocha::Integration::MiniTest::Version201To222::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version201To222::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version201To222
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version2110To2111
end

module Mocha::Integration::MiniTest::Version2110To2111::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version2110To2111::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version2110To2111
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version2112To320
end

module Mocha::Integration::MiniTest::Version2112To320::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version2112To320::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version2112To320
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version230To2101
end

module Mocha::Integration::MiniTest::Version230To2101::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version230To2101::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version230To2101
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest
  def self.activate(); end

  def self.translate(exception); end
end

module Mocha::Integration::MonkeyPatcher
end

module Mocha::Integration::MonkeyPatcher
  def self.apply(mod, run_method_patch); end
end

module Mocha::Integration::TestUnit
end

module Mocha::Integration::TestUnit::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
end

module Mocha::Integration::TestUnit::Adapter
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion200
end

module Mocha::Integration::TestUnit::GemVersion200::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion200::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion200
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion201To202
end

module Mocha::Integration::TestUnit::GemVersion201To202::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion201To202::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion201To202
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion203To220
end

module Mocha::Integration::TestUnit::GemVersion203To220::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion203To220::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion203To220
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion230To250
end

module Mocha::Integration::TestUnit::GemVersion230To250::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion230To250::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion230To250
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::Nothing
end

module Mocha::Integration::TestUnit::Nothing
  def self.applicable_to?(_test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow::RunMethodPatch
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow
  def self.applicable_to?(test_unit_version, ruby_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove::RunMethodPatch
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove
  def self.applicable_to?(test_unit_version, ruby_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit
  def self.activate(); end
end

module Mocha::Integration
  def self.activate(); end
end

class Mocha::Logger
  def initialize(io); end

  def warn(message); end
end

class Mocha::Logger
end

class Mocha::MethodMatcher
  def expected_method_name(); end

  def initialize(expected_method_name); end

  def match?(actual_method_name); end
end

class Mocha::MethodMatcher
end

class Mocha::Mock
  def __expectations__(); end

  def __expects__(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def __stubs__(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def __verified__?(assertion_counter=T.unsafe(nil)); end

  def all_expectations(); end

  def any_expectations?(); end

  def ensure_method_not_already_defined(method_name); end

  def everything_stubbed(); end

  def expects(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def initialize(mockery, name=T.unsafe(nil), receiver=T.unsafe(nil), &block); end

  def method_missing(symbol, *arguments, &block); end

  def quacks_like(responder); end

  def quacks_like_instance_of(responder_class); end

  def responds_like(responder); end

  def responds_like_instance_of(responder_class); end

  def stub_everything(); end

  def stubs(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def unstub(method_name); end
end

class Mocha::Mock
end

class Mocha::Mockery
  def logger(); end

  def logger=(logger); end

  def mock_impersonating(object, &block); end

  def mock_impersonating_any_instance_of(klass, &block); end

  def mocks(); end

  def named_mock(name, &block); end

  def new_state_machine(name); end

  def on_stubbing(object, method); end

  def on_stubbing_method_on_nil(object, method); end

  def on_stubbing_method_on_non_mock_object(object, method); end

  def on_stubbing_method_unnecessarily(expectation); end

  def on_stubbing_non_existent_method(object, method); end

  def on_stubbing_non_public_method(object, method); end

  def state_machines(); end

  def stubba(); end

  def teardown(); end

  def unnamed_mock(&block); end

  def verify(assertion_counter=T.unsafe(nil)); end
end

class Mocha::Mockery::Null
  def add_mock(*_); end

  def add_state_machine(*_); end
end

class Mocha::Mockery::Null
end

class Mocha::Mockery
  def self.instance(); end

  def self.setup(); end

  def self.teardown(); end

  def self.verify(*args); end
end

class Mocha::ModuleMethod
end

class Mocha::ModuleMethod
end

module Mocha::ModuleMethods
  def stubba_method(); end
end

module Mocha::ModuleMethods
end

class Mocha::MultipleYields
  def each(&blk); end

  def initialize(*parameter_groups); end

  def parameter_groups(); end
end

class Mocha::MultipleYields
end

class Mocha::Name
  def initialize(name); end
end

class Mocha::Name
end

class Mocha::NoYields
  def each(&blk); end
end

class Mocha::NoYields
end

class Mocha::NotInitializedError
end

class Mocha::NotInitializedError
end

module Mocha::ObjectMethods
  def _method(_); end

  def expects(expected_methods_vs_return_values); end

  def method_exists?(method, include_public_methods=T.unsafe(nil)); end

  def mocha(instantiate=T.unsafe(nil)); end

  def mocha_inspect(); end

  def reset_mocha(); end

  def stubba_method(); end

  def stubba_object(); end

  def stubs(stubbed_methods_vs_return_values); end

  def to_matcher(); end

  def unstub(*method_names); end
end

module Mocha::ObjectMethods
end

class Mocha::ObjectReceiver
  def initialize(object); end

  def mocks(); end
end

class Mocha::ObjectReceiver
end

module Mocha::ParameterMatchers
  def Not(matcher); end

  def all_of(*matchers); end

  def any_of(*matchers); end

  def any_parameters(); end

  def anything(); end

  def equals(value); end

  def equivalent_uri(uri); end

  def has_entries(entries); end

  def has_entry(*options); end

  def has_equivalent_query_string(uri); end

  def has_key(key); end

  def has_value(value); end

  def includes(*items); end

  def instance_of(klass); end

  def is_a(klass); end

  def kind_of(klass); end

  def optionally(*matchers); end

  def regexp_matches(regexp); end

  def responds_with(message, result); end

  def yaml_equivalent(object); end
end

module Mocha::ParameterMatchers
end

class Mocha::ParametersMatcher
  def initialize(expected_parameters=T.unsafe(nil), &matching_block); end

  def match?(actual_parameters=T.unsafe(nil)); end

  def matchers(); end

  def parameters_match?(actual_parameters); end
end

class Mocha::ParametersMatcher
end

class Mocha::ReturnValues
  def +(other); end

  def initialize(*values); end

  def next(); end

  def values(); end

  def values=(values); end
end

class Mocha::ReturnValues
  def self.build(*values); end
end

class Mocha::Sequence
  def constrain_as_next_in_sequence(expectation); end

  def initialize(name); end

  def satisfied_to_index?(index); end
end

class Mocha::Sequence::InSequenceOrderingConstraint
  def allows_invocation_now?(); end

  def initialize(sequence, index); end
end

class Mocha::Sequence::InSequenceOrderingConstraint
end

class Mocha::Sequence
end

class Mocha::SingleReturnValue
  def evaluate(); end

  def initialize(value); end
end

class Mocha::SingleReturnValue
end

class Mocha::SingleYield
  def each(&blk); end

  def initialize(*parameters); end

  def parameters(); end
end

class Mocha::SingleYield
end

class Mocha::StateMachine
  def become(next_state_name); end

  def current_state(); end

  def current_state=(current_state); end

  def initialize(name); end

  def is(state_name); end

  def is_not(state_name); end

  def name(); end

  def starts_as(initial_state_name); end
end

class Mocha::StateMachine::State
  def activate(); end

  def active?(); end

  def initialize(state_machine, state); end
end

class Mocha::StateMachine::State
end

class Mocha::StateMachine::StatePredicate
  def active?(); end

  def initialize(state_machine, state); end
end

class Mocha::StateMachine::StatePredicate
end

class Mocha::StateMachine
end

class Mocha::StubbingError
end

class Mocha::StubbingError
end

class Mocha::Thrower
  def evaluate(); end

  def initialize(tag, object=T.unsafe(nil)); end
end

class Mocha::Thrower
end

module Mocha::TimeMethods
  def mocha_inspect(); end
end

module Mocha::TimeMethods
end

class Mocha::UnexpectedInvocation
  def full_description(); end

  def initialize(mock, symbol, *arguments); end

  def short_description(); end
end

class Mocha::UnexpectedInvocation
end

class Mocha::YieldParameters
  def add(*parameters); end

  def multiple_add(*parameter_groups); end

  def next_invocation(); end
end

class Mocha::YieldParameters
end

module Mocha
  def self.activate(); end
end

class Module
  include ::Mocha::ModuleMethods
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  include ::Module::Concerning
  def alias_attribute(new_name, old_name); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target); end

  def deprecate(*method_names); end

  def deprecate_constant(*_); end

  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def method_visibility(method); end

  def module_parent(); end

  def module_parent_name(); end

  def module_parents(); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def rake_extension(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def silence_redefinition_of_method(method); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
end

module MultiJson::OptionsCache
  def fetch(type, key, &block); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

class MultiXml::DisallowedTypeError
end

class MultiXml::NoParserError
end

class MultiXml::NoParserError
end

class MultiXml::ParseError
end

class MultiXml::ParseError
end

module MultiXml
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end

  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPClientError
end

Net::HTTPClientErrorCode::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRedirection
end

Net::HTTPRedirectionCode::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
end

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPServerError
end

Net::HTTPServerErrorCode::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
end

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

Net::SMTPSession = Net::SMTP

module Net::WebMockHTTPResponse
  def read_body(dest=T.unsafe(nil), &block); end
end

module Net::WebMockHTTPResponse
end

class Net::WebMockNetBufferedIO
  def initialize(io, *args); end
end

class Net::WebMockNetBufferedIO
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
end

module Nokogiri::HTML
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

class Numeric
  def billion(); end

  def hundred(); end

  def million(); end

  def neg?(); end

  def pos?(); end

  def quadrillion(); end

  def thousand(); end

  def trillion(); end
  BILLION = ::T.let(nil, ::T.untyped)
  HUNDRED = ::T.let(nil, ::T.untyped)
  MILLION = ::T.let(nil, ::T.untyped)
  QUADRILLION = ::T.let(nil, ::T.untyped)
  THOUSAND = ::T.let(nil, ::T.untyped)
  TRILLION = ::T.let(nil, ::T.untyped)
end

module OAuth2
end

class OAuth2::AccessToken
  def [](key); end

  def client(); end

  def delete(path, opts=T.unsafe(nil), &block); end

  def expired?(); end

  def expires?(); end

  def expires_at(); end

  def expires_in(); end

  def get(path, opts=T.unsafe(nil), &block); end

  def headers(); end

  def initialize(client, token, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def params(); end

  def patch(path, opts=T.unsafe(nil), &block); end

  def post(path, opts=T.unsafe(nil), &block); end

  def put(path, opts=T.unsafe(nil), &block); end

  def refresh!(params=T.unsafe(nil)); end

  def refresh_token(); end

  def refresh_token=(refresh_token); end

  def request(verb, path, opts=T.unsafe(nil), &block); end

  def to_hash(); end

  def token(); end
end

class OAuth2::AccessToken
  def self.from_hash(client, hash); end

  def self.from_kvform(client, kvform); end
end

class OAuth2::Authenticator
  def apply(params); end

  def id(); end

  def initialize(id, secret, mode); end

  def mode(); end

  def secret(); end
end

class OAuth2::Authenticator
  def self.encode_basic_auth(user, password); end
end

class OAuth2::Client
  def assertion(); end

  def auth_code(); end

  def authorize_url(params=T.unsafe(nil)); end

  def client_credentials(); end

  def connection(); end

  def connection=(connection); end

  def get_token(params, access_token_opts=T.unsafe(nil), access_token_class=T.unsafe(nil)); end

  def id(); end

  def implicit(); end

  def initialize(client_id, client_secret, options=T.unsafe(nil), &block); end

  def options(); end

  def options=(options); end

  def password(); end

  def redirection_params(); end

  def request(verb, url, opts=T.unsafe(nil)); end

  def secret(); end

  def site(); end

  def site=(value); end

  def token_url(params=T.unsafe(nil)); end
end

class OAuth2::Client
end

class OAuth2::Error
  def code(); end

  def description(); end

  def error_message(response_body, opts=T.unsafe(nil)); end

  def initialize(response); end

  def response(); end
end

class OAuth2::Error
end

class OAuth2::MACToken
  def algorithm(); end

  def algorithm=(alg); end

  def header(verb, url); end

  def initialize(client, token, secret, opts=T.unsafe(nil)); end

  def secret(); end

  def signature(timestamp, nonce, verb, uri); end
end

class OAuth2::MACToken
  def self.from_access_token(token, secret, options=T.unsafe(nil)); end
end

class OAuth2::Response
  def body(); end

  def content_type(); end

  def error(); end

  def error=(error); end

  def headers(); end

  def initialize(response, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parsed(); end

  def parser(); end

  def response(); end

  def status(); end
end

class OAuth2::Response
  def self.register_parser(key, mime_types, &block); end
end

module OAuth2::Strategy
end

class OAuth2::Strategy::Assertion
  def authorize_url(); end

  def build_assertion(params); end

  def build_request(params); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Assertion
end

class OAuth2::Strategy::AuthCode
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(code, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::AuthCode
end

class OAuth2::Strategy::Base
  def initialize(client); end
end

class OAuth2::Strategy::Base
end

class OAuth2::Strategy::ClientCredentials
  def authorize_url(); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::ClientCredentials
end

class OAuth2::Strategy::Implicit
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(*_); end
end

class OAuth2::Strategy::Implicit
end

class OAuth2::Strategy::Password
  def authorize_url(); end

  def get_token(username, password, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Password
end

module OAuth2::Strategy
end

module OAuth2
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::Metaclass::ObjectMethods
  include ::Minitest::Expectations
  include ::Mocha::ObjectMethods
  include ::PP::ObjectMixin
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def __is_a__(_); end

  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Octokit
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Octokit::AbuseDetected
end

class Octokit::AbuseDetected
end

class Octokit::AccountSuspended
end

class Octokit::AccountSuspended
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::Arguments
  def initialize(args); end

  def options(); end
end

class Octokit::Arguments
end

module Octokit::Authentication
  def application_authenticated?(); end

  def basic_authenticated?(); end

  def bearer_authenticated?(); end

  def token_authenticated?(); end

  def user_authenticated?(); end
end

module Octokit::Authentication
end

class Octokit::BadGateway
end

class Octokit::BadGateway
end

class Octokit::BadRequest
end

class Octokit::BadRequest
end

class Octokit::BillingIssue
end

class Octokit::BillingIssue
end

class Octokit::BranchNotProtected
end

class Octokit::BranchNotProtected
end

class Octokit::Client
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Preview
  include ::Octokit::Warnable
  include ::Octokit::Client::Authorizations
  include ::Octokit::Client::Checks
  include ::Octokit::Client::Commits
  include ::Octokit::Client::CommitComments
  include ::Octokit::Client::CommitPulls
  include ::Octokit::Client::CommitBranches
  include ::Octokit::Client::CommunityProfile
  include ::Octokit::Client::Contents
  include ::Octokit::Client::Deployments
  include ::Octokit::Client::Downloads
  include ::Octokit::Client::Emojis
  include ::Octokit::Client::Events
  include ::Octokit::Client::Feeds
  include ::Octokit::Client::Gists
  include ::Octokit::Client::Gitignore
  include ::Octokit::Client::Hooks
  include ::Octokit::Client::Apps
  include ::Octokit::Client::Issues
  include ::Octokit::Client::Labels
  include ::Octokit::Client::LegacySearch
  include ::Octokit::Client::Licenses
  include ::Octokit::Client::Meta
  include ::Octokit::Client::Markdown
  include ::Octokit::Client::Marketplace
  include ::Octokit::Client::Milestones
  include ::Octokit::Client::Notifications
  include ::Octokit::Client::Objects
  include ::Octokit::Client::Organizations
  include ::Octokit::Client::Pages
  include ::Octokit::Client::Projects
  include ::Octokit::Client::PubSubHubbub
  include ::Octokit::Client::PullRequests
  include ::Octokit::Client::RateLimit
  include ::Octokit::Client::Reactions
  include ::Octokit::Client::Refs
  include ::Octokit::Client::Releases
  include ::Octokit::Client::Repositories
  include ::Octokit::Client::RepositoryInvitations
  include ::Octokit::Client::Reviews
  include ::Octokit::Client::Say
  include ::Octokit::Client::Search
  include ::Octokit::Client::ServiceStatus
  include ::Octokit::Client::SourceImport
  include ::Octokit::Client::Stats
  include ::Octokit::Client::Statuses
  include ::Octokit::Client::Traffic
  include ::Octokit::Client::Users
  include ::OctokitCheckRuns
  def access_token=(value); end

  def as_app(key=T.unsafe(nil), secret=T.unsafe(nil), &block); end

  def bearer_token=(value); end

  def client_id=(value); end

  def client_secret=(value); end

  def client_without_redirects(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def login=(value); end

  def password=(value); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::Apps
  def add_repo_to_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_app_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_integration_installation(installation, repo, options=T.unsafe(nil)); end

  def create_app_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_integration_installation_access_token(installation, options=T.unsafe(nil)); end

  def delete_installation(installation, options=T.unsafe(nil)); end

  def find_app_installations(options=T.unsafe(nil)); end

  def find_installation_repositories_for_user(installation, options=T.unsafe(nil)); end

  def find_installations(options=T.unsafe(nil)); end

  def find_integration_installations(options=T.unsafe(nil)); end

  def find_organization_installation(organization, options=T.unsafe(nil)); end

  def find_repository_installation(repo, options=T.unsafe(nil)); end

  def find_user_installation(user, options=T.unsafe(nil)); end

  def find_user_installations(options=T.unsafe(nil)); end

  def installation(id, options=T.unsafe(nil)); end

  def list_app_installation_repositories(options=T.unsafe(nil)); end

  def list_installation_repos(options=T.unsafe(nil)); end

  def list_integration_installation_repositories(options=T.unsafe(nil)); end

  def remove_repo_from_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_app_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_integration_installation(installation, repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Apps
end

module Octokit::Client::Authorizations
  def authorization(number, options=T.unsafe(nil)); end

  def authorizations(options=T.unsafe(nil)); end

  def authorize_url(app_id=T.unsafe(nil), options=T.unsafe(nil)); end

  def check_application_authorization(token, options=T.unsafe(nil)); end

  def create_authorization(options=T.unsafe(nil)); end

  def delete_application_authorization(token, options=T.unsafe(nil)); end

  def delete_authorization(number, options=T.unsafe(nil)); end

  def reset_application_authorization(token, options=T.unsafe(nil)); end

  def revoke_all_application_authorizations(options=T.unsafe(nil)); end

  def revoke_application_authorization(token, options=T.unsafe(nil)); end

  def scopes(token=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_authorization(number, options=T.unsafe(nil)); end
end

module Octokit::Client::Authorizations
end

module Octokit::Client::Checks
  def check_run(repo, id, options=T.unsafe(nil)); end

  def check_run_annotations(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def check_suite(repo, id, options=T.unsafe(nil)); end

  def check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def create_check_run(repo, name, head_sha, options=T.unsafe(nil)); end

  def create_check_suite(repo, head_sha, options=T.unsafe(nil)); end

  def list_check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def list_check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def list_check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def rerequest_check_suite(repo, id, options=T.unsafe(nil)); end

  def set_check_suite_preferences(repo, options=T.unsafe(nil)); end

  def update_check_run(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Checks
end

module Octokit::Client::CommitBranches
  def commit_branches(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitBranches
end

module Octokit::Client::CommitComments
  def commit_comment(repo, id, options=T.unsafe(nil)); end

  def commit_comments(repo, sha, options=T.unsafe(nil)); end

  def create_commit_comment(repo, sha, body, path=T.unsafe(nil), line=T.unsafe(nil), position=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_commit_comment(repo, id, options=T.unsafe(nil)); end

  def list_commit_comments(repo, options=T.unsafe(nil)); end

  def update_commit_comment(repo, id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitComments
end

module Octokit::Client::CommitPulls
  def commit_pulls(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitPulls
end

module Octokit::Client::Commits
  def commit(repo, sha, options=T.unsafe(nil)); end

  def commits(*args); end

  def commits_before(*args); end

  def commits_between(*args); end

  def commits_on(*args); end

  def commits_since(*args); end

  def compare(repo, start, endd, options=T.unsafe(nil)); end

  def create_commit(repo, message, tree, parents=T.unsafe(nil), options=T.unsafe(nil)); end

  def git_commit(repo, sha, options=T.unsafe(nil)); end

  def iso8601(date); end

  def list_commits(*args); end

  def merge(repo, base, head, options=T.unsafe(nil)); end

  def parse_date(date); end
end

module Octokit::Client::Commits
end

module Octokit::Client::CommunityProfile
  def community_profile(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::CommunityProfile
end

module Octokit::Client::Contents
  def add_content(*args); end

  def add_contents(*args); end

  def archive_link(repo, options=T.unsafe(nil)); end

  def content(repo, options=T.unsafe(nil)); end

  def contents(repo, options=T.unsafe(nil)); end

  def create_content(*args); end

  def create_contents(*args); end

  def delete_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def delete_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def readme(repo, options=T.unsafe(nil)); end

  def remove_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def remove_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def update_content(*args); end

  def update_contents(*args); end
end

module Octokit::Client::Contents
end

module Octokit::Client::Deployments
  def create_deployment(repo, ref, options=T.unsafe(nil)); end

  def create_deployment_status(deployment_url, state, options=T.unsafe(nil)); end

  def deployment(repo, deployment_id, options=T.unsafe(nil)); end

  def deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def deployments(repo, options=T.unsafe(nil)); end

  def list_deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def list_deployments(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Deployments
end

module Octokit::Client::Downloads
  def delete_download(repo, id, options=T.unsafe(nil)); end

  def download(repo, id, options=T.unsafe(nil)); end

  def downloads(repo, options=T.unsafe(nil)); end

  def list_downloads(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Downloads
end

module Octokit::Client::Emojis
  def emojis(options=T.unsafe(nil)); end
end

module Octokit::Client::Emojis
end

module Octokit::Client::Events
  def issue_event(repo, number, options=T.unsafe(nil)); end

  def issue_events(repo, number, options=T.unsafe(nil)); end

  def organization_events(org, options=T.unsafe(nil)); end

  def organization_public_events(org, options=T.unsafe(nil)); end

  def public_events(options=T.unsafe(nil)); end

  def received_events(user, options=T.unsafe(nil)); end

  def received_public_events(user, options=T.unsafe(nil)); end

  def repo_issue_events(repo, options=T.unsafe(nil)); end

  def repository_events(repo, options=T.unsafe(nil)); end

  def repository_issue_events(repo, options=T.unsafe(nil)); end

  def repository_network_events(repo, options=T.unsafe(nil)); end

  def user_events(user, options=T.unsafe(nil)); end

  def user_public_events(user, options=T.unsafe(nil)); end
end

module Octokit::Client::Events
end

module Octokit::Client::Feeds
  def feed(name, options=T.unsafe(nil)); end

  def feeds(); end
end

module Octokit::Client::Feeds
end

module Octokit::Client::Gists
  def create_gist(options=T.unsafe(nil)); end

  def create_gist_comment(gist_id, comment, options=T.unsafe(nil)); end

  def delete_gist(gist, options=T.unsafe(nil)); end

  def delete_gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def edit_gist(gist, options=T.unsafe(nil)); end

  def fork_gist(gist, options=T.unsafe(nil)); end

  def gist(gist, options=T.unsafe(nil)); end

  def gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def gist_comments(gist_id, options=T.unsafe(nil)); end

  def gist_commits(gist, options=T.unsafe(nil)); end

  def gist_forks(gist, options=T.unsafe(nil)); end

  def gist_starred?(gist, options=T.unsafe(nil)); end

  def gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def public_gists(options=T.unsafe(nil)); end

  def star_gist(gist, options=T.unsafe(nil)); end

  def starred_gists(options=T.unsafe(nil)); end

  def unstar_gist(gist, options=T.unsafe(nil)); end

  def update_gist_comment(gist_id, gist_comment_id, comment, options=T.unsafe(nil)); end
end

module Octokit::Client::Gists
end

module Octokit::Client::Gitignore
  def gitignore_template(template_name, options=T.unsafe(nil)); end

  def gitignore_templates(options=T.unsafe(nil)); end
end

module Octokit::Client::Gitignore
end

module Octokit::Client::Hooks
  def available_hooks(options=T.unsafe(nil)); end

  def create_hook(repo, name, config, options=T.unsafe(nil)); end

  def create_org_hook(org, config, options=T.unsafe(nil)); end

  def edit_hook(repo, id, name, config, options=T.unsafe(nil)); end

  def edit_org_hook(org, id, config, options=T.unsafe(nil)); end

  def hook(repo, id, options=T.unsafe(nil)); end

  def hooks(repo, options=T.unsafe(nil)); end

  def list_org_hooks(org, options=T.unsafe(nil)); end

  def org_hook(org, id, options=T.unsafe(nil)); end

  def org_hooks(org, options=T.unsafe(nil)); end

  def parse_payload(payload_string); end

  def ping_hook(repo, id, options=T.unsafe(nil)); end

  def ping_org_hook(org, id, options=T.unsafe(nil)); end

  def remove_hook(repo, id, options=T.unsafe(nil)); end

  def remove_org_hook(org, id, options=T.unsafe(nil)); end

  def test_hook(repo, id, options=T.unsafe(nil)); end

  def update_org_hook(org, id, config, options=T.unsafe(nil)); end
end

module Octokit::Client::Hooks
end

module Octokit::Client::Issues
  def add_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def add_comment(repo, number, comment, options=T.unsafe(nil)); end

  def close_issue(repo, number, options=T.unsafe(nil)); end

  def create_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_comment(repo, number, options=T.unsafe(nil)); end

  def issue(repo, number, options=T.unsafe(nil)); end

  def issue_comment(repo, number, options=T.unsafe(nil)); end

  def issue_comments(repo, number, options=T.unsafe(nil)); end

  def issue_timeline(repo, number, options=T.unsafe(nil)); end

  def issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def issues_comments(repo, options=T.unsafe(nil)); end

  def list_assignees(repo, options=T.unsafe(nil)); end

  def list_issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def lock_issue(repo, number, options=T.unsafe(nil)); end

  def open_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def org_issues(org, options=T.unsafe(nil)); end

  def remove_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def reopen_issue(repo, number, options=T.unsafe(nil)); end

  def unlock_issue(repo, number, options=T.unsafe(nil)); end

  def update_comment(repo, number, comment, options=T.unsafe(nil)); end

  def update_issue(repo, number, *args); end

  def user_issues(options=T.unsafe(nil)); end
end

module Octokit::Client::Issues
end

module Octokit::Client::Labels
  def add_label(repo, label, color=T.unsafe(nil), options=T.unsafe(nil)); end

  def add_labels_to_an_issue(repo, number, labels); end

  def delete_label!(repo, label, options=T.unsafe(nil)); end

  def label(repo, name, options=T.unsafe(nil)); end

  def labels(repo, options=T.unsafe(nil)); end

  def labels_for_issue(repo, number, options=T.unsafe(nil)); end

  def labels_for_milestone(repo, number, options=T.unsafe(nil)); end

  def remove_all_labels(repo, number, options=T.unsafe(nil)); end

  def remove_label(repo, number, label, options=T.unsafe(nil)); end

  def replace_all_labels(repo, number, labels, options=T.unsafe(nil)); end

  def update_label(repo, label, options=T.unsafe(nil)); end
end

module Octokit::Client::Labels
end

module Octokit::Client::LegacySearch
  def legacy_search_issues(repo, search_term, state=T.unsafe(nil), options=T.unsafe(nil)); end

  def legacy_search_repositories(q, options=T.unsafe(nil)); end

  def legacy_search_users(search, options=T.unsafe(nil)); end
end

module Octokit::Client::LegacySearch
end

module Octokit::Client::Licenses
  def license(license_name, options=T.unsafe(nil)); end

  def licenses(options=T.unsafe(nil)); end

  def repository_license_contents(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Licenses
end

module Octokit::Client::Markdown
  def markdown(text, options=T.unsafe(nil)); end
end

module Octokit::Client::Markdown
end

module Octokit::Client::Marketplace
  def list_accounts_for_plan(plan_id, options=T.unsafe(nil)); end

  def list_plans(options=T.unsafe(nil)); end

  def marketplace_purchases(options=T.unsafe(nil)); end

  def plan_for_account(account_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Marketplace
end

module Octokit::Client::Meta
  def github_meta(options=T.unsafe(nil)); end

  def meta(options=T.unsafe(nil)); end
end

module Octokit::Client::Meta
end

module Octokit::Client::Milestones
  def create_milestone(repository, title, options=T.unsafe(nil)); end

  def delete_milestone(repository, number, options=T.unsafe(nil)); end

  def edit_milestone(repository, number, options=T.unsafe(nil)); end

  def list_milestones(repository, options=T.unsafe(nil)); end

  def milestone(repository, number, options=T.unsafe(nil)); end

  def milestones(repository, options=T.unsafe(nil)); end

  def update_milestone(repository, number, options=T.unsafe(nil)); end
end

module Octokit::Client::Milestones
end

module Octokit::Client::Notifications
  def delete_thread_subscription(thread_id, options=T.unsafe(nil)); end

  def mark_notifications_as_read(options=T.unsafe(nil)); end

  def mark_repo_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_repository_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_thread_as_read(thread_id, options=T.unsafe(nil)); end

  def notifications(options=T.unsafe(nil)); end

  def repo_notifications(repo, options=T.unsafe(nil)); end

  def repository_notifications(repo, options=T.unsafe(nil)); end

  def thread_notifications(thread_id, options=T.unsafe(nil)); end

  def thread_subscription(thread_id, options=T.unsafe(nil)); end

  def update_thread_subscription(thread_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Notifications
end

module Octokit::Client::Objects
  def blob(repo, blob_sha, options=T.unsafe(nil)); end

  def create_blob(repo, content, encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_tag(repo, tag, message, object_sha, type, tagger_name, tagger_email, tagger_date, options=T.unsafe(nil)); end

  def create_tree(repo, tree, options=T.unsafe(nil)); end

  def tag(repo, tag_sha, options=T.unsafe(nil)); end

  def tree(repo, tree_sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Objects
end

module Octokit::Client::Organizations
  def add_team_member(team_id, user, options=T.unsafe(nil)); end

  def add_team_membership(team_id, user, options=T.unsafe(nil)); end

  def add_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def add_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def all_organizations(options=T.unsafe(nil)); end

  def all_orgs(options=T.unsafe(nil)); end

  def child_teams(team_id, options=T.unsafe(nil)); end

  def conceal_membership(org, user, options=T.unsafe(nil)); end

  def convert_to_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def create_team(org, options=T.unsafe(nil)); end

  def delete_migration_archive(org, id, options=T.unsafe(nil)); end

  def delete_team(team_id, options=T.unsafe(nil)); end

  def list_organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def migration_archive_url(org, id, options=T.unsafe(nil)); end

  def migration_status(org, id, options=T.unsafe(nil)); end

  def migrations(org, options=T.unsafe(nil)); end

  def org(org, options=T.unsafe(nil)); end

  def org_invitations(org, options=T.unsafe(nil)); end

  def org_member?(org, user, options=T.unsafe(nil)); end

  def org_members(org, options=T.unsafe(nil)); end

  def org_membership(org, options=T.unsafe(nil)); end

  def org_memberships(options=T.unsafe(nil)); end

  def org_public_member?(org, user, options=T.unsafe(nil)); end

  def org_public_members(org, options=T.unsafe(nil)); end

  def org_repos(org, options=T.unsafe(nil)); end

  def org_repositories(org, options=T.unsafe(nil)); end

  def org_teams(org, options=T.unsafe(nil)); end

  def organization(org, options=T.unsafe(nil)); end

  def organization_invitations(org, options=T.unsafe(nil)); end

  def organization_member?(org, user, options=T.unsafe(nil)); end

  def organization_members(org, options=T.unsafe(nil)); end

  def organization_membership(org, options=T.unsafe(nil)); end

  def organization_memberships(options=T.unsafe(nil)); end

  def organization_public_member?(org, user, options=T.unsafe(nil)); end

  def organization_public_members(org, options=T.unsafe(nil)); end

  def organization_repositories(org, options=T.unsafe(nil)); end

  def organization_teams(org, options=T.unsafe(nil)); end

  def organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def outside_collaborators(org, options=T.unsafe(nil)); end

  def publicize_membership(org, user, options=T.unsafe(nil)); end

  def remove_org_member(org, user, options=T.unsafe(nil)); end

  def remove_org_membership(org, options=T.unsafe(nil)); end

  def remove_organization_member(org, user, options=T.unsafe(nil)); end

  def remove_organization_membership(org, options=T.unsafe(nil)); end

  def remove_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def remove_team_member(team_id, user, options=T.unsafe(nil)); end

  def remove_team_membership(team_id, user, options=T.unsafe(nil)); end

  def remove_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def remove_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def start_migration(org, repositories, options=T.unsafe(nil)); end

  def team(team_id, options=T.unsafe(nil)); end

  def team_by_name(org, team_slug, options=T.unsafe(nil)); end

  def team_invitations(team_id, options=T.unsafe(nil)); end

  def team_member?(team_id, user, options=T.unsafe(nil)); end

  def team_members(team_id, options=T.unsafe(nil)); end

  def team_membership(team_id, user, options=T.unsafe(nil)); end

  def team_repo?(team_id, repo, options=T.unsafe(nil)); end

  def team_repos(team_id, options=T.unsafe(nil)); end

  def team_repositories(team_id, options=T.unsafe(nil)); end

  def team_repository?(team_id, repo, options=T.unsafe(nil)); end

  def unlock_repository(org, id, repo, options=T.unsafe(nil)); end

  def unpublicize_membership(org, user, options=T.unsafe(nil)); end

  def update_org(org, values, options=T.unsafe(nil)); end

  def update_org_membership(org, options=T.unsafe(nil)); end

  def update_organization(org, values, options=T.unsafe(nil)); end

  def update_organization_membership(org, options=T.unsafe(nil)); end

  def update_team(team_id, options=T.unsafe(nil)); end

  def user_teams(options=T.unsafe(nil)); end
end

module Octokit::Client::Organizations
end

module Octokit::Client::Pages
  def latest_pages_build(repo, options=T.unsafe(nil)); end

  def list_pages_builds(repo, options=T.unsafe(nil)); end

  def pages(repo, options=T.unsafe(nil)); end

  def pages_build(repo, id, options=T.unsafe(nil)); end

  def pages_builds(repo, options=T.unsafe(nil)); end

  def request_page_build(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Pages
end

module Octokit::Client::Projects
  def column_cards(id, options=T.unsafe(nil)); end

  def create_org_project(org, name, options=T.unsafe(nil)); end

  def create_organization_project(org, name, options=T.unsafe(nil)); end

  def create_project(repo, name, options=T.unsafe(nil)); end

  def create_project_card(id, options=T.unsafe(nil)); end

  def create_project_column(id, name, options=T.unsafe(nil)); end

  def delete_project(id, options=T.unsafe(nil)); end

  def delete_project_card(id, options=T.unsafe(nil)); end

  def delete_project_column(id, options=T.unsafe(nil)); end

  def move_project_card(id, position, options=T.unsafe(nil)); end

  def move_project_column(id, position, options=T.unsafe(nil)); end

  def org_projects(org, options=T.unsafe(nil)); end

  def organization_projects(org, options=T.unsafe(nil)); end

  def project(id, options=T.unsafe(nil)); end

  def project_card(id, options=T.unsafe(nil)); end

  def project_column(id, options=T.unsafe(nil)); end

  def project_columns(id, options=T.unsafe(nil)); end

  def projects(repo, options=T.unsafe(nil)); end

  def update_project(id, options=T.unsafe(nil)); end

  def update_project_card(id, options=T.unsafe(nil)); end

  def update_project_column(id, name, options=T.unsafe(nil)); end
end

module Octokit::Client::Projects
end

module Octokit::Client::PubSubHubbub
  def subscribe(topic, callback, secret=T.unsafe(nil)); end

  def subscribe_service_hook(repo, service_name, service_arguments=T.unsafe(nil), secret=T.unsafe(nil)); end

  def unsubscribe(topic, callback); end

  def unsubscribe_service_hook(repo, service_name); end
end

module Octokit::Client::PubSubHubbub
end

module Octokit::Client::PullRequests
  def close_pull_request(repo, number, options=T.unsafe(nil)); end

  def create_pull_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request(repo, base, head, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_pull_request_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_request_comment_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request_for_issue(repo, base, head, issue, options=T.unsafe(nil)); end

  def create_review_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_view_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def delete_pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def merge_pull_request(repo, number, commit_message=T.unsafe(nil), options=T.unsafe(nil)); end

  def pull(repo, number, options=T.unsafe(nil)); end

  def pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_comments(repo, number, options=T.unsafe(nil)); end

  def pull_commits(repo, number, options=T.unsafe(nil)); end

  def pull_files(repo, number, options=T.unsafe(nil)); end

  def pull_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_request(repo, number, options=T.unsafe(nil)); end

  def pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_request_comments(repo, number, options=T.unsafe(nil)); end

  def pull_request_commits(repo, number, options=T.unsafe(nil)); end

  def pull_request_files(repo, number, options=T.unsafe(nil)); end

  def pull_request_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_requests(repo, options=T.unsafe(nil)); end

  def pull_requests_comments(repo, options=T.unsafe(nil)); end

  def pulls(repo, options=T.unsafe(nil)); end

  def pulls_comments(repo, options=T.unsafe(nil)); end

  def review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def review_comments(repo, number, options=T.unsafe(nil)); end

  def reviews_comments(repo, options=T.unsafe(nil)); end

  def update_pull_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_pull_request(*args); end

  def update_pull_request_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_review_comment(repo, comment_id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::PullRequests
end

module Octokit::Client::RateLimit
  def rate_limit(options=T.unsafe(nil)); end

  def rate_limit!(options=T.unsafe(nil)); end

  def rate_limit_remaining(options=T.unsafe(nil)); end

  def rate_limit_remaining!(options=T.unsafe(nil)); end

  def ratelimit(options=T.unsafe(nil)); end

  def ratelimit!(options=T.unsafe(nil)); end

  def ratelimit_remaining(options=T.unsafe(nil)); end

  def ratelimit_remaining!(options=T.unsafe(nil)); end
end

module Octokit::Client::RateLimit
end

module Octokit::Client::Reactions
  def commit_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def create_commit_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_reaction(repo, number, reaction, options=T.unsafe(nil)); end

  def create_pull_request_review_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def delete_reaction(id, options=T.unsafe(nil)); end

  def issue_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def issue_reactions(repo, number, options=T.unsafe(nil)); end

  def pull_request_review_comment_reactions(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Reactions
end

module Octokit::Client::Refs
  def create_ref(repo, ref, sha, options=T.unsafe(nil)); end

  def create_reference(repo, ref, sha, options=T.unsafe(nil)); end

  def delete_branch(repo, branch, options=T.unsafe(nil)); end

  def delete_ref(repo, ref, options=T.unsafe(nil)); end

  def delete_reference(repo, ref, options=T.unsafe(nil)); end

  def list_references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def ref(repo, ref, options=T.unsafe(nil)); end

  def reference(repo, ref, options=T.unsafe(nil)); end

  def references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_branch(repo, branch, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_ref(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_reference(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Refs
end

module Octokit::Client::Releases
  def create_release(repo, tag_name, options=T.unsafe(nil)); end

  def delete_release(url, options=T.unsafe(nil)); end

  def delete_release_asset(asset_url, options=T.unsafe(nil)); end

  def edit_release(url, options=T.unsafe(nil)); end

  def edit_release_asset(asset_url, options=T.unsafe(nil)); end

  def latest_release(repo, options=T.unsafe(nil)); end

  def list_releases(repo, options=T.unsafe(nil)); end

  def release(url, options=T.unsafe(nil)); end

  def release_asset(asset_url, options=T.unsafe(nil)); end

  def release_assets(release_url, options=T.unsafe(nil)); end

  def release_for_tag(repo, tag_name, options=T.unsafe(nil)); end

  def releases(repo, options=T.unsafe(nil)); end

  def update_release(url, options=T.unsafe(nil)); end

  def update_release_asset(asset_url, options=T.unsafe(nil)); end

  def upload_asset(release_url, path_or_file, options=T.unsafe(nil)); end
end

module Octokit::Client::Releases
end

module Octokit::Client::Repositories
  def add_collab(repo, collaborator, options=T.unsafe(nil)); end

  def add_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def add_deploy_key(repo, title, key, options=T.unsafe(nil)); end

  def all_repositories(options=T.unsafe(nil)); end

  def branch(repo, branch, options=T.unsafe(nil)); end

  def branch_protection(repo, branch, options=T.unsafe(nil)); end

  def branches(repo, options=T.unsafe(nil)); end

  def check_assignee(repo, assignee, options=T.unsafe(nil)); end

  def collaborator?(repo, collaborator, options=T.unsafe(nil)); end

  def collaborators(repo, options=T.unsafe(nil)); end

  def collabs(repo, options=T.unsafe(nil)); end

  def contribs(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def contributors(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def create(name, options=T.unsafe(nil)); end

  def create_repo(name, options=T.unsafe(nil)); end

  def create_repo_from_template(repo, name, options=T.unsafe(nil)); end

  def create_repository(name, options=T.unsafe(nil)); end

  def create_repository_from_template(repo, name, options=T.unsafe(nil)); end

  def delete_repo(repo, options=T.unsafe(nil)); end

  def delete_repository(repo, options=T.unsafe(nil)); end

  def delete_subscription(repo, options=T.unsafe(nil)); end

  def deploy_key(repo, id, options=T.unsafe(nil)); end

  def deploy_keys(repo, options=T.unsafe(nil)); end

  def edit(repo, options=T.unsafe(nil)); end

  def edit_deploy_key(repo, id, options); end

  def edit_repository(repo, options=T.unsafe(nil)); end

  def fork(repo, options=T.unsafe(nil)); end

  def forks(repo, options=T.unsafe(nil)); end

  def get_branch(repo, branch, options=T.unsafe(nil)); end

  def languages(repo, options=T.unsafe(nil)); end

  def list_deploy_keys(repo, options=T.unsafe(nil)); end

  def list_repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def network(repo, options=T.unsafe(nil)); end

  def permission_level(repo, collaborator, options=T.unsafe(nil)); end

  def protect_branch(repo, branch, options=T.unsafe(nil)); end

  def remove_collab(repo, collaborator, options=T.unsafe(nil)); end

  def remove_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def remove_deploy_key(repo, id, options=T.unsafe(nil)); end

  def replace_all_topics(repo, names, options=T.unsafe(nil)); end

  def repo(repo, options=T.unsafe(nil)); end

  def repo_assignees(repo, options=T.unsafe(nil)); end

  def repo_teams(repo, options=T.unsafe(nil)); end

  def repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repository(repo, options=T.unsafe(nil)); end

  def repository?(repo, options=T.unsafe(nil)); end

  def repository_assignees(repo, options=T.unsafe(nil)); end

  def repository_teams(repo, options=T.unsafe(nil)); end

  def set_private(repo, options=T.unsafe(nil)); end

  def set_public(repo, options=T.unsafe(nil)); end

  def star(repo, options=T.unsafe(nil)); end

  def stargazers(repo, options=T.unsafe(nil)); end

  def subscribers(repo, options=T.unsafe(nil)); end

  def subscription(repo, options=T.unsafe(nil)); end

  def tags(repo, options=T.unsafe(nil)); end

  def teams(repo, options=T.unsafe(nil)); end

  def topics(repo, options=T.unsafe(nil)); end

  def transfer_repo(repo, new_owner, options=T.unsafe(nil)); end

  def transfer_repository(repo, new_owner, options=T.unsafe(nil)); end

  def unprotect_branch(repo, branch, options=T.unsafe(nil)); end

  def unstar(repo, options=T.unsafe(nil)); end

  def unwatch(repo, options=T.unsafe(nil)); end

  def update(repo, options=T.unsafe(nil)); end

  def update_deploy_key(repo, id, options); end

  def update_repository(repo, options=T.unsafe(nil)); end

  def update_subscription(repo, options=T.unsafe(nil)); end

  def watch(repo, options=T.unsafe(nil)); end

  def watchers(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Repositories
end

module Octokit::Client::RepositoryInvitations
  def accept_repo_invitation(invitation_id, options=T.unsafe(nil)); end

  def accept_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def delete_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def delete_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def invite_user_to_repo(repo, user, options=T.unsafe(nil)); end

  def invite_user_to_repository(repo, user, options=T.unsafe(nil)); end

  def repo_invitations(repo, options=T.unsafe(nil)); end

  def repository_invitations(repo, options=T.unsafe(nil)); end

  def update_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def update_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def user_repo_invitations(options=T.unsafe(nil)); end

  def user_repository_invitations(options=T.unsafe(nil)); end
end

module Octokit::Client::RepositoryInvitations
end

module Octokit::Client::Reviews
  def create_pull_request_review(repo, number, options=T.unsafe(nil)); end

  def delete_pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def delete_pull_request_review_request(repo, id, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def dismiss_pull_request_review(repo, number, review, message, options=T.unsafe(nil)); end

  def pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_comments(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_requests(repo, number, options=T.unsafe(nil)); end

  def pull_request_reviews(repo, number, options=T.unsafe(nil)); end

  def request_pull_request_review(repo, number, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_pull_request_review(repo, number, review, event, options=T.unsafe(nil)); end

  def update_pull_request_review(repo, number, review, body, options=T.unsafe(nil)); end
end

module Octokit::Client::Reviews
end

module Octokit::Client::Say
  def octocat(text=T.unsafe(nil), options=T.unsafe(nil)); end

  def say(text=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Say
end

module Octokit::Client::Search
  def search_code(query, options=T.unsafe(nil)); end

  def search_commits(query, options=T.unsafe(nil)); end

  def search_issues(query, options=T.unsafe(nil)); end

  def search_repos(query, options=T.unsafe(nil)); end

  def search_repositories(query, options=T.unsafe(nil)); end

  def search_users(query, options=T.unsafe(nil)); end
end

module Octokit::Client::Search
end

module Octokit::Client::ServiceStatus
  def github_status(); end

  def github_status_last_message(); end

  def github_status_messages(); end
  STATUS_ROOT = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::ServiceStatus
end

module Octokit::Client::SourceImport
  def cancel_source_import(repo, options=T.unsafe(nil)); end

  def map_source_import_commit_author(author_url, values, options=T.unsafe(nil)); end

  def set_source_import_lfs_preference(repo, use_lfs, options=T.unsafe(nil)); end

  def source_import_commit_authors(repo, options=T.unsafe(nil)); end

  def source_import_large_files(repo, options=T.unsafe(nil)); end

  def source_import_progress(repo, options=T.unsafe(nil)); end

  def start_source_import(*args); end

  def update_source_import(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::SourceImport
end

module Octokit::Client::Stats
  def code_frequency_stats(repo, options=T.unsafe(nil)); end

  def commit_activity_stats(repo, options=T.unsafe(nil)); end

  def contributor_stats(repo, options=T.unsafe(nil)); end

  def contributors_stats(repo, options=T.unsafe(nil)); end

  def participation_stats(repo, options=T.unsafe(nil)); end

  def punch_card(repo, options=T.unsafe(nil)); end

  def punch_card_stats(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Stats
end

module Octokit::Client::Statuses
  def combined_status(repo, ref, options=T.unsafe(nil)); end

  def create_status(repo, sha, state, options=T.unsafe(nil)); end

  def list_statuses(repo, sha, options=T.unsafe(nil)); end

  def status(repo, ref, options=T.unsafe(nil)); end

  def statuses(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Statuses
end

module Octokit::Client::Traffic
  def clones(repo, options=T.unsafe(nil)); end

  def top_paths(repo, options=T.unsafe(nil)); end

  def top_referrers(repo, options=T.unsafe(nil)); end

  def views(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Traffic
end

module Octokit::Client::Users
  def add_email(email, options=T.unsafe(nil)); end

  def add_key(title, key, options=T.unsafe(nil)); end

  def all_users(options=T.unsafe(nil)); end

  def emails(options=T.unsafe(nil)); end

  def exchange_code_for_token(code, app_id=T.unsafe(nil), app_secret=T.unsafe(nil), options=T.unsafe(nil)); end

  def follow(user, options=T.unsafe(nil)); end

  def followers(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def following(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def follows?(*args); end

  def key(key_id, options=T.unsafe(nil)); end

  def keys(options=T.unsafe(nil)); end

  def remove_email(email); end

  def remove_key(id, options=T.unsafe(nil)); end

  def starred(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def starred?(repo, options=T.unsafe(nil)); end

  def subscriptions(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def unfollow(user, options=T.unsafe(nil)); end

  def update_key(key_id, options=T.unsafe(nil)); end

  def update_user(options); end

  def user(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def user_keys(user, options=T.unsafe(nil)); end

  def validate_credentials(options=T.unsafe(nil)); end

  def watched(user=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Users
end

class Octokit::Client
end

class Octokit::ClientError
end

class Octokit::ClientError
end

module Octokit::Configurable
  def access_token(); end

  def access_token=(access_token); end

  def api_endpoint(); end

  def api_endpoint=(api_endpoint); end

  def auto_paginate(); end

  def auto_paginate=(auto_paginate); end

  def bearer_token(); end

  def bearer_token=(bearer_token); end

  def client_id(); end

  def client_id=(client_id); end

  def client_secret(); end

  def client_secret=(client_secret); end

  def configure(); end

  def connection_options(); end

  def connection_options=(connection_options); end

  def default_media_type(); end

  def default_media_type=(default_media_type); end

  def login(); end

  def login=(login); end

  def management_console_endpoint(); end

  def management_console_endpoint=(management_console_endpoint); end

  def management_console_password=(management_console_password); end

  def middleware(); end

  def middleware=(middleware); end

  def netrc(); end

  def netrc=(netrc); end

  def netrc?(); end

  def netrc_file(); end

  def netrc_file=(netrc_file); end

  def password=(password); end

  def per_page(); end

  def per_page=(per_page); end

  def proxy(); end

  def proxy=(proxy); end

  def reset!(); end

  def same_options?(opts); end

  def setup(); end

  def ssl_verify_mode(); end

  def ssl_verify_mode=(ssl_verify_mode); end

  def user_agent(); end

  def user_agent=(user_agent); end

  def web_endpoint(); end

  def web_endpoint=(web_endpoint); end
end

module Octokit::Configurable
  def self.keys(); end
end

class Octokit::Conflict
end

class Octokit::Conflict
end

module Octokit::Connection
  include ::Octokit::Authentication
  def agent(); end

  def delete(url, options=T.unsafe(nil)); end

  def endpoint(); end

  def get(url, options=T.unsafe(nil)); end

  def head(url, options=T.unsafe(nil)); end

  def last_response(); end

  def paginate(url, options=T.unsafe(nil), &block); end

  def patch(url, options=T.unsafe(nil)); end

  def post(url, options=T.unsafe(nil)); end

  def put(url, options=T.unsafe(nil)); end

  def root(); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Connection
end

module Octokit::Default
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  WEB_ENDPOINT = ::T.let(nil, ::T.untyped)
end

Octokit::Default::RACK_BUILDER_CLASS = Faraday::RackBuilder

module Octokit::Default
  def self.access_token(); end

  def self.api_endpoint(); end

  def self.auto_paginate(); end

  def self.bearer_token(); end

  def self.client_id(); end

  def self.client_secret(); end

  def self.connection_options(); end

  def self.default_media_type(); end

  def self.login(); end

  def self.management_console_endpoint(); end

  def self.management_console_password(); end

  def self.middleware(); end

  def self.netrc(); end

  def self.netrc_file(); end

  def self.options(); end

  def self.password(); end

  def self.per_page(); end

  def self.proxy(); end

  def self.ssl_verify_mode(); end

  def self.user_agent(); end

  def self.web_endpoint(); end
end

class Octokit::EnterpriseAdminClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseAdminClient::AdminStats
  include ::Octokit::EnterpriseAdminClient::License
  include ::Octokit::EnterpriseAdminClient::Orgs
  include ::Octokit::EnterpriseAdminClient::SearchIndexing
  include ::Octokit::EnterpriseAdminClient::Users
  def initialize(options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::AdminStats
  def admin_comments_stats(); end

  def admin_gists_stats(); end

  def admin_hooks_stats(); end

  def admin_issues_stats(); end

  def admin_milestones_stats(); end

  def admin_organization_stats(); end

  def admin_pages_stats(); end

  def admin_pull_requests_stats(); end

  def admin_repository_stats(); end

  def admin_stats(); end

  def admin_users_stats(); end
end

module Octokit::EnterpriseAdminClient::AdminStats
end

module Octokit::EnterpriseAdminClient::License
  def license_info(); end
end

module Octokit::EnterpriseAdminClient::License
end

module Octokit::EnterpriseAdminClient::Orgs
  def create_organization(login, admin, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Orgs
end

module Octokit::EnterpriseAdminClient::SearchIndexing
  def index_organization(user); end

  def index_organizations_repositories(user); end

  def index_organizations_repositories_code(user); end

  def index_organizations_repositories_issues(user); end

  def index_repository(repo); end

  def index_repository_code(repo); end

  def index_repository_issues(repo); end

  def index_user(user); end

  def index_users_repositories(user); end

  def index_users_repositories_code(user); end

  def index_users_repositories_issues(user); end
end

module Octokit::EnterpriseAdminClient::SearchIndexing
end

module Octokit::EnterpriseAdminClient::Users
  def create_impersonation_token(login, options=T.unsafe(nil)); end

  def create_user(login, email, options=T.unsafe(nil)); end

  def delete_impersonation_token(login, options=T.unsafe(nil)); end

  def delete_key(id, options=T.unsafe(nil)); end

  def delete_user(username, options=T.unsafe(nil)); end

  def demote(user, options=T.unsafe(nil)); end

  def list_all_keys(options=T.unsafe(nil)); end

  def promote(user, options=T.unsafe(nil)); end

  def rename_user(old_login, new_login, options=T.unsafe(nil)); end

  def suspend(user, options=T.unsafe(nil)); end

  def unsuspend(user, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Users
end

class Octokit::EnterpriseAdminClient
end

class Octokit::EnterpriseManagementConsoleClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def initialize(options=T.unsafe(nil)); end

  def management_console_endpoint=(value); end

  def management_console_password=(value); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def add_authorized_key(key); end

  def authorized_keys(); end

  def config_check(); end

  def config_status(); end

  def delete_authorized_key(key); end

  def edit_maintenance_status(maintenance); end

  def edit_settings(settings); end

  def get_authorized_keys(); end

  def get_maintenance_status(); end

  def get_settings(); end

  def maintenance_status(); end

  def remove_authorized_key(key); end

  def set_maintenance_status(maintenance); end

  def settings(); end

  def start_configuration(); end

  def upgrade(license); end

  def upload_license(license, settings=T.unsafe(nil)); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
end

class Octokit::EnterpriseManagementConsoleClient
end

class Octokit::Error
  def documentation_url(); end

  def errors(); end

  def initialize(response=T.unsafe(nil)); end

  def response_body(); end

  def response_headers(); end

  def response_status(); end
end

class Octokit::Error
  def self.error_for_401(headers); end

  def self.error_for_403(body); end

  def self.error_for_404(body); end

  def self.from_response(response); end
end

class Octokit::Forbidden
end

class Octokit::Forbidden
end

class Octokit::Gist
  def id(); end

  def id=(id); end

  def initialize(gist); end

  def url(); end
end

class Octokit::Gist
  def self.from_url(url); end
end

class Octokit::InternalServerError
end

class Octokit::InternalServerError
end

class Octokit::InvalidRepository
end

class Octokit::InvalidRepository
end

class Octokit::MethodNotAllowed
end

class Octokit::MethodNotAllowed
end

module Octokit::Middleware
end

class Octokit::Middleware::FollowRedirects
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class Octokit::Middleware::FollowRedirects
end

class Octokit::Middleware::RedirectLimitReached
  def initialize(response); end
end

class Octokit::Middleware::RedirectLimitReached
end

module Octokit::Middleware
end

class Octokit::MissingContentType
end

class Octokit::MissingContentType
end

class Octokit::NotAcceptable
end

class Octokit::NotAcceptable
end

class Octokit::NotFound
end

class Octokit::NotFound
end

class Octokit::NotImplemented
end

class Octokit::NotImplemented
end

class Octokit::OneTimePasswordRequired
  def password_delivery(); end
  OTP_DELIVERY_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::OneTimePasswordRequired
  def self.required_header(headers); end
end

class Octokit::Organization
end

class Octokit::Organization
  def self.path(org); end
end

module Octokit::Preview
  def ensure_api_media_type(type, options); end

  def warn_preview(type); end
  PREVIEW_TYPES = ::T.let(nil, ::T.untyped)
end

module Octokit::Preview
end

class Octokit::RateLimit
end

class Octokit::RateLimit
  def self.from_response(response); end
end

class Octokit::RepoArguments
  def repo(); end
end

class Octokit::RepoArguments
end

class Octokit::Repository
  def id(); end

  def id=(id); end

  def id_api_path(); end

  def initialize(repo); end

  def name(); end

  def name=(name); end

  def named_api_path(); end

  def owner(); end

  def owner=(owner); end

  def path(); end

  def repo(); end

  def slug(); end

  def url(); end

  def user(); end

  def username(); end
  NAME_WITH_OWNER_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::Repository
  def self.from_url(url); end

  def self.path(repo); end
end

class Octokit::RepositoryUnavailable
end

class Octokit::RepositoryUnavailable
end

module Octokit::Response
end

class Octokit::Response::FeedParser
end

class Octokit::Response::FeedParser
end

class Octokit::Response::RaiseError
end

class Octokit::Response::RaiseError
end

module Octokit::Response
end

class Octokit::SAMLProtected
end

class Octokit::SAMLProtected
end

class Octokit::ServerError
end

class Octokit::ServerError
end

class Octokit::ServiceUnavailable
end

class Octokit::ServiceUnavailable
end

class Octokit::TooLargeContent
end

class Octokit::TooLargeContent
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyRequests
end

class Octokit::TooManyRequests
end

class Octokit::Unauthorized
end

class Octokit::Unauthorized
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnprocessableEntity
end

class Octokit::UnprocessableEntity
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnverifiedEmail
end

class Octokit::UnverifiedEmail
end

class Octokit::User
end

class Octokit::User
  def self.path(user); end
end

module Octokit::Warnable
  def octokit_warn(*message); end
end

module Octokit::Warnable
end

module Octokit
  extend ::Octokit::Configurable
  def self.client(); end

  def self.enterprise_admin_client(); end

  def self.enterprise_management_console_client(); end
end

module OmniAuth
end

class OmniAuth::AuthHash
  def regular_writer(key, value); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def name(); end

  def name?(); end

  def to_hash(); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def self.subkey_class(); end
end

class OmniAuth::AuthHash
  def self.subkey_class(); end
end

class OmniAuth::Builder
  def before_callback_phase(&block); end

  def before_options_phase(&block); end

  def before_request_phase(&block); end

  def configure(&block); end

  def on_failure(&block); end

  def options(options=T.unsafe(nil)); end

  def provider(klass, *args, &block); end
end

class OmniAuth::Builder
end

class OmniAuth::Configuration
  include ::Singleton
  def add_camelization(name, camelized); end

  def add_mock(provider, original=T.unsafe(nil)); end

  def allowed_request_methods(); end

  def allowed_request_methods=(allowed_request_methods); end

  def before_callback_phase(&block); end

  def before_callback_phase=(before_callback_phase); end

  def before_options_phase(&block); end

  def before_options_phase=(before_options_phase); end

  def before_request_phase(&block); end

  def before_request_phase=(before_request_phase); end

  def camelizations(); end

  def camelizations=(camelizations); end

  def failure_raise_out_environments(); end

  def failure_raise_out_environments=(failure_raise_out_environments); end

  def form_css(); end

  def form_css=(form_css); end

  def full_host(); end

  def full_host=(full_host); end

  def logger(); end

  def logger=(logger); end

  def mock_auth(); end

  def mock_auth=(mock_auth); end

  def on_failure(&block); end

  def on_failure=(on_failure); end

  def path_prefix(); end

  def path_prefix=(path_prefix); end

  def test_mode(); end

  def test_mode=(test_mode); end
end

class OmniAuth::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.default_logger(); end

  def self.defaults(); end

  def self.instance(); end
end

class OmniAuth::Error
end

class OmniAuth::Error
end

class OmniAuth::FailureEndpoint
  def call(); end

  def env(); end

  def initialize(env); end

  def origin_query_param(); end

  def raise_out!(); end

  def redirect_to_failure(); end

  def strategy_name_query_param(); end
end

class OmniAuth::FailureEndpoint
  def self.call(env); end
end

class OmniAuth::Form
  def button(text); end

  def css(); end

  def fieldset(legend, options=T.unsafe(nil), &block); end

  def footer(); end

  def header(title, header_info); end

  def html(html); end

  def initialize(options=T.unsafe(nil)); end

  def input_field(type, name); end

  def label_field(text, target); end

  def options(); end

  def options=(options); end

  def password_field(label, name); end

  def text_field(label, name); end

  def to_html(); end

  def to_response(); end
  DEFAULT_CSS = ::T.let(nil, ::T.untyped)
end

class OmniAuth::Form
  def self.build(options=T.unsafe(nil), &block); end
end

module OmniAuth::GitHub
  VERSION = ::T.let(nil, ::T.untyped)
end

module OmniAuth::GitHub
end

class OmniAuth::KeyStore
end

class OmniAuth::KeyStore
  def self.override_logging(); end
end

class OmniAuth::NoSessionError
end

class OmniAuth::NoSessionError
end

module OmniAuth::OAuth2
  VERSION = ::T.let(nil, ::T.untyped)
end

module OmniAuth::OAuth2
end

module OmniAuth::Strategies
end

class OmniAuth::Strategies::Developer
  include ::OmniAuth::Strategy
end

class OmniAuth::Strategies::Developer
  extend ::OmniAuth::Strategy::ClassMethods
end

class OmniAuth::Strategies::GitHub
  def email(); end

  def email_access_allowed?(); end

  def emails(); end

  def primary_email(); end

  def raw_info(); end

  def scope(); end
end

class OmniAuth::Strategies::GitHub
end

class OmniAuth::Strategies::OAuth2
  include ::OmniAuth::Strategy
  def access_token(); end

  def access_token=(access_token); end

  def authorize_params(); end

  def build_access_token(); end

  def client(); end

  def deep_symbolize(options); end

  def options_for(option); end

  def token_params(); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
  def error(); end

  def error=(error); end

  def error_reason(); end

  def error_reason=(error_reason); end

  def error_uri(); end

  def error_uri=(error_uri); end

  def initialize(error, error_reason=T.unsafe(nil), error_uri=T.unsafe(nil)); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
end

class OmniAuth::Strategies::OAuth2
  extend ::OmniAuth::Strategy::ClassMethods
  def self.inherited(subclass); end
end

module OmniAuth::Strategies
end

module OmniAuth::Strategy
  def app(); end

  def auth_hash(); end

  def call(env); end

  def call!(env); end

  def call_app!(env=T.unsafe(nil)); end

  def callback_call(); end

  def callback_path(); end

  def callback_phase(); end

  def callback_url(); end

  def credentials(); end

  def current_path(); end

  def custom_path(kind); end

  def dup(); end

  def env(); end

  def extra(); end

  def fail!(message_key, exception=T.unsafe(nil)); end

  def full_host(); end

  def info(); end

  def initialize(app, *args, &block); end

  def inspect(); end

  def log(level, message); end

  def merge_stack(stack); end

  def mock_call!(*_); end

  def mock_callback_call(); end

  def mock_request_call(); end

  def name(); end

  def on_auth_path?(); end

  def on_callback_path?(); end

  def on_path?(path); end

  def on_request_path?(); end

  def options(); end

  def options_call(); end

  def options_request?(); end

  def path_prefix(); end

  def query_string(); end

  def redirect(uri); end

  def request(); end

  def request_call(); end

  def request_path(); end

  def request_phase(); end

  def response(); end

  def script_name(); end

  def session(); end

  def setup_path(); end

  def setup_phase(); end

  def skip_info?(); end

  def ssl?(); end

  def uid(); end

  def user_info(); end
  CURRENT_PATH_REGEX = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

module OmniAuth::Strategy::ClassMethods
  def args(args=T.unsafe(nil)); end

  def compile_stack(ancestors, method, context); end

  def configure(options=T.unsafe(nil)); end

  def credentials(&block); end

  def credentials_stack(context); end

  def default_options(); end

  def extra(&block); end

  def extra_stack(context); end

  def info(&block); end

  def info_stack(context); end

  def option(name, value=T.unsafe(nil)); end

  def uid(&block); end

  def uid_stack(context); end
end

module OmniAuth::Strategy::ClassMethods
end

class OmniAuth::Strategy::Options
end

class OmniAuth::Strategy::Options
end

module OmniAuth::Strategy
  def self.included(base); end
end

module OmniAuth::Test
end

class OmniAuth::Test::PhonySession
  def call(env); end

  def initialize(app); end
end

class OmniAuth::Test::PhonySession
end

module OmniAuth::Test::StrategyMacros
  def sets_an_auth_hash(); end

  def sets_provider_to(provider); end

  def sets_uid_to(uid); end

  def sets_user_info_to(user_info); end
end

module OmniAuth::Test::StrategyMacros
end

module OmniAuth::Test::StrategyTestCase
  def app(); end

  def app_response(); end

  def session(); end

  def strategy(); end
end

module OmniAuth::Test::StrategyTestCase
end

module OmniAuth::Test
end

module OmniAuth::Utils
end

module OmniAuth::Utils
  def self.camelize(word, first_letter_in_uppercase=T.unsafe(nil)); end

  def self.deep_merge(hash, other_hash); end

  def self.form_css(); end
end

module OmniAuth
  def self.config(); end

  def self.configure(); end

  def self.logger(); end

  def self.mock_auth_for(provider); end

  def self.strategies(); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module PTY
end

class PTY::ChildExited
  def status(); end
end

class PTY::ChildExited
end

module PTY
  def self.check(*_); end

  def self.getpty(*_); end

  def self.open(); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parlour::ConflictResolver
  def resolve_conflicts(*args, &blk); end
end

class Parlour::ConflictResolver
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging
end

module Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging::Tree
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.begin(*args, &blk); end

  def self.end(*args, &blk); end

  def self.here(*args, &blk); end

  def self.line_prefix(); end

  def self.text_prefix(); end
end

module Parlour::Debugging
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.debug_mode=(*args, &blk); end

  def self.debug_mode?(*args, &blk); end

  def self.debug_puts(*args, &blk); end

  def self.name_for_debug_caller(*args, &blk); end
end

class Parlour::DetachedRbiGenerator
  def detached!(*args, &blk); end
end

class Parlour::DetachedRbiGenerator
end

class Parlour::ParseError
  def buffer(*args, &blk); end

  def initialize(buffer, range); end

  def range(*args, &blk); end
end

class Parlour::ParseError
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Plugin
  def generate(*args, &blk); end

  def initialize(*args, &blk); end

  def strictness(*args, &blk); end

  def strictness=(strictness); end
end

class Parlour::Plugin
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.inherited(*args, &blk); end

  def self.registered_plugins(*args, &blk); end

  def self.run_plugins(*args, &blk); end
end

class Parlour::RbiGenerator
  def current_plugin(*args, &blk); end

  def current_plugin=(current_plugin); end

  def initialize(*args, &blk); end

  def options(*args, &blk); end

  def rbi(*args, &blk); end

  def root(*args, &blk); end
end

class Parlour::RbiGenerator::Arbitrary
  def ==(*args, &blk); end

  def code(*args, &blk); end

  def code=(code); end
end

class Parlour::RbiGenerator::Arbitrary
end

class Parlour::RbiGenerator::Attribute
  def class_attribute(*args, &blk); end

  def kind(*args, &blk); end
end

class Parlour::RbiGenerator::Attribute
end

class Parlour::RbiGenerator::ClassNamespace
  def abstract(*args, &blk); end

  def superclass(*args, &blk); end
end

class Parlour::RbiGenerator::ClassNamespace
end

class Parlour::RbiGenerator::Constant
  def ==(*args, &blk); end

  def value(*args, &blk); end
end

class Parlour::RbiGenerator::Constant
end

class Parlour::RbiGenerator::EnumClassNamespace
  def enums(*args, &blk); end
end

class Parlour::RbiGenerator::EnumClassNamespace
end

class Parlour::RbiGenerator::Extend
  def ==(*args, &blk); end
end

class Parlour::RbiGenerator::Extend
end

class Parlour::RbiGenerator::Include
  def ==(*args, &blk); end
end

class Parlour::RbiGenerator::Include
end

class Parlour::RbiGenerator::Method
  def ==(*args, &blk); end

  def abstract(*args, &blk); end

  def class_method(*args, &blk); end

  def final(*args, &blk); end

  def implementation(*args, &blk); end

  def overridable(*args, &blk); end

  def override(*args, &blk); end

  def parameters(*args, &blk); end

  def return_type(*args, &blk); end

  def type_parameters(*args, &blk); end
end

class Parlour::RbiGenerator::Method
end

class Parlour::RbiGenerator::ModuleNamespace
  def interface(*args, &blk); end
end

class Parlour::RbiGenerator::ModuleNamespace
end

class Parlour::RbiGenerator::Namespace
  def add_comment_to_next_child(*args, &blk); end

  def children(*args, &blk); end

  def constants(*args, &blk); end

  def create_arbitrary(code:, &block); end

  def create_attr(*args, &blk); end

  def create_attr_accessor(*args, &blk); end

  def create_attr_reader(*args, &blk); end

  def create_attr_writer(*args, &blk); end

  def create_attribute(*args, &blk); end

  def create_class(*args, &blk); end

  def create_constant(*args, &blk); end

  def create_enum_class(*args, &blk); end

  def create_extend(*args, &blk); end

  def create_extends(*args, &blk); end

  def create_include(*args, &blk); end

  def create_includes(*args, &blk); end

  def create_method(*args, &blk); end

  def create_module(*args, &blk); end

  def create_type_alias(*args, &blk); end

  def extends(*args, &blk); end

  def final(*args, &blk); end

  def includes(*args, &blk); end

  def path(*args, &blk); end
end

class Parlour::RbiGenerator::Namespace
end

class Parlour::RbiGenerator::Options
  def break_params(*args, &blk); end

  def indented(*args, &blk); end

  def initialize(*args, &blk); end

  def sort_namespaces(*args, &blk); end

  def tab_size(*args, &blk); end
end

class Parlour::RbiGenerator::Options
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Parameter
  def ==(*args, &blk); end

  def default(*args, &blk); end

  def initialize(*args, &blk); end

  def kind(*args, &blk); end

  def name(*args, &blk); end

  def name_without_kind(*args, &blk); end

  def to_def_param(*args, &blk); end

  def to_sig_param(*args, &blk); end

  def type(*args, &blk); end
  PREFIXES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::RbiObject
  def add_comment(*args, &blk); end

  def add_comments(*args, &blk); end

  def comments(*args, &blk); end

  def describe(*args, &blk); end

  def generate_rbi(*args, &blk); end

  def generated_by(*args, &blk); end

  def generator(*args, &blk); end

  def initialize(*args, &blk); end

  def merge_into_self(*args, &blk); end

  def mergeable?(*args, &blk); end

  def name(*args, &blk); end
end

class Parlour::RbiGenerator::RbiObject
  extend ::T::Helpers
  extend ::T::Sig
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::TypeLoader
end

module Parlour::TypeLoader
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.load_file(*args, &blk); end

  def self.load_project(*args, &blk); end

  def self.load_source(*args, &blk); end
end

class Parlour::TypeParser
  def ast(*args, &blk); end

  def ast=(ast); end

  def body_has_modifier?(*args, &blk); end

  def body_includes_and_extends(*args, &blk); end

  def constant_names(*args, &blk); end

  def initialize(*args, &blk); end

  def node_to_s(*args, &blk); end

  def parse_all(*args, &blk); end

  def parse_err(*args, &blk); end

  def parse_path_to_object(*args, &blk); end

  def parse_sig_into_methods(*args, &blk); end

  def parse_sig_into_sig(*args, &blk); end

  def sig_node?(*args, &blk); end

  def unknown_node_errors(*args, &blk); end

  def zip_by(*args, &blk); end
end

class Parlour::TypeParser::IntermediateSig
  def abstract(); end

  def abstract=(val); end

  def final(); end

  def final=(val); end

  def initialize(hash=T.unsafe(nil)); end

  def overridable(); end

  def overridable=(val); end

  def override(); end

  def override=(val); end

  def params(); end

  def params=(val); end

  def return_type(); end

  def return_type=(val); end

  def type_parameters(); end

  def type_parameters=(val); end
end

class Parlour::TypeParser::IntermediateSig
  def self.inherited(s); end
end

class Parlour::TypeParser::NodePath
  def child(*args, &blk); end

  def indices(*args, &blk); end

  def initialize(*args, &blk); end

  def parent(*args, &blk); end

  def sibling(*args, &blk); end

  def traverse(*args, &blk); end
end

class Parlour::TypeParser::NodePath
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::TypeParser
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.from_source(*args, &blk); end
end

module Parlour
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_if(node); end

  def on_iflipflop(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def gvar(token); end

  def ident(token); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_op(receiver, match_t, arg); end

  def method_ref(receiver, dot_t, selector_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def numparam(token); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

Parser::CurrentRuby = Parser::Ruby25

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def max_numparam(); end

  def max_numparam_stack(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  NUMPARAM_MAX = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::MaxNumparamStack
  def can_have_numparams?(); end

  def cant_have_numparams!(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def top(); end
end

class Parser::Lexer::MaxNumparamStack
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

class Parser::Ruby25
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_121(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_127(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_243(val, _values, result); end

  def _reduce_247(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_250(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_268(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_272(val, _values, result); end

  def _reduce_273(val, _values, result); end

  def _reduce_275(val, _values, result); end

  def _reduce_276(val, _values, result); end

  def _reduce_277(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_302(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_334(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_53(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_74(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby25
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def diagnostics(); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def call_enforcer_for_merge(action); end

  def combine(action); end

  def do_combine(action); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def ordered_replacements(); end

  def place_in_hierachy(action); end

  def range(); end

  def relationship_with(action); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declared?(name); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

module Parser
end

module Parts
end

class Parts::EpiloguePart
  include ::Parts::Part
  def initialize(boundary); end
end

class Parts::EpiloguePart
end

class Parts::FilePart
  include ::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Parts::FilePart
end

class Parts::ParamPart
  include ::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Parts::ParamPart
end

module Parts::Part
  def length(); end

  def to_io(); end
end

module Parts::Part
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Parts
end

class PatchedStringIO
  def orig_read_nonblock(*_); end

  def read_nonblock(size, *args); end
end

class PatchedStringIO
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

module Polyfill
  VERSION = ::T.let(nil, ::T.untyped)
end

module Polyfill::InternalUtils
end

module Polyfill::InternalUtils
  def self.create_module(); end

  def self.current_ruby_version(); end

  def self.ignore_warnings(); end

  def self.keep_only_these_methods!(mod, whitelist); end

  def self.methods_to_keep(modules, methods, lead_symbol, module_name); end

  def self.modules_to_use(module_name, versions); end

  def self.polyfill_versions_to_use(desired_version=T.unsafe(nil)); end

  def self.to_f(obj); end

  def self.to_hash(obj); end

  def self.to_int(obj); end

  def self.to_str(obj); end
end

module Polyfill::Module
end

module Polyfill::Module::M70195045702480
end

module Polyfill::Module::M70195045702480
end

module Polyfill::Module::M70195045849000
end

module Polyfill::Module::M70195045849000
end

module Polyfill::Module::M70195045880120
end

module Polyfill::Module::M70195045880120
end

module Polyfill::Module::M70195045896220
end

module Polyfill::Module::M70195045896220
end

module Polyfill::Module::M70195045958460
end

module Polyfill::Module::M70195045958460
end

module Polyfill::Module::M70195046217040
end

module Polyfill::Module::M70195046217040
end

module Polyfill::Module
end

module Polyfill::V2_2
end

module Polyfill::V2_2::Enumerable
  def max(n=T.unsafe(nil)); end

  def max_by(n=T.unsafe(nil)); end

  def min(n=T.unsafe(nil)); end

  def min_by(n=T.unsafe(nil)); end

  def slice_after(pattern=T.unsafe(nil)); end

  def slice_when(); end
end

module Polyfill::V2_2::Enumerable
end

module Polyfill::V2_2::Kernel
  def itself(); end
end

module Polyfill::V2_2::Kernel
end

module Polyfill::V2_2::Math
end

module Polyfill::V2_2::Math::ClassMethods
  def log(*args); end
end

module Polyfill::V2_2::Math::ClassMethods
end

module Polyfill::V2_2::Math
end

module Polyfill::V2_2::Prime
end

module Polyfill::V2_2::Prime::ClassMethods
  def prime?(*args); end
end

module Polyfill::V2_2::Prime::ClassMethods
end

module Polyfill::V2_2::Prime
end

module Polyfill::V2_2::Vector
  def +@(); end
end

module Polyfill::V2_2::Vector
end

module Polyfill::V2_2
end

module Polyfill::V2_3
end

module Polyfill::V2_3::Array
  def bsearch_index(); end

  def dig(head, *rest); end
end

module Polyfill::V2_3::Array
end

module Polyfill::V2_3::Enumerable
  def chunk_while(); end

  def grep_v(pattern); end

  def slice_before(*args); end
end

module Polyfill::V2_3::Enumerable
end

module Polyfill::V2_3::Enumerator
end

module Polyfill::V2_3::Enumerator::Lazy
  def grep_v(pattern); end
end

module Polyfill::V2_3::Enumerator::Lazy
end

module Polyfill::V2_3::Enumerator
end

module Polyfill::V2_3::Hash
  def <(other); end

  def <=(other); end

  def >(other); end

  def >=(other); end

  def dig(head, *rest); end

  def fetch_values(*keys); end

  def to_proc(); end
end

module Polyfill::V2_3::Hash
end

module Polyfill::V2_3::Kernel
  def loop(); end
end

module Polyfill::V2_3::Kernel
end

module Polyfill::V2_3::Numeric
  def negative?(); end

  def positive?(); end
end

module Polyfill::V2_3::Numeric
end

module Polyfill::V2_3::Prime
end

module Polyfill::V2_3::Prime::ClassMethods
  def prime?(*args); end
end

module Polyfill::V2_3::Prime::ClassMethods
end

module Polyfill::V2_3::Prime
end

module Polyfill::V2_3::String
  def +@(); end

  def -@(); end
end

module Polyfill::V2_3::String::ClassMethods
  def new(*args); end
end

module Polyfill::V2_3::String::ClassMethods
end

module Polyfill::V2_3::String
end

module Polyfill::V2_3::Struct
  def dig(head, *rest); end
end

module Polyfill::V2_3::Struct
end

module Polyfill::V2_3
end

module Polyfill::V2_4
end

module Polyfill::V2_4::Array
  def concat(*others); end

  def sum(init=T.unsafe(nil)); end
end

module Polyfill::V2_4::Array
end

module Polyfill::V2_4::Comparable
  def clamp(min, max); end
end

module Polyfill::V2_4::Comparable
end

module Polyfill::V2_4::Dir
end

module Polyfill::V2_4::Dir::ClassMethods
  def empty?(path_name); end
end

module Polyfill::V2_4::Dir::ClassMethods
end

module Polyfill::V2_4::Dir
end

module Polyfill::V2_4::Enumerable
  def chunk(*_); end

  def sum(init=T.unsafe(nil)); end

  def uniq(); end
end

module Polyfill::V2_4::Enumerable
end

module Polyfill::V2_4::Enumerator
end

module Polyfill::V2_4::Enumerator::Lazy
  def chunk_while(); end

  def uniq(); end
end

module Polyfill::V2_4::Enumerator::Lazy
end

module Polyfill::V2_4::Enumerator
end

module Polyfill::V2_4::File
end

module Polyfill::V2_4::File::ClassMethods
  def empty?(file_name); end
end

module Polyfill::V2_4::File::ClassMethods
end

module Polyfill::V2_4::File
end

module Polyfill::V2_4::Float
  def ceil(ndigits=T.unsafe(nil)); end

  def floor(ndigits=T.unsafe(nil)); end

  def truncate(ndigits=T.unsafe(nil)); end
end

module Polyfill::V2_4::Float
end

module Polyfill::V2_4::Hash
  def compact(); end

  def compact!(); end

  def transform_values(); end

  def transform_values!(); end
end

module Polyfill::V2_4::Hash
end

module Polyfill::V2_4::IO
  def each_line(*args); end

  def gets(*args); end

  def lines(*args); end

  def readline(*args); end

  def readlines(*args); end
end

module Polyfill::V2_4::IO::ClassMethods
  def foreach(name, *args); end

  def readlines(file_name, *args); end
end

module Polyfill::V2_4::IO::ClassMethods
end

module Polyfill::V2_4::IO
end

module Polyfill::V2_4::IPAddr
  def ==(*_); end
end

module Polyfill::V2_4::IPAddr
end

module Polyfill::V2_4::Integer
  def ceil(ndigits=T.unsafe(nil)); end

  def digits(base=T.unsafe(nil)); end

  def floor(ndigits=T.unsafe(nil)); end

  def round(ndigits=T.unsafe(nil), half: T.unsafe(nil)); end

  def truncate(ndigits=T.unsafe(nil)); end
end

module Polyfill::V2_4::Integer
end

module Polyfill::V2_4::MatchData
  def named_captures(); end

  def values_at(*indexes); end
end

module Polyfill::V2_4::MatchData
end

module Polyfill::V2_4::Numeric
  def clone(freeze: T.unsafe(nil)); end

  def dup(); end

  def finite?(); end

  def infinite?(); end
end

module Polyfill::V2_4::Numeric
end

module Polyfill::V2_4::Object
  def clone(freeze: T.unsafe(nil)); end
end

module Polyfill::V2_4::Object
end

module Polyfill::V2_4::Pathname
  def empty?(); end
end

module Polyfill::V2_4::Pathname
end

module Polyfill::V2_4::Regexp
  def match?(string, position=T.unsafe(nil)); end
end

module Polyfill::V2_4::Regexp
end

module Polyfill::V2_4::String
  def casecmp?(other); end

  def concat(*others); end

  def each_line(*args); end

  def lines(*args); end

  def match?(pattern, position=T.unsafe(nil)); end

  def prepend(*others); end

  def unpack1(*args); end
end

module Polyfill::V2_4::String::ClassMethods
  def new(*args); end
end

module Polyfill::V2_4::String::ClassMethods
end

module Polyfill::V2_4::String
end

module Polyfill::V2_4::StringIO
  def each_line(*args); end

  def gets(*args); end

  def lines(*args); end

  def readline(*args); end

  def readlines(*args); end
end

module Polyfill::V2_4::StringIO::ClassMethods
  def foreach(name, *args); end

  def readlines(file_name, *args); end
end

module Polyfill::V2_4::StringIO::ClassMethods
end

module Polyfill::V2_4::StringIO
end

module Polyfill::V2_4::Symbol
  def casecmp?(other); end

  def match(*args); end

  def match?(pattern, position=T.unsafe(nil)); end
end

module Polyfill::V2_4::Symbol
end

module Polyfill::V2_4
end

module Polyfill::V2_5
end

module Polyfill::V2_5::Array
  def append(*args); end

  def prepend(*args); end
end

module Polyfill::V2_5::Array
end

module Polyfill::V2_5::BigDecimal
  def clone(); end

  def dup(); end
end

module Polyfill::V2_5::BigDecimal
end

module Polyfill::V2_5::Dir
end

module Polyfill::V2_5::Dir::ClassMethods
  def children(dirname, encoding: T.unsafe(nil)); end

  def each_child(dirname, encoding: T.unsafe(nil)); end
end

module Polyfill::V2_5::Dir::ClassMethods
end

module Polyfill::V2_5::Dir
end

module Polyfill::V2_5::Enumerable
  def all?(*pattern); end

  def any?(*pattern); end

  def none?(*pattern); end

  def one?(*pattern); end
end

module Polyfill::V2_5::Enumerable
end

module Polyfill::V2_5::Hash
  def slice(*keys); end

  def transform_keys(); end
end

module Polyfill::V2_5::Hash
end

module Polyfill::V2_5::Integer
  def allbits?(mask); end

  def anybits?(mask); end

  def ceil(*_); end

  def floor(*_); end

  def nobits?(mask); end

  def round(*_); end

  def truncate(*_); end
end

module Polyfill::V2_5::Integer::ClassMethods
  def sqrt(n); end
end

module Polyfill::V2_5::Integer::ClassMethods
end

module Polyfill::V2_5::Integer
end

module Polyfill::V2_5::Kernel
  def yield_self(); end
end

module Polyfill::V2_5::Kernel
end

module Polyfill::V2_5::Set
  def ===(other); end

  def to_s(); end
end

module Polyfill::V2_5::Set
end

module Polyfill::V2_5::String
  def casecmp(other_str); end

  def casecmp?(other_str); end

  def delete_prefix(prefix); end

  def delete_prefix!(prefix); end

  def delete_suffix(suffix); end

  def delete_suffix!(suffix); end

  def each_grapheme_cluster(); end

  def grapheme_clusters(); end

  def start_with?(*prefixes); end
end

module Polyfill::V2_5::String
end

module Polyfill::V2_5::Struct
end

module Polyfill::V2_5::Struct::ClassMethods
  def new(*args, keyword_init: T.unsafe(nil)); end
end

module Polyfill::V2_5::Struct::ClassMethods
end

module Polyfill::V2_5::Struct
end

module Polyfill::V2_5::Time
end

module Polyfill::V2_5::Time::ClassMethods
  def at(*args); end
end

module Polyfill::V2_5::Time::ClassMethods
end

module Polyfill::V2_5::Time
end

module Polyfill::V2_5
end

module Polyfill::V2_6
end

module Polyfill::V2_6::Array
  def difference(*arrays); end

  def to_h(); end

  def union(*arrays); end
end

module Polyfill::V2_6::Array
end

module Polyfill::V2_6::Enumerable
  def to_h(); end
end

module Polyfill::V2_6::Enumerable
end

module Polyfill::V2_6::Hash
  def merge(*args); end

  def merge!(*args); end

  def to_h(); end

  def update(*args); end
end

module Polyfill::V2_6::Hash
end

module Polyfill::V2_6::Kernel
  def Complex(*args, exception: T.unsafe(nil)); end

  def Float(arg, exception: T.unsafe(nil)); end

  def Integer(arg, exception: T.unsafe(nil)); end

  def Rational(*args, exception: T.unsafe(nil)); end

  def then(); end
end

module Polyfill::V2_6::Kernel
end

module Polyfill::V2_6::OpenStruct
  def to_h(); end
end

module Polyfill::V2_6::OpenStruct
end

module Polyfill::V2_6::String
  def split(*_); end
end

module Polyfill::V2_6::String
end

module Polyfill::V2_6::Struct
  def to_h(); end
end

module Polyfill::V2_6::Struct
end

module Polyfill::V2_6
end

module Polyfill
  def self.get(module_name, methods, options=T.unsafe(nil)); end
end

module Powerpack
  VERSION = ::T.let(nil, ::T.untyped)
end

module Powerpack
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(); end

  def color=(value); end

  def command_state(); end

  def commands(); end

  def commands=(value); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(); end

  def editor=(value); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(value); end

  def hooks(); end

  def hooks=(value); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, b); end

  def inject_sticky_locals!(); end

  def input(); end

  def input=(value); end

  def input_array(); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(e); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(value); end

  def output_array(); end

  def output_ring(); end

  def pager(); end

  def pager=(value); end

  def pop_prompt(); end

  def print(); end

  def print=(value); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_WHITELIST = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end

  def opts(); end
end

class Pry::BlockCommand
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line, lineno=T.unsafe(nil)); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line, lineno=T.unsafe(nil)); end

  def raw(); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def _pry_=(_pry_); end

  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, _pry_, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, _pry_, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def text(str, width=T.unsafe(nil)); end
  OBJ_COLOR = ::T.let(nil, ::T.untyped)
end

class Pry::ColorPrinter
  def self.pp(obj, out=T.unsafe(nil), width=T.unsafe(nil), newline=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def call_safely(*args); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def dependencies_met?(); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def text(); end

  def tokenize(val); end

  def use_unpatched_symbol(); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def _pry_(); end

  def ex(); end

  def format(); end

  def initialize(exception, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def _pry_(); end

  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, _pry_); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def _pry_(); end

  def _pry_=(_pry_); end

  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(_pry_, state, exception_file_and_line); end

  def perform_patch(); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::GemCd
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemCd
end

class Pry::Command::GemInstall
  def process(gem); end
end

class Pry::Command::GemInstall
end

class Pry::Command::GemList
  def process(pattern=T.unsafe(nil)); end
end

class Pry::Command::GemList
end

class Pry::Command::GemOpen
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemOpen
end

class Pry::Command::GemReadme
  def process(name); end
end

class Pry::Command::GemReadme
end

class Pry::Command::GemSearch
  def process(str); end
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemSearch
end

class Pry::Command::GemStat
  def process(name); end
  FAIL_WHALE = ::T.let(nil, ::T.untyped)
  STAT_HOST = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STAT_PORT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemStat
end

class Pry::Command::Gist
  def clipboard_content(content); end

  def comment_expression_result_for_gist(result); end

  def gist_content(content, filename); end

  def input_content(); end
end

class Pry::Command::Gist
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::InstallCommand
  def process(name); end
end

class Pry::Command::InstallCommand
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def _pry_(); end

  def grep=(grep); end

  def initialize(_pry_); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, _pry_); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, _pry_); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, _pry_); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def _pry_(); end

  def entities_table(); end

  def initialize(opts); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  def content_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def _pry_(); end

  def changed?(); end

  def eval!(); end

  def initialize(_pry_, target, source); end

  def previous_value(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.hooks(); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def disabled_command(name_of_disabled_command, message, matcher=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def helpers(&block); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def run_command(context, match, *args); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::Config
  include ::Pry::Config::Behavior
end

module Pry::Config::Behavior
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def clear(); end

  def default(); end

  def eager_load!(); end

  def eql?(other); end

  def forget(key); end

  def initialize(default=T.unsafe(nil)); end

  def inspect(); end

  def key?(key); end

  def keys(); end

  def last_default(); end

  def merge!(other); end

  def method_missing(name, *args, &block); end

  def pretty_print(q); end

  def to_h(); end

  def to_hash(); end
  ASSIGNMENT = ::T.let(nil, ::T.untyped)
  INSPECT_REGEXP = ::T.let(nil, ::T.untyped)
  NODUP = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Behavior::Builder
  def assign(attributes, default=T.unsafe(nil)); end

  def from_hash(attributes, default=T.unsafe(nil)); end
end

module Pry::Config::Behavior::Builder
end

class Pry::Config::Behavior::ReservedKeyError
end

class Pry::Config::Behavior::ReservedKeyError
end

module Pry::Config::Behavior
  def self.included(klass); end
end

module Pry::Config::Convenience
  def config_shortcut(*names); end
  SHORTCUTS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Convenience
end

class Pry::Config::Default
  include ::Pry::Config::Behavior
  include ::Pry::Config::Memoization
  def auto_indent(); end

  def collision_warning(); end

  def color(); end

  def command_completions(); end

  def command_prefix(); end

  def commands(); end

  def completer(); end

  def control_d_handler(); end

  def correct_indent(); end

  def default_window_size(); end

  def disable_auto_reload(); end

  def editor(); end

  def exception_handler(); end

  def exception_whitelist(); end

  def exec_string(); end

  def extra_sticky_locals(); end

  def file_completions(); end

  def gist(); end

  def history(); end

  def hooks(); end

  def initialize(); end

  def input(); end

  def ls(); end

  def memory_size(); end

  def output(); end

  def output_prefix(); end

  def pager(); end

  def print(); end

  def prompt(); end

  def prompt_name(); end

  def prompt_safe_contexts(); end

  def quiet(); end

  def requires(); end

  def should_load_local_rc(); end

  def should_load_plugins(); end

  def should_load_rc(); end

  def should_load_requires(); end

  def should_trap_interrupts(); end

  def system(); end

  def windows_console_warning(); end
end

class Pry::Config::Default
  extend ::Pry::Config::Behavior::Builder
  extend ::Pry::Config::Memoization::ClassMethods
end

class Pry::Config::Lazy
  def call(); end

  def initialize(&block); end
end

class Pry::Config::Lazy
end

module Pry::Config::Memoization
  def memoized_methods(); end
  MEMOIZED_METHODS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Memoization::ClassMethods
  def def_memoized(method_table); end
end

module Pry::Config::Memoization::ClassMethods
end

module Pry::Config::Memoization
  def self.included(mod); end
end

class Pry::Config
  extend ::Pry::Config::Behavior::Builder
  def self.shortcuts(); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(_pry_); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end
end

class Pry::Editor
end

module Pry::ExtendCommandBundle
end

module Pry::ExtendCommandBundle
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def command_dependencies_met?(options); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def jruby?(); end

  def jruby_19?(); end

  def linux?(); end

  def mac_osx?(); end

  def mri?(); end

  def mri_19?(); end

  def mri_2?(); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end

  def windows?(); end

  def windows_ansi?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::CommandHelpers
  def self.absolute_index_number(line_number, array_length); end

  def self.absolute_index_range(range_or_number, array_length); end

  def self.command_error(message, omit_help, klass=T.unsafe(nil)); end

  def self.get_method_or_raise(name, target, opts=T.unsafe(nil), omit_help=T.unsafe(nil)); end

  def self.internal_binding?(target); end

  def self.one_index_number(line_number); end

  def self.one_index_range(range); end

  def self.one_index_range_or_number(range_or_number); end

  def self.restrict_to_lines(content, lines); end

  def self.set_file_and_dir_locals(file_name, _pry_=T.unsafe(nil), target=T.unsafe(nil)); end

  def self.temp_file(ext=T.unsafe(nil)); end

  def self.unindent(text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::DocumentationHelpers
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(n); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, config=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, config=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, config=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, config=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def clearer(); end

  def clearer=(clearer); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def pusher(); end

  def pusher=(pusher); end

  def restore_default_behavior(); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputLock
  def __with_ownership(&block); end

  def enter_interruptible_region(); end

  def interruptible_region(&block); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(e); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(obj); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def pry_method?(); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def method_missing(meth_name, *args, &block); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def get_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, b); end

  def self.weird_method?(method, b); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_common(obj, _method_type=T.unsafe(nil), include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(b); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def _pry_(); end

  def decolorize_maybe(str); end

  def initialize(_pry_); end

  def method_missing(name, *args, &block); end

  def print(*objs); end

  def puts(*objs); end

  def tty?(); end

  def write(*objs); end
end

class Pry::Output
end

class Pry::Pager
  def _pry_(); end

  def initialize(_pry_); end

  def open(); end

  def page(text); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end

  def method_missing(*_args); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  def self.[](prompt_name); end

  def self.add(prompt_name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

module Pry::Rubygem
end

module Pry::Rubygem
  def self.complete(so_far); end

  def self.install(name); end

  def self.installed?(name); end

  def self.list(pattern=T.unsafe(nil)); end

  def self.spec(name); end
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::Terminal
end

class Pry::Terminal
  def self.actual_screen_size(); end

  def self.height!(); end

  def self.screen_size(); end

  def self.screen_size_according_to_ansicon_env(); end

  def self.screen_size_according_to_env(); end

  def self.screen_size_according_to_io_console(); end

  def self.screen_size_according_to_readline(); end

  def self.size!(default=T.unsafe(nil)); end

  def self.width!(); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Config::Convenience
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(); end

  def self.color=(value); end

  def self.commands(); end

  def self.commands=(value); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.default_editor_for_platform(); end

  def self.editor(); end

  def self.editor=(value); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(); end

  def self.exception_handler=(value); end

  def self.extra_sticky_locals(); end

  def self.extra_sticky_locals=(value); end

  def self.final_session_setup(); end

  def self.history(); end

  def self.history=(history); end

  def self.hooks(); end

  def self.hooks=(value); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(); end

  def self.input=(value); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.lazy(&block); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(); end

  def self.memory_size=(value); end

  def self.output(); end

  def self.output=(value); end

  def self.pager(); end

  def self.pager=(value); end

  def self.plugins(*args, &block); end

  def self.print(); end

  def self.print=(value); end

  def self.prompt(); end

  def self.prompt=(value); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, *original_arguments); end

  def self.load_file(file, options=T.unsafe(nil)); end

  def self.load_file_with_options(file, options=T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.load_with_options(yaml, *original_arguments); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(*args); end

  def self.safe_load_file(*args); end

  def self.to_json(object); end

  def self.unsafe_load(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.unsafe_load_file(filename); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Pubsubstub
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pubsubstub::Application
  def call(env); end

  def initialize(*_); end
end

class Pubsubstub::Application
  def self.call(env); end
end

class Pubsubstub::Channel
  def initialize(name); end

  def name(); end

  def publish(event); end

  def pubsub_key(); end

  def redis(); end

  def scrollback(since:); end

  def scrollback_key(); end
end

class Pubsubstub::Channel
  def self.name_from_pubsub_key(key); end
end

class Pubsubstub::Event
  def ==(other); end

  def data(); end

  def id(); end

  def initialize(data, options=T.unsafe(nil)); end

  def name(); end

  def retry_after(); end

  def to_json(); end

  def to_message(); end
end

class Pubsubstub::Event
  def self.from_json(json); end
end

module Pubsubstub::Logging
  def debug(); end

  def error(); end

  def info(); end
end

module Pubsubstub::Logging
end

class Pubsubstub::PublishAction
  def call(env); end

  def initialize(*_); end
end

class Pubsubstub::PublishAction
end

module Pubsubstub::RedisPubSub
  def publish(channel_name, event); end
end

module Pubsubstub::RedisPubSub
  extend ::Pubsubstub::RedisPubSub
end

class Pubsubstub::StreamAction
  include ::Pubsubstub::Logging
  def call(env); end

  def initialize(*_); end
  HEADERS = ::T.let(nil, ::T.untyped)
end

class Pubsubstub::StreamAction
end

class Pubsubstub::Subscriber
  include ::Pubsubstub::Logging
  include ::Mutex_m
  def add_event_listener(channel_key, callback); end

  def initialize(); end

  def lock(); end

  def locked?(); end

  def remove_event_listener(channel_key, callback); end

  def start(); end

  def stop(); end

  def subscribed?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Pubsubstub::Subscriber
end

class Pubsubstub::Subscription
  include ::Pubsubstub::Logging
  def channels(); end

  def connection(); end

  def id(); end

  def initialize(channels, connection); end

  def push(event); end

  def queue(); end

  def stream(last_event_id); end
end

class Pubsubstub::Subscription
end

module Pubsubstub
  extend ::Mutex_m
  def self.channels_scrollback_size(); end

  def self.channels_scrollback_size=(channels_scrollback_size); end

  def self.channels_scrollback_ttl(); end

  def self.channels_scrollback_ttl=(channels_scrollback_ttl); end

  def self.error_handler(); end

  def self.error_handler=(error_handler); end

  def self.handle_error(error); end

  def self.heartbeat_event(); end

  def self.heartbeat_frequency(); end

  def self.heartbeat_frequency=(heartbeat_frequency); end

  def self.lock(); end

  def self.locked?(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.new_redis(); end

  def self.publish(channel_name, *args); end

  def self.reconnect_timeout(); end

  def self.reconnect_timeout=(reconnect_timeout); end

  def self.redis(); end

  def self.redis_url(); end

  def self.redis_url=(url); end

  def self.report_errors(); end

  def self.subscriber(); end

  def self.synchronize(&block); end

  def self.try_lock(); end

  def self.unlock(); end

  def self.use_persistent_connections(); end

  def self.use_persistent_connections=(use_persistent_connections); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Light
end

class REXML::Light::Node
  def <<(element); end

  def =~(path); end

  def [](reference, ns=T.unsafe(nil)); end

  def []=(reference, ns, value=T.unsafe(nil)); end

  def children(); end

  def each(&blk); end

  def has_name?(name, namespace=T.unsafe(nil)); end

  def initialize(node=T.unsafe(nil)); end

  def local_name(); end

  def local_name=(name_str); end

  def name(); end

  def name=(name_str, ns=T.unsafe(nil)); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespace=(namespace); end

  def node_type(); end

  def parent(); end

  def parent=(node); end

  def prefix(namespace=T.unsafe(nil)); end

  def root(); end

  def size(); end

  def text=(foo); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
  PARENTS = ::T.let(nil, ::T.untyped)
end

class REXML::Light::Node
end

module REXML::Light
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  MISSING_ATTRIBUTE_QUOTES = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  NCNAMETEST = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(&blk); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  ALL = ::T.let(nil, ::T.untyped)
  ELEMENTS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

class REXMLUtilityNode
  def add_node(node); end

  def attributes(); end

  def attributes=(attributes); end

  def children(); end

  def children=(children); end

  def initialize(name, normalized_attributes=T.unsafe(nil)); end

  def inner_html(); end

  def name(); end

  def name=(name); end

  def to_hash(); end

  def to_html(); end

  def type(); end

  def type=(type); end

  def typecast_value(value); end

  def undasherize_keys(params); end
end

class REXMLUtilityNode
  def self.available_typecasts(); end

  def self.available_typecasts=(obj); end

  def self.typecasts(); end

  def self.typecasts=(obj); end
end

class REXMLUtiliyNodeString
  def attributes(); end

  def attributes=(attributes); end
end

class REXMLUtiliyNodeString
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*_); end
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_h(); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(content, content_type=T.unsafe(nil), binary=T.unsafe(nil), original_filename: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
  def self.actually_finalize(file); end

  def self.finalize(file); end
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
  def self.build_file_part(parameter_name, uploaded_file); end

  def self.build_multipart(params, first=T.unsafe(nil), multipart=T.unsafe(nil)); end

  def self.build_parts(parameters); end

  def self.build_primitive_part(parameter_name, value); end

  def self.get_parts(parameters); end
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.[](headers); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rails::Application
  def asset_precompiled?(logical_path); end

  def assets(); end

  def assets=(assets); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def build_middleware_stack(); end

  def config=(config); end

  def config_for(name, env: T.unsafe(nil)); end

  def console(&blk); end

  def credentials(); end

  def default_url_options(*args, &block); end

  def default_url_options=(arg); end

  def encrypted(path, key_path: T.unsafe(nil), env_key: T.unsafe(nil)); end

  def executor(); end

  def generators(&blk); end

  def initialize(initial_variable_values=T.unsafe(nil), &block); end

  def initialize!(group=T.unsafe(nil)); end

  def initialized?(); end

  def initializer(name, opts=T.unsafe(nil), &block); end

  def isolate_namespace(mod); end

  def key_generator(); end

  def message_verifier(verifier_name); end

  def migration_railties(); end

  def ordered_railties(); end

  def precompiled_assets(clear_cache=T.unsafe(nil)); end

  def railties_initializers(current); end

  def rake_tasks(&block); end

  def reload_routes!(); end

  def reloader(); end

  def reloaders(); end

  def require_environment!(); end

  def routes_reloader(); end

  def run_load_hooks!(); end

  def run_tasks_blocks(app); end

  def runner(&blk); end

  def sandbox(); end

  def sandbox=(sandbox); end

  def sandbox?(); end

  def secret_key_base(); end

  def secrets(); end

  def secrets=(secrets); end

  def to_app(); end

  def validate_secret_key_base(secret_key_base); end

  def watchable_args(); end
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

module Rails::Application::Bootstrap
  include ::Rails::Initializable
end

module Rails::Application::Bootstrap
end

class Rails::Application::Configuration
  def add_autoload_paths_to_load_path(); end

  def add_autoload_paths_to_load_path=(add_autoload_paths_to_load_path); end

  def allow_concurrency(); end

  def allow_concurrency=(allow_concurrency); end

  def annotations(); end

  def api_only(); end

  def api_only=(value); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def autoflush_log(); end

  def autoflush_log=(autoflush_log); end

  def autoloader(); end

  def autoloader=(autoloader); end

  def beginning_of_week(); end

  def beginning_of_week=(beginning_of_week); end

  def cache_classes(); end

  def cache_classes=(cache_classes); end

  def cache_store(); end

  def cache_store=(cache_store); end

  def colorize_logging(); end

  def colorize_logging=(val); end

  def consider_all_requests_local(); end

  def consider_all_requests_local=(consider_all_requests_local); end

  def console(); end

  def console=(console); end

  def content_security_policy(&block); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(content_security_policy_nonce_directives); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(content_security_policy_nonce_generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(content_security_policy_report_only); end

  def credentials(); end

  def credentials=(credentials); end

  def database_configuration(); end

  def debug_exception_response_format(); end

  def debug_exception_response_format=(debug_exception_response_format); end

  def default_log_file(); end

  def disable_sandbox(); end

  def disable_sandbox=(disable_sandbox); end

  def eager_load(); end

  def eager_load=(eager_load); end

  def enable_dependency_loading(); end

  def enable_dependency_loading=(enable_dependency_loading); end

  def encoding(); end

  def encoding=(value); end

  def exceptions_app(); end

  def exceptions_app=(exceptions_app); end

  def file_watcher(); end

  def file_watcher=(file_watcher); end

  def filter_parameters(); end

  def filter_parameters=(filter_parameters); end

  def filter_redirect(); end

  def filter_redirect=(filter_redirect); end

  def force_ssl(); end

  def force_ssl=(force_ssl); end

  def helpers_paths(); end

  def helpers_paths=(helpers_paths); end

  def hosts(); end

  def hosts=(hosts); end

  def initialize(*_); end

  def load_database_yaml(); end

  def load_defaults(target_version); end

  def loaded_config_version(); end

  def log_formatter(); end

  def log_formatter=(log_formatter); end

  def log_level(); end

  def log_level=(log_level); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def public_file_server(); end

  def public_file_server=(public_file_server); end

  def railties_order(); end

  def railties_order=(railties_order); end

  def read_encrypted_secrets(); end

  def read_encrypted_secrets=(read_encrypted_secrets); end

  def relative_url_root(); end

  def relative_url_root=(relative_url_root); end

  def reload_classes_only_on_change(); end

  def reload_classes_only_on_change=(reload_classes_only_on_change); end

  def require_master_key(); end

  def require_master_key=(require_master_key); end

  def secret_key_base(); end

  def secret_key_base=(secret_key_base); end

  def session_options(); end

  def session_options=(session_options); end

  def session_store(new_session_store=T.unsafe(nil), **options); end

  def session_store?(); end

  def ssl_options(); end

  def ssl_options=(ssl_options); end

  def time_zone(); end

  def time_zone=(time_zone); end

  def x(); end

  def x=(x); end
end

class Rails::Application::Configuration::Custom
  def method_missing(method, *args); end
end

class Rails::Application::Configuration::Custom
end

class Rails::Application::Configuration
end

class Rails::Application::DefaultMiddlewareStack
  def app(); end

  def build_stack(); end

  def config(); end

  def initialize(app, config, paths); end

  def paths(); end
end

class Rails::Application::DefaultMiddlewareStack
end

module Rails::Application::Finisher
  include ::Rails::Initializable
end

module Rails::Application::Finisher::InterlockHook
end

module Rails::Application::Finisher::InterlockHook
  def self.complete(_state); end

  def self.run(); end
end

class Rails::Application::Finisher::MutexHook
  def complete(_state); end

  def initialize(mutex=T.unsafe(nil)); end

  def run(); end
end

class Rails::Application::Finisher::MutexHook
end

module Rails::Application::Finisher
end

class Rails::Application::NonSymbolAccessDeprecatedHash
  def initialize(value=T.unsafe(nil)); end
end

class Rails::Application::NonSymbolAccessDeprecatedHash
end

class Rails::Application::RoutesReloader
  def eager_load(); end

  def eager_load=(eager_load); end

  def execute(*args, &block); end

  def execute_if_updated(*args, &block); end

  def paths(); end

  def reload!(); end

  def route_sets(); end

  def updated?(*args, &block); end
end

class Rails::Application::RoutesReloader
end

class Rails::Application
  def self.add_lib_to_load_path!(root); end

  def self.create(initial_variable_values=T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Autoloaders
end

module Rails::Autoloaders
  extend ::Enumerable
  def self.each(&blk); end

  def self.log!(); end

  def self.logger=(logger); end

  def self.main(); end

  def self.once(); end

  def self.zeitwerk_enabled?(); end
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Rails::BacktraceCleaner
end

module Rails::Command
  include ::Rails::Command::Behavior
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Behavior
end

module Rails::Command::Behavior::ClassMethods
  def no_color!(); end

  def subclasses(); end
end

module Rails::Command::Behavior::ClassMethods
end

module Rails::Command::Behavior
  extend ::ActiveSupport::Concern
end

module Rails::Command::Spellchecker
end

module Rails::Command::Spellchecker
  def self.suggest(word, from:); end
end

module Rails::Command
  extend ::ActiveSupport::Autoload
  extend ::Rails::Command::Behavior::ClassMethods
  def self.environment(); end

  def self.find_by_namespace(namespace, command_name=T.unsafe(nil)); end

  def self.hidden_commands(); end

  def self.invoke(full_namespace, args=T.unsafe(nil), **config); end

  def self.print_commands(); end

  def self.root(); end
end

module Rails::Conductor
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::BaseController
end

class Rails::Conductor::BaseController
end

module Rails::Conductor
end

module Rails::Configuration
end

class Rails::Configuration::Generators
  def aliases(); end

  def aliases=(aliases); end

  def api_only(); end

  def api_only=(api_only); end

  def colorize_logging(); end

  def colorize_logging=(colorize_logging); end

  def fallbacks(); end

  def fallbacks=(fallbacks); end

  def hidden_namespaces(); end

  def hide_namespace(namespace); end

  def method_missing(method, *args); end

  def options(); end

  def options=(options); end

  def templates(); end

  def templates=(templates); end
end

class Rails::Configuration::Generators
end

class Rails::Configuration::MiddlewareStackProxy
  def +(other); end

  def delete(*args, &block); end

  def delete_operations(); end

  def initialize(operations=T.unsafe(nil), delete_operations=T.unsafe(nil)); end

  def insert(*args, &block); end

  def insert_after(*args, &block); end

  def insert_before(*args, &block); end

  def merge_into(other); end

  def operations(); end

  def swap(*args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class Rails::Configuration::MiddlewareStackProxy
end

module Rails::Configuration
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing
end

module Rails::Dom
end

class Rails::Engine
  def app(); end

  def call(env); end

  def eager_load!(); end

  def endpoint(); end

  def engine_name(*args, &block); end

  def env_config(); end

  def helpers(); end

  def helpers_paths(); end

  def isolated?(*args, &block); end

  def load_console(app=T.unsafe(nil)); end

  def load_generators(app=T.unsafe(nil)); end

  def load_runner(app=T.unsafe(nil)); end

  def load_seed(); end

  def load_tasks(app=T.unsafe(nil)); end

  def middleware(*args, &block); end

  def paths(*args, &block); end

  def railties(); end

  def root(*args, &block); end

  def routes(&block); end

  def routes?(); end

  def run_tasks_blocks(*_); end
end

class Rails::Engine::Configuration
  def autoload_once_paths(); end

  def autoload_once_paths=(autoload_once_paths); end

  def autoload_paths(); end

  def autoload_paths=(autoload_paths); end

  def eager_load_paths(); end

  def eager_load_paths=(eager_load_paths); end

  def generators(); end

  def initialize(root=T.unsafe(nil)); end

  def javascript_path(); end

  def javascript_path=(javascript_path); end

  def middleware(); end

  def middleware=(middleware); end

  def paths(); end

  def root(); end

  def root=(value); end
end

class Rails::Engine::Configuration
end

class Rails::Engine
  def self.called_from(); end

  def self.called_from=(called_from); end

  def self.eager_load!(*args, &block); end

  def self.endpoint(endpoint=T.unsafe(nil)); end

  def self.engine_name(name=T.unsafe(nil)); end

  def self.find(path); end

  def self.find_root(from); end

  def self.find_root_with_flag(flag, root_path, default=T.unsafe(nil)); end

  def self.isolate_namespace(mod); end

  def self.isolated(); end

  def self.isolated=(isolated); end

  def self.isolated?(); end
end

module Rails::Generators
  include ::Rails::Command::Behavior
  def namespace(); end

  def namespace=(obj); end
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def github(repo, options=T.unsafe(nil), &block); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

module Rails::Generators::AppName
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::AppName
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Database
  def convert_database_option_for_jruby(); end

  def gem_for_database(database=T.unsafe(nil)); end

  def initialize(*_); end
  DATABASES = ::T.let(nil, ::T.untyped)
  JDBC_DATABASES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Database
end

class Rails::Generators::Error
end

class Rails::Generators::Error
end

class Rails::Generators::GeneratedAttribute
  def attachment?(); end

  def attachments?(); end

  def attr_options(); end

  def column_name(); end

  def default(); end

  def field_type(); end

  def foreign_key?(); end

  def has_index?(); end

  def has_uniq_index?(); end

  def human_name(); end

  def index_name(); end

  def index_name=(index_name); end

  def initialize(name, type=T.unsafe(nil), index_type=T.unsafe(nil), attr_options=T.unsafe(nil)); end

  def inject_index_options(); end

  def inject_options(); end

  def name(); end

  def name=(name); end

  def options_for_migration(); end

  def password_digest?(); end

  def plural_name(); end

  def polymorphic?(); end

  def reference?(); end

  def required?(); end

  def rich_text?(); end

  def singular_name(); end

  def token?(); end

  def type(); end

  def type=(type); end

  def virtual?(); end
  INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
  UNIQ_INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rails::Generators::GeneratedAttribute
  def self.parse(column_definition); end

  def self.reference?(type); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  include ::Coffee::Rails::JsHook
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  include ::Rails::Generators::Testing::SetupAndTeardown
  include ::Rails::Generators::Testing::Assertions
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def current_path(); end

  def current_path=(val); end

  def current_path?(); end

  def default_arguments(); end

  def default_arguments=(val); end

  def default_arguments?(); end

  def destination_root(); end

  def destination_root=(val); end

  def destination_root?(); end

  def generator_class(); end

  def generator_class=(val); end

  def generator_class?(); end
end

class Rails::Generators::TestCase
  def self.current_path(); end

  def self.current_path=(val); end

  def self.current_path?(); end

  def self.default_arguments(); end

  def self.default_arguments=(val); end

  def self.default_arguments?(); end

  def self.destination_root(); end

  def self.destination_root=(val); end

  def self.destination_root?(); end

  def self.generator_class(); end

  def self.generator_class=(val); end

  def self.generator_class?(); end
end

module Rails::Generators::Testing
end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end

  def assert_directory(relative, *contents); end

  def assert_field_default_value(attribute_type, value); end

  def assert_field_type(attribute_type, field_type); end

  def assert_file(relative, *contents); end

  def assert_instance_method(method, content); end

  def assert_method(method, content); end

  def assert_migration(relative, *contents, &block); end

  def assert_no_directory(relative); end

  def assert_no_file(relative); end

  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Assertions
end

module Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  def create_generated_attribute(attribute_type, name=T.unsafe(nil), index=T.unsafe(nil)); end

  def generator(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def run_generator(args=T.unsafe(nil), config=T.unsafe(nil)); end
end

module Rails::Generators::Testing::Behaviour
  extend ::ActiveSupport::Concern
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup(); end

  def teardown(); end
end

module Rails::Generators::Testing::SetupAndTeardown
end

module Rails::Generators::Testing
end

module Rails::Generators
  extend ::Rails::Command::Behavior::ClassMethods
  def self.aliases(); end

  def self.api_only!(); end

  def self.configure!(config); end

  def self.fallbacks(); end

  def self.find_by_namespace(name, base=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.help(command=T.unsafe(nil)); end

  def self.hidden_namespaces(); end

  def self.hide_namespace(*namespaces); end

  def self.hide_namespaces(*namespaces); end

  def self.invoke(namespace, args=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.namespace(); end

  def self.namespace=(obj); end

  def self.options(); end

  def self.print_generators(); end

  def self.public_namespaces(); end

  def self.sorted_groups(); end

  def self.templates_path(); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Html
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  def initializers(); end

  def run_initializers(group=T.unsafe(nil), *args); end
end

module Rails::Initializable
  def self.included(base); end
end

module Rails::LineFiltering
  def run(reporter, options=T.unsafe(nil)); end
end

module Rails::LineFiltering
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

module Rails::Paths
end

class Rails::Paths::Path
  include ::Enumerable
  def <<(path); end

  def absolute_current(); end

  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def children(); end

  def concat(paths); end

  def each(&block); end

  def eager_load!(); end

  def eager_load?(); end

  def existent(); end

  def existent_directories(); end

  def expanded(); end

  def extensions(); end

  def first(); end

  def glob(); end

  def glob=(glob); end

  def initialize(root, current, paths, options=T.unsafe(nil)); end

  def last(); end

  def load_path!(); end

  def load_path?(); end

  def push(path); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end

  def to_a(); end

  def to_ary(); end

  def unshift(*paths); end
end

class Rails::Paths::Path
end

class Rails::Paths::Root
  def [](path); end

  def []=(path, value); end

  def add(path, options=T.unsafe(nil)); end

  def all_paths(); end

  def autoload_once(); end

  def autoload_paths(); end

  def eager_load(); end

  def initialize(path); end

  def keys(); end

  def load_paths(); end

  def path(); end

  def path=(path); end

  def values(); end

  def values_at(*list); end
end

class Rails::Paths::Root
end

module Rails::Paths
end

module Rails::Rack
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Rack::Logger
end

module Rails::Rack
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie::Configuration
  def after_initialize(&block); end

  def app_generators(); end

  def app_middleware(); end

  def before_configuration(&block); end

  def before_eager_load(&block); end

  def before_initialize(&block); end

  def eager_load_namespaces(); end

  def respond_to?(name, include_private=T.unsafe(nil)); end

  def to_prepare(&blk); end

  def to_prepare_blocks(); end

  def watchable_dirs(); end

  def watchable_files(); end
end

class Rails::Railtie::Configuration
  def self.eager_load_namespaces(); end
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.runner(&blk); end
end

class Rails::Secrets
end

class Rails::Secrets::MissingKeyError
  def initialize(); end
end

class Rails::Secrets::MissingKeyError
end

class Rails::Secrets
  def self.decrypt(data); end

  def self.encrypt(data); end

  def self.key(); end

  def self.parse(paths, env:); end

  def self.read(); end

  def self.read_for_editing(&block); end

  def self.root=(root); end

  def self.write(contents); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.notes_task_deprecation_warning(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnit::CompositeFilter
  def ===(method); end

  def initialize(runnable, filter, patterns); end

  def named_filter(); end
end

class Rails::TestUnit::CompositeFilter
end

class Rails::TestUnit::Filter
  def ===(method); end

  def initialize(runnable, file, line); end
end

class Rails::TestUnit::Filter
end

class Rails::TestUnit::Runner
  def filters(); end
end

class Rails::TestUnit::Runner
  def self.attach_before_load_options(opts); end

  def self.compose_filter(runnable, filter); end

  def self.filters(); end

  def self.load_tests(argv); end

  def self.parse_options(argv); end

  def self.rake_run(argv=T.unsafe(nil)); end

  def self.run(argv=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnitRailtie
end

class Rails::TestUnitRailtie
end

module Rails::Timeago
end

class Rails::Timeago::Engine
end

class Rails::Timeago::Engine
end

module Rails::Timeago::Helper
  def timeago_script_tag(); end

  def timeago_tag(time, html_options=T.unsafe(nil)); end

  def timeago_tag_content(time, time_options=T.unsafe(nil)); end
end

module Rails::Timeago::Helper
end

module Rails::Timeago::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STAGE = ::T.let(nil, ::T.untyped)
end

module Rails::Timeago::VERSION
end

module Rails::Timeago
  def self.default_options(opts=T.unsafe(nil)); end

  def self.option_hash(); end

  def self.reset_default_options(); end
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::ActiveSupport::Autoload
  def self.app_class(); end

  def self.app_class=(app_class); end

  def self.application=(application); end

  def self.autoloaders(); end

  def self.backtrace_cleaner(); end

  def self.cache(); end

  def self.cache=(cache); end

  def self.configuration(); end

  def self.env(); end

  def self.env=(environment); end

  def self.gem_version(); end

  def self.groups(*groups); end

  def self.initialize!(*args, &block); end

  def self.initialized?(*args, &block); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.public_path(); end

  def self.version(); end
end

module RailsAutolink
end

class RailsAutolink::Railtie
end

class RailsAutolink::Railtie
end

module RailsAutolink
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def average(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def butfirst(*args, &block); end

  def butlast(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_last(*args, &block); end

  def drop_last_while(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exactly?(*args, &block); end

  def exclude(*patterns, &block); end

  def exclude?(*args, &block); end

  def excluded_from_list?(fn); end

  def excluding(*args, &block); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def frequencies(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def several?(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_last(*args, &block); end

  def take_last_while(*args, &block); end

  def take_while(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def overlaps?(other); end

  def sum(identity=T.unsafe(nil)); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Redis
  include ::MonitorMixin
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def _bpop(cmd, args, &blk); end

  def _client(); end

  def _eval(cmd, args); end

  def _scan(command, cursor, args, options=T.unsafe(nil), &block); end

  def append(key, value); end

  def asking(); end

  def auth(password); end

  def bgrewriteaof(); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, options=T.unsafe(nil)); end

  def bzpopmax(*args); end

  def bzpopmin(*args); end

  def call(*command); end

  def client(subcommand=T.unsafe(nil), *args); end

  def close(); end

  def cluster(subcommand, *args); end

  def commit(); end

  def config(action, *args); end

  def connected?(); end

  def connection(); end

  def dbsize(); end

  def debug(*args); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*keys); end

  def discard(); end

  def disconnect!(); end

  def dump(key); end

  def echo(value); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(key); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(options=T.unsafe(nil)); end

  def flushdb(options=T.unsafe(nil)); end

  def geoadd(key, *member); end

  def geodist(key, member1, member2, unit=T.unsafe(nil)); end

  def geohash(key, member); end

  def geopos(key, member); end

  def georadius(*args, **geoptions); end

  def georadiusbymember(*args, **geoptions); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields, &blk); end

  def hmset(key, *attrs); end

  def hscan(key, cursor, options=T.unsafe(nil)); end

  def hscan_each(key, options=T.unsafe(nil), &block); end

  def hset(key, field, value); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def id(); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def keys(pattern=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def method_missing(command, *args); end

  def mget(*keys, &blk); end

  def migrate(key, options); end

  def monitor(&block); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def object(*args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(message=T.unsafe(nil)); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def pubsub(subcommand, *args); end

  def punsubscribe(*channels); end

  def queue(*command); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, options=T.unsafe(nil)); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scan(cursor, options=T.unsafe(nil)); end

  def scan_each(options=T.unsafe(nil), &block); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def sentinel(subcommand, *args); end

  def set(key, value, options=T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def shutdown(); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def slaveof(host, port); end

  def slowlog(subcommand, length=T.unsafe(nil)); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, options=T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, options=T.unsafe(nil)); end

  def sscan_each(key, options=T.unsafe(nil), &block); end

  def strlen(key); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def sync(); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*keys); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def with_reconnect(val=T.unsafe(nil), &blk); end

  def without_reconnect(&blk); end

  def xack(key, group, *ids); end

  def xadd(key, entry, opts=T.unsafe(nil)); end

  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  def xdel(key, *ids); end

  def xgroup(subcommand, key, group, id_or_consumer=T.unsafe(nil), mkstream: T.unsafe(nil)); end

  def xinfo(subcommand, key, group=T.unsafe(nil)); end

  def xlen(key); end

  def xpending(key, group, *args); end

  def xrange(key, start=T.unsafe(nil), _end=T.unsafe(nil), count: T.unsafe(nil)); end

  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  def xreadgroup(group, consumer, keys, ids, opts=T.unsafe(nil)); end

  def xrevrange(key, _end=T.unsafe(nil), start=T.unsafe(nil), count: T.unsafe(nil)); end

  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, options=T.unsafe(nil)); end

  def zlexcount(key, min, max); end

  def zpopmax(key, count=T.unsafe(nil)); end

  def zpopmin(key, count=T.unsafe(nil)); end

  def zrange(key, start, stop, options=T.unsafe(nil)); end

  def zrangebylex(key, min, max, options=T.unsafe(nil)); end

  def zrangebyscore(key, min, max, options=T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, options=T.unsafe(nil)); end

  def zrevrangebylex(key, max, min, options=T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, options=T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscan(key, cursor, options=T.unsafe(nil)); end

  def zscan_each(key, options=T.unsafe(nil), &block); end

  def zscore(key, member); end

  def zunionstore(destination, keys, options=T.unsafe(nil)); end
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  HashifyClusterNodeInfo = ::T.let(nil, ::T.untyped)
  HashifyClusterNodes = ::T.let(nil, ::T.untyped)
  HashifyClusterSlaves = ::T.let(nil, ::T.untyped)
  HashifyClusterSlots = ::T.let(nil, ::T.untyped)
  HashifyInfo = ::T.let(nil, ::T.untyped)
  HashifyStreamEntries = ::T.let(nil, ::T.untyped)
  HashifyStreamPendingDetails = ::T.let(nil, ::T.untyped)
  HashifyStreamPendings = ::T.let(nil, ::T.untyped)
  HashifyStreams = ::T.let(nil, ::T.untyped)
  Noop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::BaseConnectionError
end

class Redis::BaseConnectionError
end

class Redis::BaseError
end

class Redis::BaseError
end

class Redis::BaseObject
  def <(what); end

  def <=(what); end

  def ==(what); end

  def >(what); end

  def >=(what); end

  def allow_expiration(&block); end

  def as_json(*_); end

  def initialize(key, *args); end

  def redis(); end

  def set_expiration(); end

  def to_hash(); end

  def to_json(*args); end
end

class Redis::BaseObject
end

class Redis::CannotConnectError
end

class Redis::CannotConnectError
end

class Redis::Client
  def _parse_driver(driver); end

  def _parse_options(options); end

  def call(command); end

  def call_loop(command, timeout=T.unsafe(nil)); end

  def call_pipeline(pipeline); end

  def call_pipelined(pipeline); end

  def call_with_timeout(command, timeout, &blk); end

  def call_without_timeout(command, &blk); end

  def command_map(); end

  def connect(); end

  def connect_timeout(); end

  def connected?(); end

  def connection(); end

  def db(); end

  def db=(db); end

  def disconnect(); end

  def driver(); end

  def ensure_connected(); end

  def establish_connection(); end

  def host(); end

  def id(); end

  def inherit_socket?(); end

  def initialize(options=T.unsafe(nil)); end

  def io(); end

  def location(); end

  def logger(); end

  def logger=(logger); end

  def logging(commands); end

  def options(); end

  def password(); end

  def path(); end

  def port(); end

  def process(commands); end

  def read(); end

  def read_timeout(); end

  def reconnect(); end

  def scheme(); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_socket_timeout(timeout); end

  def without_reconnect(&blk); end

  def without_socket_timeout(&blk); end

  def write(command); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Redis::Client::Connector
  def check(client); end

  def initialize(options); end

  def resolve(); end
end

class Redis::Client::Connector::Sentinel
  def resolve_master(); end

  def resolve_slave(); end

  def sentinel_detect(); end
end

class Redis::Client::Connector::Sentinel
end

class Redis::Client::Connector
end

class Redis::Client
end

class Redis::Cluster
  def call(command, &block); end

  def call_loop(command, timeout=T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def call_without_timeout(command, &block); end

  def connected?(); end

  def connection_info(); end

  def db(); end

  def db=(_db); end

  def disconnect(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def process(commands, &block); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil), &block); end
end

class Redis::Cluster::AmbiguousNodeError
  def initialize(command); end
end

class Redis::Cluster::AmbiguousNodeError
end

class Redis::Cluster::Command
  def extract_first_key(command); end

  def initialize(details); end

  def should_send_to_master?(command); end

  def should_send_to_slave?(command); end
end

class Redis::Cluster::Command
end

class Redis::Cluster::CommandErrorCollection
  def errors(); end

  def initialize(errors, error_message=T.unsafe(nil)); end
end

class Redis::Cluster::CommandErrorCollection
end

module Redis::Cluster::CommandLoader
end

module Redis::Cluster::CommandLoader
  def self.load(nodes); end
end

class Redis::Cluster::CrossSlotPipeliningError
  def initialize(keys); end
end

class Redis::Cluster::CrossSlotPipeliningError
end

module Redis::Cluster::KeySlotConverter
  HASH_SLOTS = ::T.let(nil, ::T.untyped)
  XMODEM_CRC16_LOOKUP = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::KeySlotConverter
  def self.convert(key); end
end

class Redis::Cluster::Node
  include ::Enumerable
  def call_all(command, &block); end

  def call_master(command, &block); end

  def call_slave(command, &block); end

  def each(&block); end

  def find_by(node_key); end

  def initialize(options, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def process_all(commands, &block); end

  def sample(); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node::ReloadNeeded
end

class Redis::Cluster::Node
end

module Redis::Cluster::NodeKey
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
end

module Redis::Cluster::NodeKey
  def self.build_from_host_port(host, port); end

  def self.build_from_uri(uri); end

  def self.split(node_key); end

  def self.to_node_urls(node_keys, secure:); end
end

module Redis::Cluster::NodeLoader
end

module Redis::Cluster::NodeLoader
  def self.load_flags(nodes); end
end

class Redis::Cluster::Option
  def add_node(host, port); end

  def initialize(options); end

  def per_node_key(); end

  def secure?(); end

  def update_node(addrs); end

  def use_replica?(); end
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  SECURE_SCHEME = ::T.let(nil, ::T.untyped)
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Option
end

class Redis::Cluster::OrchestrationCommandNotSupported
  def initialize(command, subcommand=T.unsafe(nil)); end
end

class Redis::Cluster::OrchestrationCommandNotSupported
end

class Redis::Cluster::Slot
  def exists?(slot); end

  def find_node_key_of_master(slot); end

  def find_node_key_of_slave(slot); end

  def initialize(available_slots, node_flags=T.unsafe(nil), with_replica=T.unsafe(nil)); end

  def put(slot, node_key); end
  ROLE_SLAVE = ::T.let(nil, ::T.untyped)
end

class Redis::Cluster::Slot
end

module Redis::Cluster::SlotLoader
end

module Redis::Cluster::SlotLoader
  def self.load(nodes); end
end

class Redis::Cluster
end

class Redis::CommandError
end

class Redis::CommandError
end

module Redis::Connection
end

module Redis::Connection::CommandHelper
  def build_command(args); end

  def encode(string); end
  COMMAND_DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::CommandHelper
end

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper
  def connected?(); end

  def disconnect(); end

  def format_bulk_reply(line); end

  def format_error_reply(line); end

  def format_integer_reply(line); end

  def format_multi_bulk_reply(line); end

  def format_reply(reply_type, line); end

  def format_status_reply(line); end

  def get_tcp_keepalive(); end

  def initialize(sock); end

  def read(); end

  def set_tcp_keepalive(keepalive); end

  def set_tcp_nodelay(); end

  def timeout=(timeout); end

  def write(command); end

  def write_timeout=(timeout); end
  ASTERISK = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
  MINUS = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
end

class Redis::Connection::Ruby
  def self.connect(config); end
end

class Redis::Connection::SSLSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::SSLSocket
  def self.connect(host, port, timeout, ssl_params); end
end

module Redis::Connection::SocketMixin
  def _read_from_socket(nbytes); end

  def _write_to_socket(data); end

  def gets(); end

  def initialize(*args); end

  def read(nbytes); end

  def timeout=(timeout); end

  def write(data); end

  def write_timeout=(timeout); end
  CRLF = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  def self.connect(host, port, timeout); end

  def self.connect_addrinfo(ai, port, timeout); end
end

class Redis::Connection::UNIXSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::UNIXSocket
  def self.connect(path, timeout); end
end

module Redis::Connection
  def self.drivers(); end
end

class Redis::ConnectionError
end

class Redis::ConnectionError
end

class Redis::Counter
  include ::Redis::Helpers::CoreCommands
  def +(what); end

  def -(what); end

  def decr(by=T.unsafe(nil), &block); end

  def decrby(by=T.unsafe(nil), &block); end

  def decrbyfloat(by=T.unsafe(nil), &block); end

  def decrement(by=T.unsafe(nil), &block); end

  def get(); end

  def getset(to=T.unsafe(nil)); end

  def incr(by=T.unsafe(nil), &block); end

  def incrby(by=T.unsafe(nil), &block); end

  def incrbyfloat(by=T.unsafe(nil), &block); end

  def increment(by=T.unsafe(nil), &block); end

  def key(); end

  def options(); end

  def reset(to=T.unsafe(nil)); end

  def set(val); end

  def to_f(); end

  def to_i(); end

  def value(); end

  def value=(val); end
end

class Redis::Counter
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, options=T.unsafe(nil)); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(key); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hset(key, field, value); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def mget(*keys); end

  def migrate(key, options); end

  def monitor(); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, options=T.unsafe(nil)); end

  def ring(); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, options=T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, options=T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, options=T.unsafe(nil)); end

  def sscan_each(key, options=T.unsafe(nil), &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, options=T.unsafe(nil)); end

  def zrange(key, start, stop, options=T.unsafe(nil)); end

  def zrangebyscore(key, min, max, options=T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, options=T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, options=T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunionstore(destination, keys, options=T.unsafe(nil)); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  def _command(); end

  def _set(object); end

  def class(); end

  def initialize(command, transformation, timeout); end

  def inspect(); end

  def is_a?(other); end

  def timeout(); end

  def value(); end
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::Future
end

class Redis::FutureNotReady
  def initialize(); end
end

class Redis::FutureNotReady
end

class Redis::HashKey
  include ::Enumerable
  include ::Redis::Helpers::CoreCommands
  def [](field); end

  def []=(field, value); end

  def all(); end

  def as_json(*_); end

  def bulk_get(*fields); end

  def bulk_set(*args); end

  def bulk_values(*keys); end

  def clone(); end

  def count(); end

  def decr(field, by=T.unsafe(nil)); end

  def decrby(field, by=T.unsafe(nil)); end

  def decrbyfloat(field, by=T.unsafe(nil)); end

  def delete(*field); end

  def each(&block); end

  def each_key(&block); end

  def each_value(&block); end

  def empty?(); end

  def fetch(field, *args, &block); end

  def fill(pairs=T.unsafe(nil)); end

  def get(field); end

  def has_key?(field); end

  def hget(field); end

  def include?(field); end

  def incr(field, by=T.unsafe(nil)); end

  def incrby(field, by=T.unsafe(nil)); end

  def incrbyfloat(field, by=T.unsafe(nil)); end

  def key(); end

  def key?(field); end

  def keys(); end

  def length(); end

  def member?(field); end

  def options(); end

  def size(); end

  def store(field, value); end

  def update(*args); end

  def vals(); end

  def value(); end

  def values(); end
end

class Redis::HashKey
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def get_node_pos(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def self.binary_search(ary, value, &block); end
end

module Redis::Helpers::CoreCommands
  def clear(); end

  def del(); end

  def delete(); end

  def exists?(); end

  def expire(seconds); end

  def expireat(unixtime); end

  def marshal(value, domarshal=T.unsafe(nil)); end

  def move(dbindex); end

  def persist(); end

  def rename(name, setkey=T.unsafe(nil)); end

  def renamenx(name, setkey=T.unsafe(nil)); end

  def sort(options=T.unsafe(nil)); end

  def ttl(); end

  def type(); end

  def unmarshal(value, domarshal=T.unsafe(nil)); end
end

module Redis::Helpers::CoreCommands
end

class Redis::InheritedError
end

class Redis::InheritedError
end

class Redis::InvalidClientOptionError
end

class Redis::InvalidClientOptionError
end

class Redis::List
  include ::Enumerable
  include ::Redis::Helpers::CoreCommands
  def <<(value); end

  def ==(x); end

  def [](index, length=T.unsafe(nil)); end

  def []=(index, value); end

  def as_json(*_); end

  def at(index); end

  def delete(name, count=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def first(); end

  def get(); end

  def insert(where, pivot, value); end

  def key(); end

  def last(); end

  def length(); end

  def options(); end

  def pop(n=T.unsafe(nil)); end

  def push(*values); end

  def range(start_index, end_index); end

  def rpoplpush(destination); end

  def shift(n=T.unsafe(nil)); end

  def size(); end

  def slice(index, length=T.unsafe(nil)); end

  def unshift(*values); end

  def value(); end

  def values(); end
end

class Redis::List
end

class Redis::Lock
  def clear(); end

  def delete(); end

  def generate_expiration(); end

  def key(); end

  def lock(); end

  def options(); end

  def value(); end
end

class Redis::Lock::LockTimeout
end

class Redis::Lock::LockTimeout
end

class Redis::Lock
end

class Redis::Namespace
  def _client(); end

  def call_with_namespace(command, *args, &block); end

  def client(); end

  def deprecations?(); end

  def eval(*args); end

  def exec(); end

  def initialize(namespace, options=T.unsafe(nil)); end

  def keys(query=T.unsafe(nil)); end

  def method_missing(command, *args, &block); end

  def multi(&block); end

  def namespace(desired_namespace=T.unsafe(nil)); end

  def namespace=(namespace); end

  def pipelined(&block); end

  def redis(); end

  def respond_to?(command, include_private=T.unsafe(nil)); end

  def self_respond_to?(*_); end

  def type(key); end

  def warning(); end

  def warning=(warning); end

  def warning?(); end
  ADMINISTRATIVE_COMMANDS = ::T.let(nil, ::T.untyped)
  COMMANDS = ::T.let(nil, ::T.untyped)
  DEPRECATED_COMMANDS = ::T.let(nil, ::T.untyped)
  HELPER_COMMANDS = ::T.let(nil, ::T.untyped)
  NAMESPACED_COMMANDS = ::T.let(nil, ::T.untyped)
  TRANSACTION_COMMANDS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::Namespace
end

module Redis::Objects
end

module Redis::Objects::ClassMethods
  def first_ancestor_with(name); end

  def redis(); end

  def redis=(conn); end

  def redis_field_key(name, id=T.unsafe(nil), context=T.unsafe(nil)); end

  def redis_field_redis(name); end

  def redis_id_field(id=T.unsafe(nil)); end

  def redis_objects(); end

  def redis_objects=(redis_objects); end

  def redis_options(name); end

  def redis_prefix(klass=T.unsafe(nil)); end

  def redis_prefix=(redis_prefix); end
end

module Redis::Objects::ClassMethods
end

class Redis::Objects::ConnectionPoolProxy
  def initialize(pool); end

  def method_missing(name, *args, &block); end
end

class Redis::Objects::ConnectionPoolProxy
  def self.proxy_if_needed(conn); end

  def self.should_proxy?(conn); end
end

module Redis::Objects::Counters
end

module Redis::Objects::Counters::ClassMethods
  def counter(name, options=T.unsafe(nil)); end

  def counter_defined?(name); end

  def decrement_counter(name, id=T.unsafe(nil), by=T.unsafe(nil), &block); end

  def get_counter(name, id=T.unsafe(nil)); end

  def getset_counter(name, id=T.unsafe(nil), to=T.unsafe(nil)); end

  def increment_counter(name, id=T.unsafe(nil), by=T.unsafe(nil), &block); end

  def initialized_counters(); end

  def reset_counter(name, id=T.unsafe(nil), to=T.unsafe(nil)); end
end

module Redis::Objects::Counters::ClassMethods
end

module Redis::Objects::Counters::InstanceMethods
  def decrement(name, by=T.unsafe(nil)); end

  def increment(name, by=T.unsafe(nil)); end
end

module Redis::Objects::Counters::InstanceMethods
end

module Redis::Objects::Counters
  def self.included(klass); end
end

module Redis::Objects::Hashes
end

module Redis::Objects::Hashes::ClassMethods
  def hash_key(name, options=T.unsafe(nil)); end
end

module Redis::Objects::Hashes::ClassMethods
end

module Redis::Objects::Hashes::InstanceMethods
end

module Redis::Objects::Hashes::InstanceMethods
end

module Redis::Objects::Hashes
  def self.included(klass); end
end

module Redis::Objects::InstanceMethods
  def delete!(); end

  def redis(); end

  def redis_field_key(name); end

  def redis_field_redis(name); end

  def redis_objects(); end

  def redis_options(name); end
end

module Redis::Objects::InstanceMethods
end

module Redis::Objects::Lists
end

module Redis::Objects::Lists::ClassMethods
  def list(name, options=T.unsafe(nil)); end
end

module Redis::Objects::Lists::ClassMethods
end

module Redis::Objects::Lists::InstanceMethods
end

module Redis::Objects::Lists::InstanceMethods
end

module Redis::Objects::Lists
  def self.included(klass); end
end

module Redis::Objects::Locks
end

module Redis::Objects::Locks::ClassMethods
  def clear_lock(name, id); end

  def lock(name, options=T.unsafe(nil)); end

  def obtain_lock(name, id, &block); end
end

module Redis::Objects::Locks::ClassMethods
end

module Redis::Objects::Locks
  def self.included(klass); end
end

class Redis::Objects::NilObjectId
end

class Redis::Objects::NilObjectId
end

class Redis::Objects::NotConnected
end

class Redis::Objects::NotConnected
end

module Redis::Objects::Sets
end

module Redis::Objects::Sets::ClassMethods
  def set(name, options=T.unsafe(nil)); end
end

module Redis::Objects::Sets::ClassMethods
end

module Redis::Objects::Sets::InstanceMethods
end

module Redis::Objects::Sets::InstanceMethods
end

module Redis::Objects::Sets
  def self.included(klass); end
end

module Redis::Objects::SortedSets
end

module Redis::Objects::SortedSets::ClassMethods
  def sorted_set(name, options=T.unsafe(nil)); end
end

module Redis::Objects::SortedSets::ClassMethods
end

module Redis::Objects::SortedSets::InstanceMethods
end

module Redis::Objects::SortedSets::InstanceMethods
end

module Redis::Objects::SortedSets
  def self.included(klass); end
end

module Redis::Objects::Values
end

module Redis::Objects::Values::ClassMethods
  def mget(name, objects=T.unsafe(nil)); end

  def value(name, options=T.unsafe(nil)); end
end

module Redis::Objects::Values::ClassMethods
end

module Redis::Objects::Values::InstanceMethods
end

module Redis::Objects::Values::InstanceMethods
end

module Redis::Objects::Values
  def self.included(klass); end
end

module Redis::Objects
  def self.included(klass); end

  def self.redis(); end

  def self.redis=(conn); end
end

class Redis::Pipeline
  def call(command, timeout: T.unsafe(nil), &block); end

  def call_pipeline(pipeline); end

  def call_with_timeout(command, timeout, &block); end

  def client(); end

  def commands(); end

  def db(); end

  def db=(db); end

  def empty?(); end

  def finish(replies, &blk); end

  def futures(); end

  def initialize(client); end

  def shutdown?(); end

  def timeout(); end

  def timeouts(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_reconnect?(); end

  def without_reconnect(&blk); end

  def without_reconnect?(); end
end

class Redis::Pipeline::Multi
  def finish(replies); end
end

class Redis::Pipeline::Multi
end

class Redis::Pipeline
end

class Redis::ProtocolError
  def initialize(reply_type); end
end

class Redis::ProtocolError
end

class Redis::Set
  include ::Enumerable
  include ::Redis::Helpers::CoreCommands
  def &(*sets); end

  def +(*sets); end

  def -(*sets); end

  def <<(value); end

  def ==(x); end

  def ^(*sets); end

  def add(value); end

  def as_json(*_); end

  def count(); end

  def delete(value); end

  def delete_if(&block); end

  def diff(*sets); end

  def difference(*sets); end

  def diffstore(name, *sets); end

  def each(&block); end

  def empty?(); end

  def get(); end

  def include?(value); end

  def inter(*sets); end

  def intersect(*sets); end

  def intersection(*sets); end

  def interstore(name, *sets); end

  def key(); end

  def length(); end

  def member?(value); end

  def members(); end

  def merge(*values); end

  def move(value, destination); end

  def options(); end

  def pop(); end

  def randmember(count=T.unsafe(nil)); end

  def size(); end

  def union(*sets); end

  def unionstore(name, *sets); end

  def value(); end

  def |(*sets); end
end

class Redis::Set
end

class Redis::SortedSet
  include ::Redis::Helpers::CoreCommands
  def &(*sets); end

  def +(*sets); end

  def ==(x); end

  def [](index, length=T.unsafe(nil)); end

  def []=(member, score); end

  def add(member, score); end

  def add_all(values); end

  def at(index); end

  def count(); end

  def decr(member, by=T.unsafe(nil)); end

  def decrby(member, by=T.unsafe(nil)); end

  def decrement(member, by=T.unsafe(nil)); end

  def delete(value); end

  def delete_if(&block); end

  def empty?(); end

  def first(); end

  def incr(member, by=T.unsafe(nil)); end

  def incrby(member, by=T.unsafe(nil)); end

  def increment(member, by=T.unsafe(nil)); end

  def inter(*sets); end

  def intersect(*sets); end

  def intersection(*sets); end

  def interstore(name, *sets); end

  def key(); end

  def last(); end

  def length(); end

  def member?(value); end

  def members(options=T.unsafe(nil)); end

  def merge(values); end

  def options(); end

  def range(start_index, end_index, options=T.unsafe(nil)); end

  def range_size(min, max); end

  def rangebyscore(min, max, options=T.unsafe(nil)); end

  def rank(member); end

  def remrangebyrank(min, max); end

  def remrangebyscore(min, max); end

  def revrange(start_index, end_index, options=T.unsafe(nil)); end

  def revrangebyscore(max, min, options=T.unsafe(nil)); end

  def revrank(member); end

  def score(member); end

  def size(); end

  def slice(index, length=T.unsafe(nil)); end

  def union(*sets); end

  def unionstore(name, *sets); end

  def value(options=T.unsafe(nil)); end

  def |(*sets); end
end

class Redis::SortedSet
end

class Redis::SubscribedClient
  def call(command); end

  def initialize(client); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def punsubscribe(*channels); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscription(start, stop, channels, block, timeout=T.unsafe(nil)); end

  def unsubscribe(*channels); end
end

class Redis::SubscribedClient
end

class Redis::Subscription
  def callbacks(); end

  def message(&block); end

  def pmessage(&block); end

  def psubscribe(&block); end

  def punsubscribe(&block); end

  def subscribe(&block); end

  def unsubscribe(&block); end
end

class Redis::Subscription
end

class Redis::TimeoutError
end

class Redis::TimeoutError
end

class Redis::Value
  include ::Redis::Helpers::CoreCommands
  def ==(other); end

  def compress(value); end

  def decompress(value); end

  def get(); end

  def key(); end

  def marshal(value, *args); end

  def method_missing(*args); end

  def options(); end

  def set(val); end

  def unmarshal(value, *args); end

  def value(); end

  def value=(val); end
end

class Redis::Value
end

class Redis
  def self.current(); end

  def self.current=(redis); end
end

class ReduceTasksStatsSize
end

class ReduceTasksTypeSize
end

class Regexp
  def multiline?(); end
end

class RenameHooksUrlInDeliveryUrl
end

class ReorderActiveTasksIndex
end

module Responders
end

module Responders::CollectionResponder
  def navigation_location(); end
end

module Responders::CollectionResponder
end

module Responders::ControllerMethod
  def responders(*responders); end
end

module Responders::ControllerMethod
end

module Responders::FlashResponder
  def controller_interpolation_options(); end

  def flash_defaults_by_namespace(status); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def mount_i18n_options(status); end

  def resource_name(); end

  def set_flash(key, value); end

  def set_flash_message!(); end

  def set_flash_message?(); end

  def set_flash_now?(); end

  def to_html(); end

  def to_js(); end
end

module Responders::FlashResponder
  def self.flash_keys(); end

  def self.flash_keys=(flash_keys); end

  def self.helper(); end

  def self.helper=(helper); end

  def self.namespace_lookup(); end

  def self.namespace_lookup=(namespace_lookup); end
end

module Responders::HttpCacheResponder
  def do_http_cache!(); end

  def do_http_cache?(); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def persisted?(); end

  def to_format(); end
end

module Responders::HttpCacheResponder
end

module Responders::LocationResponder
end

module Responders::LocationResponder
  def self.included(_base); end
end

class Responders::Railtie
end

class Responders::Railtie
end

module Responders
end

module RuboCop
  RUBY_EXTENSIONS = ::T.let(nil, ::T.untyped)
  RUBY_FILENAMES = ::T.let(nil, ::T.untyped)
  RUBY_INTERPRETERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end

  def node_parts(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def node_parts(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def node_parts(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def average(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def butfirst(*args, &block); end

  def butlast(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_last(*args, &block); end

  def drop_last_while(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exactly?(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def frequencies(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def several?(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_last(*args, &block); end

  def take_last_while(*args, &block); end

  def take_while(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def body(); end

  def method_name(); end

  def node_parts(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::EnsureNode
  def body(); end

  def node_parts(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def node_parts(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def node_parts(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def node_parts(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def bare_access_modifier?(node=T.unsafe(nil)); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def receiver(); end

  def self_receiver?(); end

  def setter_method?(); end
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def operator_method?(); end

  def predicate_method?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def arithmetic_operation?(); end

  def array_type?(); end

  def asgn_method_call?(); end

  def asgn_rhs(node=T.unsafe(nil)); end

  def assignment?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def binary_operation?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def break_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def const_name(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(node=T.unsafe(nil)); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def guard_clause?(node=T.unsafe(nil)); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def keyword_bang?(); end

  def keyword_not?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_current_line_type?(); end

  def match_with_lvasgn_type?(); end

  def meth_ref_type?(); end

  def method_name(node=T.unsafe(nil)); end

  def mlhs_type?(); end

  def module_definition?(node=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def numparam_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(node=T.unsafe(nil)); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def unary_operation?(); end

  def undef_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end

  def node_parts(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end

  def node_parts(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def node_parts(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def lambda?(); end

  def negation_method?(); end

  def node_parts(); end

  def stabby_lambda?(); end
  ARROW = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def node_parts(); end
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
  def node_parts(); end
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_if(node); end

  def on_iflipflop(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end

  def node_parts(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def node_parts(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end

  def node_parts(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def node_parts(); end
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  include ::RuboCop::Formatter::TextUtil
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end

  def trap_interrupt(runner); end
  SKIPPED_PHASE_1 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  UNNEEDED_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  def [](key); end

  def []=(key, value); end

  def add_excludes_from_higher_level(highest_config); end

  def base_dir_for_path_parameters(); end

  def check(); end

  def delete(key); end

  def deprecation_check(); end

  def each(&block); end

  def each_key(&block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(&block); end

  def merge(other_hash); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def possibly_include_hidden?(); end

  def target_rails_version(); end

  def target_ruby_version(); end

  def to_h(); end

  def to_hash(); end

  def validate(); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
  DEFAULT_RUBY_VERSION = ::T.let(nil, ::T.untyped)
  KNOWN_RUBIES = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  OBSOLETE_RUBIES = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file); end

  def self.root_level=(root_level); end

  def self.target_ruby_version_to_f!(hash); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash); end

  def merge_with_default(config, config_file); end

  def resolve_inheritance(path, hash, file); end

  def resolve_inheritance_from_gems(hash, gems); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayHashIndentation
end

module RuboCop::Cop::ArrayHashIndentation
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner::CopError
  def column(); end

  def column=(_); end

  def error(); end

  def error=(_); end

  def line(); end

  def line=(_); end
end

class RuboCop::Cop::Commissioner::CopError
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
  def self.callback_methods(); end
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.non_rails(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def remove_leading(range, size); end

  def remove_preceding(range, size); end

  def remove_trailing(range, size); end

  def replace(range, content); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignment
end

class RuboCop::Cop::HashAlignment::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(*_); end
end

class RuboCop::Cop::HashAlignment::KeyAlignment
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(*_); end
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
end

class RuboCop::Cop::HashAlignment::TableAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignment::TableAlignment
end

module RuboCop::Cop::HashAlignment::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignment::ValueAlignment
end

module RuboCop::Cop::HashAlignment
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::AlignArray
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignArray
end

class RuboCop::Cop::Layout::AlignHash
  include ::RuboCop::Cop::HashAlignment
  def autocorrect(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignHash
end

class RuboCop::Cop::Layout::AlignParameters
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignParameters
end

class RuboCop::Cop::Layout::BlockEndNewline
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  def autocorrect(token); end

  def investigate(source); end
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  def autocorrect(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::IndentArray
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentArray
end

class RuboCop::Cop::Layout::IndentAssignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentAssignment
end

class RuboCop::Cop::Layout::IndentHash
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation
  def autocorrect(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentHash
end

class RuboCop::Cop::Layout::IndentHeredoc
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SafeMode
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentHeredoc
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  def autocorrect(range); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(lambda_node); end

  def on_send(node); end
  ARROW = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::Tab
  include ::RuboCop::Cop::Alignment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::Tab
end

class RuboCop::Cop::Layout::TrailingBlankLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingBlankLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BlockAlignment
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConditionPosition
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end

  def pry_rescue?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DefEndAlignment
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(class_constant, deprecated_method, replacement_method); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::DuplicatedKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicatedKey
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Lint::EndAlignment
end

class RuboCop::Cop::Lint::EndInMethod
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EndInMethod
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def on_send(node); end
  FIELD_REGEX = ::T.let(nil, ::T.untyped)
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NAMED_FIELD_REGEX = ::T.let(nil, ::T.untyped)
  NAMED_INTERPOLATION = ::T.let(nil, ::T.untyped)
  PERCENT = ::T.let(nil, ::T.untyped)
  PERCENT_PERCENT = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HandleExceptions
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HandleExceptions
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_method(node=T.unsafe(nil)); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  def autocorrect(node); end

  def on_dstr(node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleCompare
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleCompare
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantWithIndex
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  def autocorrect(node); end

  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnneededDisable
  include ::RuboCop::NameSimilarity
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededDisable
end

class RuboCop::Cop::Lint::UnneededRequireStatement
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededRequireStatement
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message, name); end

  def config(); end

  def cop_config(); end

  def initialize(config, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::LineLength
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::LineLength
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_RHS_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  extend ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(processed_source, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def corrected(); end

  def corrected?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::PercentLiteral
end

module RuboCop::Cop::Performance
end

class RuboCop::Cop::Performance::Caller
  def caller_with_scope_method?(node=T.unsafe(nil)); end

  def on_send(node); end

  def slow_caller?(node=T.unsafe(nil)); end
  MSG_BRACE = ::T.let(nil, ::T.untyped)
  MSG_FIRST = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Caller
end

class RuboCop::Cop::Performance::CaseWhenSplat
  include ::RuboCop::Cop::Alignment
  def autocorrect(when_node); end

  def on_case(case_node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::CaseWhenSplat
end

class RuboCop::Cop::Performance::Casecmp
  def autocorrect(node); end

  def downcase_eq(node=T.unsafe(nil)); end

  def eq_downcase(node=T.unsafe(nil)); end

  def on_send(node); end
  CASE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Casecmp
end

class RuboCop::Cop::Performance::CompareWithBlock
  def autocorrect(node); end

  def compare?(node=T.unsafe(nil)); end

  def on_block(node); end

  def replaceable_body?(node=T.unsafe(nil), param1, param2); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::CompareWithBlock
end

class RuboCop::Cop::Performance::Count
  include ::RuboCop::Cop::SafeMode
  def autocorrect(node); end

  def count_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Count
end

class RuboCop::Cop::Performance::Detect
  include ::RuboCop::Cop::SafeMode
  def autocorrect(node); end

  def detect_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REVERSE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Detect
end

class RuboCop::Cop::Performance::DoubleStartEndWith
  def autocorrect(node); end

  def check_with_active_support_aliases(node=T.unsafe(nil)); end

  def on_or(node); end

  def two_start_end_with_calls(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::DoubleStartEndWith
end

class RuboCop::Cop::Performance::EndWith
  def autocorrect(node); end

  def literal_at_end?(regex_str); end

  def on_send(node); end

  def redundant_regex?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::EndWith
end

class RuboCop::Cop::Performance::FixedSize
  def counter(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FixedSize
end

class RuboCop::Cop::Performance::FlatMap
  def autocorrect(node); end

  def flat_map_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  FLATTEN_MULTIPLE_LEVELS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FlatMap
end

class RuboCop::Cop::Performance::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end

  def kv_each(node=T.unsafe(nil)); end

  def on_block(node); end

  def plain_each(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::HashEachMethods
end

class RuboCop::Cop::Performance::LstripRstrip
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::LstripRstrip
end

class RuboCop::Cop::Performance::RangeInclude
  def autocorrect(node); end

  def on_send(node); end

  def range_include(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RangeInclude
end

class RuboCop::Cop::Performance::RedundantBlockCall
  def autocorrect(node); end

  def blockarg_assigned?(node0, param1); end

  def blockarg_calls(node0, param1); end

  def blockarg_def(node=T.unsafe(nil)); end

  def on_def(node); end
  CLOSE_PAREN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OPEN_PAREN = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  YIELD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantBlockCall
end

class RuboCop::Cop::Performance::RedundantMatch
  def autocorrect(node); end

  def match_call?(node=T.unsafe(nil)); end

  def on_send(node); end

  def only_truthiness_matters?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMatch
end

class RuboCop::Cop::Performance::RedundantMerge
  def autocorrect(node); end

  def modifier_flow_control?(node=T.unsafe(nil)); end

  def on_send(node); end

  def redundant_merge_candidate(node=T.unsafe(nil)); end
  AREF_ASGN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  def each_with_object_node(node=T.unsafe(nil)); end

  def initialize(node, receiver); end

  def value_used?(); end
end

class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Performance::RedundantMerge
end

class RuboCop::Cop::Performance::RedundantSortBy
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantSortBy
end

class RuboCop::Cop::Performance::RegexpMatch
  def autocorrect(node); end

  def last_matches(node0); end

  def match_method?(node=T.unsafe(nil)); end

  def match_node?(node=T.unsafe(nil)); end

  def match_operator?(node=T.unsafe(nil)); end

  def match_threequals?(node=T.unsafe(nil)); end

  def match_with_lvasgn?(node); end

  def on_case(node); end

  def on_if(node); end

  def search_match_nodes(node0); end
  MATCH_NODE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RegexpMatch
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Performance::ReverseEach
  def autocorrect(node); end

  def on_send(node); end

  def reverse_each?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ReverseEach
end

class RuboCop::Cop::Performance::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Sample
end

class RuboCop::Cop::Performance::Size
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Size
end

class RuboCop::Cop::Performance::StartWith
  def autocorrect(node); end

  def literal_at_start?(regex_str); end

  def on_send(node); end

  def redundant_regex?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StartWith
end

class RuboCop::Cop::Performance::StringReplacement
  def autocorrect(node); end

  def on_send(node); end

  def replace_method(node, first, second, first_param, replacement); end

  def string_replacement?(node=T.unsafe(nil)); end
  BANG = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  TR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringReplacement
end

class RuboCop::Cop::Performance::TimesMap
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end

  def times_map_call(node=T.unsafe(nil)); end
  MESSAGE = ::T.let(nil, ::T.untyped)
  MESSAGE_ONLY_IF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::TimesMap
end

class RuboCop::Cop::Performance::UnfreezeString
  def dup_string?(node=T.unsafe(nil)); end

  def on_send(node); end

  def string_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UnfreezeString
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Performance::UriDefaultParser
  def autocorrect(node); end

  def on_send(node); end

  def uri_parser_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UriDefaultParser
end

module RuboCop::Cop::Performance
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::Rails
end

class RuboCop::Cop::Rails::ActionFilter
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ACTION_METHODS = ::T.let(nil, ::T.untyped)
  FILTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionFilter
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ActiveSupportAliases
  def append(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def ends_with?(node=T.unsafe(nil)); end

  def on_send(node); end

  def prepend(node=T.unsafe(nil)); end

  def starts_with?(node=T.unsafe(nil)); end
  ALIASES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveSupportAliases
end

class RuboCop::Cop::Rails::ApplicationJob
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationJob
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ApplicationRecord
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationRecord
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::Blank
  def autocorrect(node); end

  def nil_or_empty?(node=T.unsafe(nil)); end

  def not_present?(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_present?(node=T.unsafe(nil)); end
  MSG_NIL_OR_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_PRESENT = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Blank
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
  def create_table_with_block?(node=T.unsafe(nil)); end

  def created_at_or_updated_at_included?(node0); end

  def on_send(node); end

  def timestamps_included?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
end

class RuboCop::Cop::Rails::Date
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_const(node); end

  def on_send(node); end
  BAD_DAYS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Date
end

class RuboCop::Cop::Rails::Delegate
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Delegate
end

class RuboCop::Cop::Rails::DelegateAllowBlank
  def allow_blank_option?(node=T.unsafe(nil)); end

  def autocorrect(pair_node); end

  def delegate_options(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DelegateAllowBlank
end

class RuboCop::Cop::Rails::DynamicFindBy
  def autocorrect(node); end

  def on_send(node); end
  METHOD_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DynamicFindBy
end

class RuboCop::Cop::Rails::EnumUniqueness
  include ::RuboCop::Cop::Duplication
  def enum_declaration(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumUniqueness
end

class RuboCop::Cop::Rails::EnvironmentComparison
  def autocorrect(node); end

  def environment_str_comparison?(node=T.unsafe(nil)); end

  def environment_sym_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SYM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvironmentComparison
end

class RuboCop::Cop::Rails::Exit
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  EXPLICIT_RECEIVERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Exit
end

class RuboCop::Cop::Rails::FilePath
  def file_join_nodes?(node=T.unsafe(nil)); end

  def on_dstr(node); end

  def on_send(node); end

  def rails_root_join_nodes?(node=T.unsafe(nil)); end

  def rails_root_nodes?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FilePath
end

class RuboCop::Cop::Rails::FindBy
  def autocorrect(node); end

  def on_send(node); end

  def where_first?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindBy
end

class RuboCop::Cop::Rails::FindEach
  def autocorrect(node); end

  def on_send(node); end
  IGNORED_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SCOPE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindEach
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
  def association_with_options?(node=T.unsafe(nil)); end

  def association_without_options?(node=T.unsafe(nil)); end

  def dependent_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def present_option?(node=T.unsafe(nil)); end

  def with_options_block(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  def autocorrect(node); end

  def convert_hash_data(data, type); end

  def format_arg?(node); end

  def http_request?(node=T.unsafe(nil)); end

  def needs_conversion?(data); end

  def on_send(node); end

  def special_keyword_arg?(node); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORD_ARGS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::InverseOf
  def as_option?(node=T.unsafe(nil)); end

  def association_recv_arguments(node=T.unsafe(nil)); end

  def class_name_option?(node=T.unsafe(nil)); end

  def conditions_option?(node=T.unsafe(nil)); end

  def foreign_key_option?(node=T.unsafe(nil)); end

  def inverse_of_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def options_contain_inverse_of?(options); end

  def options_from_argument(node=T.unsafe(nil)); end

  def options_ignoring_inverse_of?(options); end

  def options_requiring_inverse_of?(options); end

  def polymorphic_option?(node=T.unsafe(nil)); end

  def same_context_in_with_options?(arg, recv); end

  def scope?(arguments); end

  def through_option?(node=T.unsafe(nil)); end

  def with_options_arguments(recv, node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::InverseOf
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
  def on_send(node); end

  def only_or_except_filter_methods(node=T.unsafe(nil)); end
  FILTERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
end

class RuboCop::Cop::Rails::NotNullColumn
  def add_not_null_column?(node=T.unsafe(nil)); end

  def add_not_null_reference?(node=T.unsafe(nil)); end

  def default_option?(node=T.unsafe(nil)); end

  def null_false?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NotNullColumn
end

class RuboCop::Cop::Rails::Output
  def on_send(node); end

  def output?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Output
end

class RuboCop::Cop::Rails::OutputSafety
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::OutputSafety
end

class RuboCop::Cop::Rails::PluralizationGrammar
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLURAL_DURATION_METHODS = ::T.let(nil, ::T.untyped)
  SINGULAR_DURATION_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluralizationGrammar
end

class RuboCop::Cop::Rails::Presence
  def autocorrect(node); end

  def on_if(node); end

  def redundant_negative_receiver_and_other(node=T.unsafe(nil)); end

  def redundant_receiver_and_other(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Presence
end

class RuboCop::Cop::Rails::Present
  def autocorrect(node); end

  def exists_and_not_empty?(node=T.unsafe(nil)); end

  def not_blank?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_blank?(node=T.unsafe(nil)); end
  MSG_EXISTS_AND_NOT_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_BLANK = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_BLANK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Present
end

class RuboCop::Cop::Rails::ReadWriteAttribute
  def autocorrect(node); end

  def on_send(node); end

  def read_write_attribute?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReadWriteAttribute
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  def all_block_nodes_in(node0); end

  def all_send_nodes_in(node0); end

  def autocorrect(node); end

  def on_block(node); end

  def with_options?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::RelativeDateConstant
  def autocorrect(node); end

  def on_casgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RELATIVE_DATE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RelativeDateConstant
end

class RuboCop::Cop::Rails::RequestReferer
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end

  def referer?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RequestReferer
end

class RuboCop::Cop::Rails::ReversibleMigration
  def change_column_default_call(node=T.unsafe(nil)); end

  def change_table_call(node=T.unsafe(nil)); end

  def drop_table_call(node=T.unsafe(nil)); end

  def irreversible_schema_statement_call(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end

  def remove_column_call(node=T.unsafe(nil)); end

  def remove_foreign_key_call(node=T.unsafe(nil)); end
  IRREVERSIBLE_CHANGE_TABLE_CALLS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReversibleMigration
end

class RuboCop::Cop::Rails::SafeNavigation
  def autocorrect(node); end

  def on_send(node); end

  def try_call(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigation
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Rails::SaveBang
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def check_assignment(assignment); end

  def join_force?(force_class); end

  def on_send(node); end
  CREATE_CONDITIONAL_MSG = ::T.let(nil, ::T.untyped)
  CREATE_MSG = ::T.let(nil, ::T.untyped)
  CREATE_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MODIFY_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERSIST_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SaveBang
end

class RuboCop::Cop::Rails::ScopeArgs
  def on_send(node); end

  def scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ScopeArgs
end

class RuboCop::Cop::Rails::SkipsModelValidations
  def good_touch?(node=T.unsafe(nil)); end

  def on_send(node); end
  METHODS_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SkipsModelValidations
end

class RuboCop::Cop::Rails::TimeZone
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_const(node); end
  ACCEPTED_METHODS = ::T.let(nil, ::T.untyped)
  DANGEROUS_METHODS = ::T.let(nil, ::T.untyped)
  GOOD_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ACCEPTABLE = ::T.let(nil, ::T.untyped)
  MSG_CURRENT = ::T.let(nil, ::T.untyped)
  MSG_LOCALTIME = ::T.let(nil, ::T.untyped)
  TIMECLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TimeZone
end

class RuboCop::Cop::Rails::UniqBeforePluck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def aggressive_node_match(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def conservative_node_match(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqBeforePluck
end

class RuboCop::Cop::Rails::UnknownEnv
  include ::RuboCop::NameSimilarity
  def on_send(node); end

  def unknown_environment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SIMILAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UnknownEnv
end

class RuboCop::Cop::Rails::Validation
  def autocorrect(node); end

  def on_send(node); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  WHITELIST = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Validation
end

module RuboCop::Cop::Rails
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def departments(); end

  def each(&block); end

  def enabled(config, only); end

  def enlist(cop); end

  def initialize(cops=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def qualified_cop_name(name, path); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::SafeMode
end

module RuboCop::Cop::SafeMode
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::BracesAroundHashParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(send_node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BracesAroundHashParameters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::Copyright
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FlipFlop
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
  FIELD_CHARACTERS = ::T.let(nil, ::T.untyped)
  FORMAT_STRING_METHODS = ::T.let(nil, ::T.untyped)
  STYLE_PATTERNS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def autocorrect(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def lambda_node?(node=T.unsafe(nil)); end

  def on_block(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_EDGE_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  def autocorrect(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  def autocorrect(node); end

  def on_send(node); end
  ASGN_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissing
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultipleComparison
  def on_if(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(outer_node, inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  def autocorrect(nested); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  def autocorrect(node); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
  ALLOWED_LITERALS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantReturn
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate?(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NIL_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  def autocorrect(node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  def autocorrect(node); end

  def method_call_argument(node=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInLiteral
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_array(node); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(_node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessCorrector
end

class RuboCop::Cop::Style::UnlessCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end
end

class RuboCop::Cop::Style::UnlessElse
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnneededCapitalW
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededCapitalW
end

class RuboCop::Cop::Style::UnneededInterpolation
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededInterpolation
end

class RuboCop::Cop::Style::UnneededPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededPercentQ
end

class RuboCop::Cop::Style::VariableInterpolation
  def autocorrect(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_xstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  include ::RuboCop::Cop::PercentLiteral
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
  QUESTION_MARK_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end

  def support_target_rails_version?(version); end
end

module RuboCop::Cop::TargetRailsVersion
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(processed_source, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  ASGN_NODES = ::T.let(nil, ::T.untyped)
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
  CONDITIONAL_NODES = ::T.let(nil, ::T.untyped)
  EQUALS_ASGN_NODES = ::T.let(nil, ::T.untyped)
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_NODES = ::T.let(nil, ::T.untyped)
  MODIFIER_NODES = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASGN_NODES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  extend ::RuboCop::AST::Sexp
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.effective_column(range); end

  def self.ends_its_line?(range); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(arg); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.operator?(symbol); end

  def self.parentheses?(node); end

  def self.parenthesized_call?(send); end

  def self.precede?(n1, n2); end

  def self.range_between(start_pos, end_pos); end

  def self.range_by_whole_lines(range, include_final_newline: T.unsafe(nil)); end

  def self.range_with_surrounding_comma(range, side=T.unsafe(nil)); end

  def self.range_with_surrounding_space(range:, side: T.unsafe(nil), newlines: T.unsafe(nil), whitespace: T.unsafe(nil)); end

  def self.same_line?(n1, n2); end

  def self.source_range(source_buffer, line_number, column, length=T.unsafe(nil)); end

  def self.strip_quotes(str); end

  def self.stripped_source_upto(line); end

  def self.symbol_without_quote?(string); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.to_symbol_literal(string); end

  def self.within_node?(inner, outer); end
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop
end

class RuboCop::Error
end

class RuboCop::Error
end

module RuboCop::Formatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  COPS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::DisabledLinesFormatter
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::Colorizable
  def cop_disabled_line_ranges(); end

  def finished(_inspected_files); end

  def started(_target_files); end
end

class RuboCop::Formatter::DisabledLinesFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*_); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(s); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
end

class RuboCop::NodePattern
  def initialize(str); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
end

class RuboCop::NodePattern
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def no_offense_counts_without_auto_gen_config?(); end

  def only_includes_unneeded_disable?(); end

  def validate_compatibility(); end

  def validate_exclude_limit_option(args); end

  def validate_parallel(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.find_file_upwards(filename, start_dir=T.unsafe(nil)); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def comments(); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def raw_source(); end

  def ruby_version(); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def abort(); end

  def aborting(); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

class RuboCop::StringUtil::Jaro
  def distance(); end

  def initialize(a, b); end

  def longer(); end

  def shorter(); end
end

class RuboCop::StringUtil::Jaro
  def self.distance(*args); end
end

class RuboCop::StringUtil::JaroWinkler
  def boost_threshold(); end

  def initialize(a, b, boost_threshold=T.unsafe(nil), scaling_factor=T.unsafe(nil)); end

  def scaling_factor(); end
  DEFAULT_BOOST_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_SCALING_FACTOR = ::T.let(nil, ::T.untyped)
  MAX_COMMON_PREFIX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringUtil::JaroWinkler
end

module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::AbortException
end

class SQLite3::AbortException
end

class SQLite3::AuthorizationException
end

class SQLite3::AuthorizationException
end

class SQLite3::Backup
  def finish(); end

  def initialize(_, _1, _2, _3); end

  def pagecount(); end

  def remaining(); end

  def step(_); end
end

class SQLite3::Backup
end

class SQLite3::Blob
end

class SQLite3::Blob
end

class SQLite3::BusyException
end

class SQLite3::BusyException
end

class SQLite3::CantOpenException
end

class SQLite3::CantOpenException
end

module SQLite3::Constants
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ColumnType
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  DETERMINISTIC = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::TextRep
end

module SQLite3::Constants
end

class SQLite3::ConstraintException
end

class SQLite3::ConstraintException
end

class SQLite3::CorruptException
end

class SQLite3::CorruptException
end

class SQLite3::Database
  include ::SQLite3::Pragmas
  def authorizer(&block); end

  def authorizer=(authorizer); end

  def busy_handler(*_); end

  def busy_timeout(_); end

  def busy_timeout=(busy_timeout); end

  def changes(); end

  def close(); end

  def closed?(); end

  def collation(_, _1); end

  def collations(); end

  def commit(); end

  def complete?(_); end

  def create_aggregate(name, arity, step=T.unsafe(nil), finalize=T.unsafe(nil), text_rep=T.unsafe(nil), &block); end

  def create_aggregate_handler(handler); end

  def create_function(name, arity, text_rep=T.unsafe(nil), &block); end

  def define_aggregator(name, aggregator); end

  def define_function(_); end

  def define_function_with_flags(_, _1); end

  def enable_load_extension(_); end

  def errcode(); end

  def errmsg(); end

  def execute(sql, bind_vars=T.unsafe(nil), *args, &block); end

  def execute2(sql, *bind_vars); end

  def execute_batch(sql, bind_vars=T.unsafe(nil), *args); end

  def execute_batch2(sql, &block); end

  def extended_result_codes=(extended_result_codes); end

  def filename(db_name=T.unsafe(nil)); end

  def get_first_row(sql, *bind_vars); end

  def get_first_value(sql, *bind_vars); end

  def initialize(file, options=T.unsafe(nil), zvfs=T.unsafe(nil)); end

  def interrupt(); end

  def last_insert_row_id(); end

  def load_extension(_); end

  def prepare(sql); end

  def query(sql, bind_vars=T.unsafe(nil), *args); end

  def readonly?(); end

  def results_as_hash(); end

  def results_as_hash=(results_as_hash); end

  def rollback(); end

  def total_changes(); end

  def trace(*_); end

  def transaction(mode=T.unsafe(nil)); end

  def transaction_active?(); end

  def translate_from_db(types, row); end

  def translator(); end

  def type_translation(); end

  def type_translation=(value); end
  NULL_TRANSLATOR = ::T.let(nil, ::T.untyped)
end

class SQLite3::Database::FunctionProxy
  def [](key); end

  def []=(key, value); end

  def count(); end

  def result(); end

  def result=(result); end

  def set_error(error); end
end

class SQLite3::Database::FunctionProxy
end

class SQLite3::Database
  def self.quote(string); end
end

class SQLite3::EmptyException
end

class SQLite3::EmptyException
end

class SQLite3::Exception
  def code(); end
end

class SQLite3::Exception
end

class SQLite3::FormatException
end

class SQLite3::FormatException
end

class SQLite3::FullException
end

class SQLite3::FullException
end

class SQLite3::IOException
end

class SQLite3::IOException
end

class SQLite3::InternalException
end

class SQLite3::InternalException
end

class SQLite3::InterruptException
end

class SQLite3::InterruptException
end

class SQLite3::LockedException
end

class SQLite3::LockedException
end

class SQLite3::MemoryException
end

class SQLite3::MemoryException
end

class SQLite3::MismatchException
end

class SQLite3::MismatchException
end

class SQLite3::MisuseException
end

class SQLite3::MisuseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotFoundException
end

class SQLite3::NotFoundException
end

class SQLite3::PermissionException
end

class SQLite3::PermissionException
end

module SQLite3::Pragmas
  def application_id(); end

  def application_id=(integer); end

  def auto_vacuum(); end

  def auto_vacuum=(mode); end

  def automatic_index(); end

  def automatic_index=(mode); end

  def busy_timeout(); end

  def busy_timeout=(milliseconds); end

  def cache_size(); end

  def cache_size=(size); end

  def cache_spill(); end

  def cache_spill=(mode); end

  def case_sensitive_like=(mode); end

  def cell_size_check(); end

  def cell_size_check=(mode); end

  def checkpoint_fullfsync(); end

  def checkpoint_fullfsync=(mode); end

  def collation_list(&block); end

  def compile_options(&block); end

  def count_changes(); end

  def count_changes=(mode); end

  def data_version(); end

  def database_list(&block); end

  def default_cache_size(); end

  def default_cache_size=(size); end

  def default_synchronous(); end

  def default_synchronous=(mode); end

  def default_temp_store(); end

  def default_temp_store=(mode); end

  def defer_foreign_keys(); end

  def defer_foreign_keys=(mode); end

  def encoding(); end

  def encoding=(mode); end

  def foreign_key_check(*table, &block); end

  def foreign_key_list(table, &block); end

  def foreign_keys(); end

  def foreign_keys=(mode); end

  def freelist_count(); end

  def full_column_names(); end

  def full_column_names=(mode); end

  def fullfsync(); end

  def fullfsync=(mode); end

  def get_boolean_pragma(name); end

  def get_enum_pragma(name); end

  def get_int_pragma(name); end

  def get_query_pragma(name, *parms, &block); end

  def ignore_check_constraints=(mode); end

  def incremental_vacuum(pages, &block); end

  def index_info(index, &block); end

  def index_list(table, &block); end

  def index_xinfo(index, &block); end

  def integrity_check(*num_errors, &block); end

  def journal_mode(); end

  def journal_mode=(mode); end

  def journal_size_limit(); end

  def journal_size_limit=(size); end

  def legacy_file_format(); end

  def legacy_file_format=(mode); end

  def locking_mode(); end

  def locking_mode=(mode); end

  def max_page_count(); end

  def max_page_count=(size); end

  def mmap_size(); end

  def mmap_size=(size); end

  def page_count(); end

  def page_size(); end

  def page_size=(size); end

  def parser_trace=(mode); end

  def query_only(); end

  def query_only=(mode); end

  def quick_check(*num_errors, &block); end

  def read_uncommitted(); end

  def read_uncommitted=(mode); end

  def recursive_triggers(); end

  def recursive_triggers=(mode); end

  def reverse_unordered_selects(); end

  def reverse_unordered_selects=(mode); end

  def schema_cookie(); end

  def schema_cookie=(cookie); end

  def schema_version(); end

  def schema_version=(version); end

  def secure_delete(); end

  def secure_delete=(mode); end

  def set_boolean_pragma(name, mode); end

  def set_enum_pragma(name, mode, enums); end

  def set_int_pragma(name, value); end

  def short_column_names(); end

  def short_column_names=(mode); end

  def shrink_memory(); end

  def soft_heap_limit(); end

  def soft_heap_limit=(mode); end

  def stats(&block); end

  def synchronous(); end

  def synchronous=(mode); end

  def table_info(table); end

  def temp_store(); end

  def temp_store=(mode); end

  def threads(); end

  def threads=(count); end

  def user_cookie(); end

  def user_cookie=(cookie); end

  def user_version(); end

  def user_version=(version); end

  def vdbe_addoptrace=(mode); end

  def vdbe_debug=(mode); end

  def vdbe_listing=(mode); end

  def vdbe_trace(); end

  def vdbe_trace=(mode); end

  def wal_autocheckpoint(); end

  def wal_autocheckpoint=(mode); end

  def wal_checkpoint(); end

  def wal_checkpoint=(mode); end

  def writable_schema=(mode); end
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
end

class SQLite3::ProtocolException
end

class SQLite3::ProtocolException
end

class SQLite3::RangeException
end

class SQLite3::RangeException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ResultSet
  include ::Enumerable
  def close(); end

  def closed?(); end

  def columns(); end

  def each(&blk); end

  def each_hash(); end

  def eof?(); end

  def initialize(db, stmt); end

  def next(); end

  def next_hash(); end

  def reset(*bind_params); end

  def types(); end
end

class SQLite3::ResultSet::ArrayWithTypes
  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypes
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
end

class SQLite3::ResultSet::HashWithTypesAndFields
  def [](key); end

  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::HashWithTypesAndFields
end

class SQLite3::ResultSet
end

class SQLite3::SQLException
end

class SQLite3::SQLException
end

class SQLite3::SchemaChangedException
end

class SQLite3::SchemaChangedException
end

class SQLite3::Statement
  include ::Enumerable
  def active?(); end

  def bind_param(_, _1); end

  def bind_parameter_count(); end

  def bind_params(*bind_vars); end

  def clear_bindings!(); end

  def close(); end

  def closed?(); end

  def column_count(); end

  def column_decltype(_); end

  def column_name(_); end

  def columns(); end

  def database_name(_); end

  def done?(); end

  def each(&blk); end

  def execute(*bind_vars); end

  def execute!(*bind_vars, &block); end

  def initialize(_, _1); end

  def must_be_open!(); end

  def remainder(); end

  def reset!(); end

  def step(); end

  def types(); end
end

class SQLite3::Statement
end

class SQLite3::TooBigException
end

class SQLite3::TooBigException
end

class SQLite3::Translator
  def add_translator(type, &block); end

  def translate(type, value); end
end

class SQLite3::Translator
end

class SQLite3::UnsupportedException
end

class SQLite3::UnsupportedException
end

class SQLite3::Value
  def handle(); end

  def initialize(db, handle); end

  def length(utf16=T.unsafe(nil)); end

  def null?(); end

  def to_blob(); end

  def to_f(); end

  def to_i(); end

  def to_int64(); end

  def to_s(utf16=T.unsafe(nil)); end

  def type(); end
end

class SQLite3::Value
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
end

module SQLite3
  def self.const_missing(name); end

  def self.libversion(); end

  def self.sqlcipher?(); end

  def self.threadsafe(); end

  def self.threadsafe?(); end
end

module SafeType
end

class SafeType::Boolean
  def initialize(type: T.unsafe(nil), **args); end
end

class SafeType::Boolean
  def self.default(value=T.unsafe(nil)); end
end

module SafeType::BooleanMixin
end

module SafeType::BooleanMixin
end

class SafeType::CoercionError
  def desired_type(); end

  def initialize(value, desired_type, key=T.unsafe(nil)); end

  def key(); end

  def value(); end
end

class SafeType::CoercionError
end

class SafeType::Converter
end

class SafeType::Converter
  def self.to_bool(input); end

  def self.to_date(input); end

  def self.to_date_time(input); end

  def self.to_false(input); end

  def self.to_float(input); end

  def self.to_int(input); end

  def self.to_time(input); end

  def self.to_true(input); end

  def self.to_type(input, type); end
end

class SafeType::Date
  def initialize(type: T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), **args); end
end

class SafeType::Date
  def self.default(value=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.strict(from: T.unsafe(nil), to: T.unsafe(nil)); end
end

class SafeType::DateTime
  def initialize(type: T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), **args); end
end

class SafeType::DateTime
  def self.default(value=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.strict(from: T.unsafe(nil), to: T.unsafe(nil)); end
end

class SafeType::EmptyValueError
  def desired_type(); end

  def initialize(desired_type, key=T.unsafe(nil)); end

  def key(); end
end

class SafeType::EmptyValueError
end

class SafeType::Float
  def initialize(type: T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil), **args); end
end

class SafeType::Float
  def self.default(value=T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.strict(min: T.unsafe(nil), max: T.unsafe(nil)); end
end

class SafeType::Integer
  def initialize(type: T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil), **args); end
end

class SafeType::Integer
  def self.default(value=T.unsafe(nil), min: T.unsafe(nil), max: T.unsafe(nil)); end

  def self.strict(min: T.unsafe(nil), max: T.unsafe(nil)); end
end

class SafeType::InvalidRuleError
  def initialize(); end
end

class SafeType::InvalidRuleError
end

class SafeType::Rule
  def after(input); end

  def before(input); end

  def coerce(input, key=T.unsafe(nil)); end

  def initialize(type:, default: T.unsafe(nil), required: T.unsafe(nil), **args); end

  def is_valid?(input); end
end

class SafeType::Rule
  def self.coerce(input); end

  def self.default(); end

  def self.strict(); end
end

class SafeType::String
  def initialize(type: T.unsafe(nil), min_length: T.unsafe(nil), max_length: T.unsafe(nil), **args); end
end

class SafeType::String
  def self.default(value=T.unsafe(nil), min_length: T.unsafe(nil), max_length: T.unsafe(nil)); end

  def self.strict(min_length: T.unsafe(nil), max_length: T.unsafe(nil)); end
end

class SafeType::Symbol
  def initialize(type: T.unsafe(nil), min_length: T.unsafe(nil), max_length: T.unsafe(nil), **args); end
end

class SafeType::Symbol
  def self.default(value=T.unsafe(nil), min_length: T.unsafe(nil), max_length: T.unsafe(nil)); end

  def self.strict(min_length: T.unsafe(nil), max_length: T.unsafe(nil)); end
end

class SafeType::Time
  def initialize(type: T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), **args); end
end

class SafeType::Time
  def self.default(value=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil)); end

  def self.strict(from: T.unsafe(nil), to: T.unsafe(nil)); end
end

class SafeType::ValidationError
  def desired_type(); end

  def initialize(value, desired_type, key=T.unsafe(nil)); end

  def key(); end

  def value(); end
end

class SafeType::ValidationError
end

module SafeType
  def self.coerce(input, rule, coerce_key=T.unsafe(nil)); end

  def self.coerce!(input, rule); end
end

module SafeYAML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  MULTI_ARGUMENT_YAML_LOAD = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PREDEFINED_TAGS = ::T.let(nil, ::T.untyped)
  YAML_ENGINE = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Deep
end

class SafeYAML::Deep
  def self.copy(object); end

  def self.freeze(object); end
end

class SafeYAML::LibyamlChecker
  KNOWN_PATCHED_LIBYAML_VERSIONS = ::T.let(nil, ::T.untyped)
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  SAFE_LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
end

class SafeYAML::LibyamlChecker
  def self.libyaml_patched?(); end

  def self.libyaml_version_ok?(); end
end

class SafeYAML::Parse
end

class SafeYAML::Parse::Date
  DATE_MATCHER = ::T.let(nil, ::T.untyped)
  MICROSECONDS_PER_SECOND = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SEC_FRACTION_MULTIPLIER = ::T.let(nil, ::T.untyped)
  TIME_MATCHER = ::T.let(nil, ::T.untyped)
  TO_TIME_AVAILABLE = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Date
  def self.value(value); end
end

class SafeYAML::Parse::Hexadecimal
  MATCHER = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Hexadecimal
  def self.value(value); end
end

class SafeYAML::Parse::Sexagesimal
  FLOAT_MATCHER = ::T.let(nil, ::T.untyped)
  INTEGER_MATCHER = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Sexagesimal
  def self.value(value); end
end

class SafeYAML::Parse
end

class SafeYAML::PsychHandler
  def add_to_current_structure(value, anchor=T.unsafe(nil), quoted=T.unsafe(nil), tag=T.unsafe(nil)); end

  def end_current_structure(); end

  def initialize(options, &block); end

  def result(); end
end

class SafeYAML::PsychHandler
end

class SafeYAML::PsychResolver
  def get_node_tag(node); end

  def get_node_type(node); end

  def get_node_value(node); end

  def initialize(options=T.unsafe(nil)); end

  def native_resolve(node); end

  def resolve_alias(node); end

  def resolve_root(root); end

  def value_is_quoted?(node); end
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::PsychResolver
end

class SafeYAML::Resolver
  def get_and_check_node_tag(node); end

  def initialize(options); end

  def options(); end

  def resolve_map(node); end

  def resolve_node(node); end

  def resolve_scalar(node); end

  def resolve_seq(node); end

  def tag_is_whitelisted?(tag); end
end

class SafeYAML::Resolver
end

class SafeYAML::SafeToRubyVisitor
  def accept(node); end

  def initialize(resolver); end
  INITIALIZE_ARITY = ::T.let(nil, ::T.untyped)
end

class SafeYAML::SafeToRubyVisitor
end

class SafeYAML::Transform
  TRANSFORMERS = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToBoolean
  include ::SafeYAML::Transform::TransformationMap
  def transform?(value); end
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToBoolean
  extend ::SafeYAML::Transform::TransformationMap::ClassMethods
end

class SafeYAML::Transform::ToDate
  def transform?(value); end
end

class SafeYAML::Transform::ToDate
end

class SafeYAML::Transform::ToFloat
  def transform?(value); end

  def try_edge_cases?(value); end
  Infinity = ::T.let(nil, ::T.untyped)
  MATCHER = ::T.let(nil, ::T.untyped)
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToFloat
end

class SafeYAML::Transform::ToInteger
  def transform?(value); end

  def try_edge_cases?(value); end
  MATCHERS = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToInteger
end

class SafeYAML::Transform::ToNil
  include ::SafeYAML::Transform::TransformationMap
  def transform?(value); end
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToNil
  extend ::SafeYAML::Transform::TransformationMap::ClassMethods
end

class SafeYAML::Transform::ToSymbol
  def transform?(value, options=T.unsafe(nil)); end
end

class SafeYAML::Transform::ToSymbol
end

module SafeYAML::Transform::TransformationMap
end

class SafeYAML::Transform::TransformationMap::CaseAgnosticMap
  def [](key); end

  def include?(key); end

  def initialize(*args); end
end

class SafeYAML::Transform::TransformationMap::CaseAgnosticMap
end

module SafeYAML::Transform::TransformationMap::ClassMethods
  def set_predefined_values(predefined_values); end
end

module SafeYAML::Transform::TransformationMap::ClassMethods
end

module SafeYAML::Transform::TransformationMap
  def self.included(base); end
end

class SafeYAML::Transform
  def self.to_guessed_type(value, quoted=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.to_proper_type(value, quoted=T.unsafe(nil), tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module SafeYAML
  def self.load(yaml, filename=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.load_file(filename, options=T.unsafe(nil)); end

  def self.restore_defaults!(); end

  def self.tag_is_explicitly_trusted?(tag); end

  def self.tag_safety_check!(tag, options); end

  def self.whitelist!(*classes); end

  def self.whitelist_class!(klass); end
end

module Sass
  ROOT_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sass::BaseEnvironment
  def _function(name); end

  def _mixin(name); end

  def _var(name); end

  def caller(); end

  def caller=(caller); end

  def content(); end

  def content=(content); end

  def function(name); end

  def global?(); end

  def global_env(); end

  def initialize(parent=T.unsafe(nil), options=T.unsafe(nil)); end

  def is_function_global?(name); end

  def is_mixin_global?(name); end

  def is_var_global?(name); end

  def mixin(name); end

  def options(); end

  def selector(); end

  def selector=(selector); end

  def stack(); end

  def var(name); end
end

class Sass::BaseEnvironment
  def self.inherited_hash_accessor(name); end

  def self.inherited_hash_reader(name); end

  def self.inherited_hash_writer(name); end
end

module Sass::CacheStores
end

class Sass::CacheStores::Base
  def _retrieve(key, version, sha); end

  def _store(key, version, sha, contents); end

  def key(sass_dirname, sass_basename); end

  def retrieve(key, sha); end

  def store(key, sha, root); end
end

class Sass::CacheStores::Base
end

class Sass::CacheStores::Chain
  def initialize(*caches); end

  def store(key, sha, obj); end
end

class Sass::CacheStores::Chain
end

class Sass::CacheStores::Filesystem
  def cache_location(); end

  def cache_location=(cache_location); end

  def initialize(cache_location); end
end

class Sass::CacheStores::Filesystem
end

class Sass::CacheStores::Memory
  def _dump(depth); end

  def reset!(); end

  def store(key, sha, obj); end
end

class Sass::CacheStores::Memory
  def self._load(repr); end
end

module Sass::CacheStores
end

class Sass::Callable
  def args(); end

  def args=(_); end

  def environment(); end

  def environment=(_); end

  def has_content(); end

  def has_content=(_); end

  def name(); end

  def name=(_); end

  def origin(); end

  def origin=(_); end

  def splat(); end

  def splat=(_); end

  def tree(); end

  def tree=(_); end

  def type(); end

  def type=(_); end
end

class Sass::Callable
  def self.[](*_); end

  def self.members(); end
end

class Sass::Deprecation
  def warn(filename, line, column_or_message, message=T.unsafe(nil)); end
end

class Sass::Deprecation
  def self.allow_double_warnings(); end
end

class Sass::Engine
  def _dependencies(seen, engines); end

  def dependencies(); end

  def initialize(template, options=T.unsafe(nil)); end

  def options(); end

  def render(); end

  def render_with_sourcemap(sourcemap_uri); end

  def source_encoding(); end

  def to_css(); end

  def to_tree(); end
  COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  CONTENT_RE = ::T.let(nil, ::T.untyped)
  CSS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  DIRECTIVE_CHAR = ::T.let(nil, ::T.untyped)
  ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
  FUNCTION_RE = ::T.let(nil, ::T.untyped)
  MIXIN_DEFINITION_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_DEF_RE = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_RE = ::T.let(nil, ::T.untyped)
  PROPERTY_CHAR = ::T.let(nil, ::T.untyped)
  PROPERTY_OLD = ::T.let(nil, ::T.untyped)
  SASS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  SASS_LOUD_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class Sass::Engine::Line
  def comment?(); end
end

class Sass::Engine::Line
end

class Sass::Engine
  def self.for_file(filename, options); end

  def self.normalize_options(options); end

  def self.parse_interp(text, line, offset, options); end
end

class Sass::Environment
  def parent(); end

  def set_function(name, value); end

  def set_global_function(name, value); end

  def set_global_mixin(name, value); end

  def set_global_var(name, value); end

  def set_local_function(name, value); end

  def set_local_mixin(name, value); end

  def set_local_var(name, value); end

  def set_mixin(name, value); end

  def set_var(name, value); end

  def try_set_function(name, value); end

  def try_set_mixin(name, value); end

  def try_set_var(name, value); end
end

class Sass::Environment
end

module Sass::Features
  def add_feature(feature_name); end

  def has_feature?(feature_name); end
  KNOWN_FEATURES = ::T.let(nil, ::T.untyped)
end

module Sass::Features
end

module Sass::Importers
end

class Sass::Importers::Base
  def directories_to_watch(); end

  def find(uri, options); end

  def find_relative(uri, base, options); end

  def key(uri, options); end

  def mtime(uri, options); end

  def public_url(uri, sourcemap_directory); end

  def watched_file?(filename); end
end

class Sass::Importers::Base
end

class Sass::Importers::DeprecatedPath
  def deprecation_warning(); end

  def find(*args); end
end

class Sass::Importers::DeprecatedPath
end

class Sass::Importers::Filesystem
  def eql?(other); end

  def escape_glob_characters(name); end

  def extensions(); end

  def find(name, options); end

  def find_real_file(dir, name, options); end

  def find_relative(name, base, options); end

  def initialize(root); end

  def key(name, options); end

  def mtime(name, options); end

  def possible_files(name); end

  def public_url(name, sourcemap_directory); end

  def remove_root(name); end

  def root(); end

  def root=(root); end

  def split(name); end
  REDUNDANT_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Sass::Importers::Filesystem
end

module Sass::Importers
end

module Sass::Logger
end

class Sass::Logger::Base
  include ::Sass::Logger::LogLevel
  def _log(level, message); end

  def capture(); end

  def debug(message); end

  def disabled(); end

  def disabled=(disabled); end

  def error(message); end

  def info(message); end

  def initialize(log_level=T.unsafe(nil), io=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def log(level, message); end

  def log_level(); end

  def log_level=(log_level); end

  def logging_level?(level); end

  def trace(message); end

  def warn(message); end
end

class Sass::Logger::Base
  extend ::Sass::Logger::LogLevel::ClassMethods
end

class Sass::Logger::Delayed
  def flush(); end

  def initialize(inner); end

  def uninstall!(); end
end

class Sass::Logger::Delayed
  def self.install!(); end
end

module Sass::Logger::LogLevel
end

module Sass::Logger::LogLevel::ClassMethods
  def define_logger(name, options=T.unsafe(nil)); end

  def inherited(subclass); end

  def log_level(name, options=T.unsafe(nil)); end

  def log_level?(level, min_level); end

  def log_levels(); end

  def log_levels=(log_levels); end
end

module Sass::Logger::LogLevel::ClassMethods
end

module Sass::Logger::LogLevel
  def self.included(base); end
end

module Sass::Logger
end

module Sass::Media
end

class Sass::Media::Query
  def deep_copy(); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(modifier, type, expressions); end

  def merge(other); end

  def modifier(); end

  def modifier=(modifier); end

  def resolved_modifier(); end

  def resolved_type(); end

  def to_a(); end

  def to_css(); end

  def to_src(options); end

  def type(); end

  def type=(type); end
end

class Sass::Media::Query
end

class Sass::Media::QueryList
  def deep_copy(); end

  def initialize(queries); end

  def merge(other); end

  def queries(); end

  def queries=(queries); end

  def to_a(); end

  def to_css(); end

  def to_src(options); end
end

class Sass::Media::QueryList
end

module Sass::Media
  def self._interp_to_src(interp, options); end
end

module Sass::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sass::Rails::CacheStore
  def environment(); end

  def initialize(environment); end

  def path_to(key); end
end

class Sass::Rails::CacheStore
end

class Sass::Rails::Logger
end

class Sass::Rails::Logger
end

class Sass::Rails::Railtie
end

class Sass::Rails::Railtie
end

class Sass::Rails::SassImporter
  include ::Sass::Rails::SassImporter::Deprecated
  include ::Sass::Rails::SassImporter::ERB
  include ::Sass::Rails::SassImporter::Globbing
end

module Sass::Rails::SassImporter::Deprecated
  def extensions(); end

  def find(*args); end

  def find_relative(*args); end
end

module Sass::Rails::SassImporter::Deprecated
end

module Sass::Rails::SassImporter::ERB
  def erb_extensions(); end

  def extensions(); end

  def find(*args); end

  def find_relative(*args); end
end

module Sass::Rails::SassImporter::ERB
end

module Sass::Rails::SassImporter::Globbing
  def find(name, options); end

  def find_relative(name, base, options); end
  GLOB = ::T.let(nil, ::T.untyped)
end

module Sass::Rails::SassImporter::Globbing
end

class Sass::Rails::SassImporter
end

class Sass::Rails::SassTemplate
  def evaluate(context, locals, &block); end

  def initialize_engine(); end

  def syntax(); end
end

class Sass::Rails::SassTemplate
  def self.engine_initialized?(); end
end

class Sass::Rails::ScssTemplate
end

class Sass::Rails::ScssTemplate
end

module Sass::Rails
end

class Sass::ReadOnlyEnvironment
end

class Sass::ReadOnlyEnvironment
end

module Sass::SCSS
end

class Sass::SCSS::CssParser
end

class Sass::SCSS::CssParser
end

class Sass::SCSS::Parser
  include ::Sass::SCSS::RX
  def initialize(str, filename, importer, line=T.unsafe(nil), offset=T.unsafe(nil)); end

  def offset(); end

  def offset=(offset); end

  def parse(); end

  def parse_at_root_query(); end

  def parse_declaration_value(); end

  def parse_interp_ident(); end

  def parse_media_query_list(); end

  def parse_supports_clause(); end

  def parse_supports_condition(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PREFIXED_DIRECTIVES = ::T.let(nil, ::T.untyped)
  TOK_NAMES = ::T.let(nil, ::T.untyped)
end

class Sass::SCSS::Parser
  def self.expected(scanner, expected, line); end

  def self.sass_script_parser(); end

  def self.sass_script_parser=(sass_script_parser); end
end

module Sass::SCSS::RX
  ANY = ::T.let(nil, ::T.untyped)
  CDC = ::T.let(nil, ::T.untyped)
  CDO = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DASHMATCH = ::T.let(nil, ::T.untyped)
  DOMAIN = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  GREATER = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  HASH = ::T.let(nil, ::T.untyped)
  HEXCOLOR = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_HYPHEN_INTERP = ::T.let(nil, ::T.untyped)
  IDENT_START = ::T.let(nil, ::T.untyped)
  IMPORTANT = ::T.let(nil, ::T.untyped)
  INCLUDES = ::T.let(nil, ::T.untyped)
  INTERP_START = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NL = ::T.let(nil, ::T.untyped)
  NMCHAR = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  NOT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPTIONAL = ::T.let(nil, ::T.untyped)
  PERCENTAGE = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  PREFIXMATCH = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_COMMENT = ::T.let(nil, ::T.untyped)
  STATIC_COMPONENT = ::T.let(nil, ::T.untyped)
  STATIC_SELECTOR = ::T.let(nil, ::T.untyped)
  STATIC_VALUE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRING1 = ::T.let(nil, ::T.untyped)
  STRING1_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING2 = ::T.let(nil, ::T.untyped)
  STRING2_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING_NOINTERP = ::T.let(nil, ::T.untyped)
  SUBSTRINGMATCH = ::T.let(nil, ::T.untyped)
  SUFFIXMATCH = ::T.let(nil, ::T.untyped)
  TILDE = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
  UNICODERANGE = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  UNITLESS_NUMBER = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URLCHAR = ::T.let(nil, ::T.untyped)
  URL_PREFIX = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
  W = ::T.let(nil, ::T.untyped)
end

module Sass::SCSS::RX
  def self.escape_char(c); end

  def self.escape_ident(str); end

  def self.quote(str, flags=T.unsafe(nil)); end
end

class Sass::SCSS::StaticParser
  def initialize(str, filename, importer, line=T.unsafe(nil), offset=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_keyframes_selector(); end

  def parse_selector(); end

  def parse_static_at_root_query(); end
  PREFIXED_SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Sass::SCSS::StaticParser
end

module Sass::SCSS
end

module Sass::Script
  CONST_RENAMES = ::T.let(nil, ::T.untyped)
  MATCH = ::T.let(nil, ::T.untyped)
  VALIDATE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::CssLexer
end

class Sass::Script::CssLexer
end

class Sass::Script::CssParser
  def div(); end
end

class Sass::Script::CssParser
end

module Sass::Script::Functions
  include ::Sprockets::SassProcessor::Functions
  def abs(number); end

  def adjust_color(color, kwargs); end

  def adjust_hue(color, degrees); end

  def alpha(*args); end

  def append(list, val, separator=T.unsafe(nil)); end

  def blue(color); end

  def call(name, *args); end

  def ceil(number); end

  def change_color(color, kwargs); end

  def comparable(number1, number2); end

  def complement(color); end

  def content_exists(); end

  def counter(*args); end

  def counters(*args); end

  def darken(color, amount); end

  def desaturate(color, amount); end

  def fade_in(color, amount); end

  def fade_out(color, amount); end

  def feature_exists(feature); end

  def floor(number); end

  def function_exists(name); end

  def get_function(name, kwargs=T.unsafe(nil)); end

  def global_variable_exists(name); end

  def grayscale(color); end

  def green(color); end

  def hsl(hue, saturation=T.unsafe(nil), lightness=T.unsafe(nil)); end

  def hsla(hue, saturation=T.unsafe(nil), lightness=T.unsafe(nil), alpha=T.unsafe(nil)); end

  def hue(color); end

  def ie_hex_str(color); end

  def if(condition, if_true, if_false); end

  def index(list, value); end

  def inspect(value); end

  def invert(color, weight=T.unsafe(nil)); end

  def is_bracketed(list); end

  def is_superselector(sup, sub); end

  def join(list1, list2, separator=T.unsafe(nil), bracketed=T.unsafe(nil), kwargs=T.unsafe(nil), *rest); end

  def keywords(args); end

  def length(list); end

  def lighten(color, amount); end

  def lightness(color); end

  def list_separator(list); end

  def map_get(map, key); end

  def map_has_key(map, key); end

  def map_keys(map); end

  def map_merge(map1, map2); end

  def map_remove(map, *keys); end

  def map_values(map); end

  def max(*values); end

  def min(*numbers); end

  def mix(color1, color2, weight=T.unsafe(nil)); end

  def mixin_exists(name); end

  def nth(list, n); end

  def opacify(color, amount); end

  def opacity(color); end

  def percentage(number); end

  def quote(string); end

  def random(limit=T.unsafe(nil)); end

  def red(color); end

  def rgb(red, green=T.unsafe(nil), blue=T.unsafe(nil)); end

  def rgba(*args); end

  def round(number); end

  def saturate(color, amount=T.unsafe(nil)); end

  def saturation(color); end

  def scale_color(color, kwargs); end

  def selector_append(*selectors); end

  def selector_extend(selector, extendee, extender); end

  def selector_nest(*selectors); end

  def selector_parse(selector); end

  def selector_replace(selector, original, replacement); end

  def selector_unify(selector1, selector2); end

  def set_nth(list, n, value); end

  def simple_selectors(selector); end

  def str_index(string, substring); end

  def str_insert(original, insert, index); end

  def str_length(string); end

  def str_slice(string, start_at, end_at=T.unsafe(nil)); end

  def to_lower_case(string); end

  def to_upper_case(string); end

  def transparentize(color, amount); end

  def type_of(value); end

  def unique_id(); end

  def unit(number); end

  def unitless(number); end

  def unquote(string); end

  def variable_exists(name); end

  def zip(*lists); end
end

class Sass::Script::Functions::EvaluationContext
  include ::Sass::Script::Functions
  include ::Sprockets::SassProcessor::Functions
  include ::Sass::Script::Value::Helpers
  def assert_integer(number, name=T.unsafe(nil)); end

  def assert_type(value, type, name=T.unsafe(nil)); end

  def assert_unit(number, unit, name=T.unsafe(nil)); end

  def environment(); end

  def initialize(environment); end

  def options(); end

  def perform(node, env=T.unsafe(nil)); end
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Functions::EvaluationContext
end

class Sass::Script::Functions::Signature
  def args(); end

  def args=(_); end

  def delayed_args(); end

  def delayed_args=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def var_args(); end

  def var_args=(_); end

  def var_kwargs(); end

  def var_kwargs=(_); end
end

class Sass::Script::Functions::Signature
  def self.[](*_); end

  def self.members(); end
end

module Sass::Script::Functions
  def self.callable?(_); end

  def self.declare(method_name, args, options=T.unsafe(nil)); end

  def self.random_number_generator(); end

  def self.random_seed=(seed); end

  def self.signature(method_name, arg_arity, kwarg_arity); end
end

class Sass::Script::Lexer
  include ::Sass::SCSS::RX
  def after_interpolation?(); end

  def char(pos=T.unsafe(nil)); end

  def done?(); end

  def expected!(name); end

  def initialize(str, line, offset, options); end

  def line(); end

  def next(); end

  def next_char(); end

  def offset(); end

  def peek(); end

  def str(); end

  def try(); end

  def unpeek!(); end

  def whitespace?(tok=T.unsafe(nil)); end
  IDENT_OP_NAMES = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OPERATORS_REVERSE = ::T.let(nil, ::T.untyped)
  OP_NAMES = ::T.let(nil, ::T.untyped)
  PARSEABLE_NUMBER = ::T.let(nil, ::T.untyped)
  REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  STRING_REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  TOKEN_NAMES = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Lexer::Token
  def pos(); end

  def pos=(_); end

  def source_range(); end

  def source_range=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Sass::Script::Lexer::Token
  def self.[](*_); end

  def self.members(); end
end

class Sass::Script::Lexer
end

class Sass::Script::Parser
  def and_expr(); end

  def eq_or_neq(); end

  def equals(); end

  def initialize(str, line, offset, options=T.unsafe(nil)); end

  def line(); end

  def offset(); end

  def or_expr(); end

  def parse(); end

  def parse_function_definition_arglist(); end

  def parse_interpolated(warn_for_color=T.unsafe(nil)); end

  def parse_mixin_definition_arglist(); end

  def parse_mixin_include_arglist(); end

  def parse_string(); end

  def parse_until(tokens); end

  def plus_or_minus(); end

  def relational(); end

  def times_div_or_mod(); end

  def unary_div(); end

  def unary_minus(); end

  def unary_not(); end

  def unary_plus(); end
  ASSOCIATIVE = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Parser
  def self.associative?(op); end

  def self.parse(*args); end

  def self.precedence_of(op); end
end

module Sass::Script::Tree
end

class Sass::Script::Tree::Funcall
  def args(); end

  def callable(); end

  def initialize(name_or_callable, args, keywords, splat, kwarg_splat); end

  def keywords(); end

  def kwarg_splat(); end

  def kwarg_splat=(kwarg_splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end

  def to_literal(args); end

  def to_value(args); end
end

class Sass::Script::Tree::Funcall
end

class Sass::Script::Tree::Interpolation
  def after(); end

  def before(); end

  def deprecation(); end

  def initialize(before, mid, after, wb, wa, opts=T.unsafe(nil)); end

  def mid(); end

  def originally_text(); end

  def to_quoted_equivalent(); end

  def to_string_interpolation(node_or_interp); end

  def warn_for_color(); end

  def whitespace_after(); end

  def whitespace_before(); end
end

class Sass::Script::Tree::Interpolation
end

class Sass::Script::Tree::ListLiteral
  def bracketed(); end

  def elements(); end

  def initialize(elements, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def separator(); end
end

class Sass::Script::Tree::ListLiteral
end

class Sass::Script::Tree::Literal
  def initialize(value); end

  def value(); end
end

class Sass::Script::Tree::Literal
end

class Sass::Script::Tree::MapLiteral
  def initialize(pairs); end

  def inspect(opts=T.unsafe(nil)); end

  def pairs(); end
end

class Sass::Script::Tree::MapLiteral
end

class Sass::Script::Tree::Node
  def _perform(environment); end

  def children(); end

  def dasherize(s, opts); end

  def deep_copy(); end

  def filename(); end

  def filename=(filename); end

  def force_division!(); end

  def line(); end

  def line=(line); end

  def options(); end

  def options=(options); end

  def opts(value); end

  def perform(environment); end

  def source_range(); end

  def source_range=(source_range); end

  def to_sass(opts=T.unsafe(nil)); end
end

class Sass::Script::Tree::Node
end

class Sass::Script::Tree::Operation
  def initialize(operand1, operand2, operator); end

  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Sass::Script::Tree::Operation
end

class Sass::Script::Tree::Selector
end

class Sass::Script::Tree::Selector
end

class Sass::Script::Tree::StringInterpolation
  def after(); end

  def before(); end

  def initialize(before, mid, after); end

  def mid(); end

  def quote(); end

  def type(); end
end

class Sass::Script::Tree::StringInterpolation
end

class Sass::Script::Tree::UnaryOperation
  def initialize(operand, operator); end

  def operand(); end

  def operator(); end
end

class Sass::Script::Tree::UnaryOperation
end

class Sass::Script::Tree::Variable
  def initialize(name); end

  def inspect(opts=T.unsafe(nil)); end

  def name(); end

  def underscored_name(); end
end

class Sass::Script::Tree::Variable
end

module Sass::Script::Tree
end

module Sass::Script::Value
end

class Sass::Script::Value::ArgList
  def initialize(value, keywords, separator); end

  def keywords(); end

  def keywords_accessed(); end

  def keywords_accessed=(keywords_accessed); end
end

class Sass::Script::Value::ArgList
end

class Sass::Script::Value::Base
  def ==(other); end

  def _perform(environment); end

  def assert_int!(); end

  def bracketed(); end

  def div(other); end

  def eq(other); end

  def eql?(other); end

  def initialize(value=T.unsafe(nil)); end

  def minus(other); end

  def neq(other); end

  def null?(); end

  def options(); end

  def options=(options); end

  def plus(other); end

  def separator(); end

  def single_eq(other); end

  def source_range(); end

  def source_range=(source_range); end

  def to_a(); end

  def to_bool(); end

  def to_h(); end

  def to_i(); end

  def to_s(opts=T.unsafe(nil)); end

  def to_sass(opts=T.unsafe(nil)); end

  def unary_div(); end

  def unary_minus(); end

  def unary_not(); end

  def unary_plus(); end

  def value(); end

  def with_contents(contents, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end
end

class Sass::Script::Value::Base
end

class Sass::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Bool
  def self.new(value); end
end

class Sass::Script::Value::Callable
  def initialize(callable); end

  def to_sass(); end
end

class Sass::Script::Value::Callable
end

class Sass::Script::Value::Color
  def alpha(); end

  def alpha?(); end

  def blue(); end

  def green(); end

  def hsl(); end

  def hsla(); end

  def hue(); end

  def initialize(attrs, representation=T.unsafe(nil), allow_both_rgb_and_hsl=T.unsafe(nil)); end

  def lightness(); end

  def mod(other); end

  def name(); end

  def red(); end

  def representation(); end

  def rgb(); end

  def rgba(); end

  def saturation(); end

  def times(other); end

  def with(attrs); end
  ALTERNATE_COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES_REVERSE = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Color
  def self.from_hex(hex_string, alpha=T.unsafe(nil)); end

  def self.int_to_rgba(color); end
end

class Sass::Script::Value::Function
  def initialize(function); end
end

class Sass::Script::Value::Function
end

module Sass::Script::Value::Helpers
  def bool(value); end

  def calc?(literal); end

  def hex_color(value, alpha=T.unsafe(nil)); end

  def hsl_color(hue, saturation, lightness, alpha=T.unsafe(nil)); end

  def identifier(str); end

  def list(*elements, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def map(hash); end

  def null(); end

  def number(number, unit_string=T.unsafe(nil)); end

  def parse_complex_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_compound_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def quoted_string(str); end

  def rgb_color(red, green, blue, alpha=T.unsafe(nil)); end

  def special_number?(literal); end

  def unquoted_string(str); end

  def var?(literal); end
  VALID_UNIT = ::T.let(nil, ::T.untyped)
end

module Sass::Script::Value::Helpers
end

class Sass::Script::Value::List
  def initialize(value, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def options=(options); end
end

class Sass::Script::Value::List
  def self.assert_valid_index(list, n); end
end

class Sass::Script::Value::Map
  def initialize(hash); end

  def inspect(opts=T.unsafe(nil)); end

  def options=(options); end
end

class Sass::Script::Value::Map
end

class Sass::Script::Value::Null
  NULL = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Null
  def self.new(); end
end

class Sass::Script::Value::Number
  def coerce(num_units, den_units); end

  def comparable_to?(other); end

  def denominator_units(); end

  def gt(other); end

  def gte(other); end

  def initialize(value, numerator_units=T.unsafe(nil), denominator_units=T.unsafe(nil)); end

  def inspect(opts=T.unsafe(nil)); end

  def int?(); end

  def is_unit?(unit); end

  def legal_units?(); end

  def lt(other); end

  def lte(other); end

  def mod(other); end

  def numerator_units(); end

  def original(); end

  def original=(original); end

  def times(other); end

  def unit_str(); end

  def unitless?(); end
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

class Sass::Script::Value::Number
  def self.basically_equal?(num1, num2); end

  def self.epsilon(); end

  def self.precision(); end

  def self.precision=(digits); end

  def self.precision_factor(); end

  def self.round(num); end
end

class Sass::Script::Value::String
  def check_deprecated_interp(); end

  def initialize(value, type=T.unsafe(nil), deprecated_interp_equivalent=T.unsafe(nil)); end

  def type(); end
end

class Sass::Script::Value::String
  def self.quote(contents, opts=T.unsafe(nil)); end

  def self.value(contents); end
end

module Sass::Script::Value
end

module Sass::Script
  def self.const_missing(name); end

  def self.parse(value, line, offset, options=T.unsafe(nil)); end
end

module Sass::Selector
  SPECIFICITY_BASE = ::T.let(nil, ::T.untyped)
end

class Sass::Selector::AbstractSequence
  def ==(other); end

  def _specificity(arr); end

  def eql?(other); end

  def filename(); end

  def filename=(filename); end

  def invisible?(); end

  def line(); end

  def line=(line); end

  def specificity(); end

  def to_s(opts=T.unsafe(nil)); end
end

class Sass::Selector::AbstractSequence
end

class Sass::Selector::Attribute
  def flags(); end

  def initialize(name, namespace, operator, value, flags); end

  def name(); end

  def namespace(); end

  def operator(); end

  def specificity(); end

  def value(); end
end

class Sass::Selector::Attribute
end

class Sass::Selector::Class
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sass::Selector::Class
end

class Sass::Selector::CommaSequence
  def contains_parent_ref?(); end

  def do_extend(extends, parent_directives=T.unsafe(nil), replace=T.unsafe(nil), seen=T.unsafe(nil), original=T.unsafe(nil)); end

  def initialize(seqs); end

  def members(); end

  def populate_extends(extends, extendee, extend_node=T.unsafe(nil), parent_directives=T.unsafe(nil), allow_compound_target=T.unsafe(nil)); end

  def resolve_parent_refs(super_cseq, implicit_parent=T.unsafe(nil)); end

  def superselector?(cseq); end

  def to_sass_script(); end

  def unify(other); end
end

class Sass::Selector::CommaSequence
end

class Sass::Selector::Element
  def initialize(name, namespace); end

  def name(); end

  def namespace(); end

  def specificity(); end
end

class Sass::Selector::Element
end

class Sass::Selector::Id
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sass::Selector::Id
end

class Sass::Selector::Parent
  def initialize(suffix=T.unsafe(nil)); end

  def suffix(); end
end

class Sass::Selector::Parent
end

class Sass::Selector::Placeholder
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sass::Selector::Placeholder
end

class Sass::Selector::Pseudo
  def arg(); end

  def initialize(syntactic_type, name, arg, selector); end

  def invisible?(); end

  def name(); end

  def normalized_name(); end

  def selector(); end

  def specificity(); end

  def superselector?(their_sseq, parents=T.unsafe(nil)); end

  def syntactic_type(); end

  def type(); end

  def with_selector(new_selector); end
  ACTUALLY_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Sass::Selector::Pseudo
end

class Sass::Selector::Sequence
  def add_sources!(sources); end

  def contains_parent_ref?(); end

  def do_extend(extends, parent_directives, replace, seen, original); end

  def initialize(seqs_and_ops); end

  def members(); end

  def resolve_parent_refs(super_cseq, implicit_parent); end

  def subjectless(); end

  def superselector?(seq); end

  def unify(other); end
end

class Sass::Selector::Sequence
end

class Sass::Selector::Simple
  def ==(other); end

  def eql?(other); end

  def equality_key(); end

  def filename(); end

  def filename=(filename); end

  def line(); end

  def line=(line); end

  def to_s(opts=T.unsafe(nil)); end

  def unify(sels); end

  def unify_namespaces(ns1, ns2); end

  def unique?(); end
end

class Sass::Selector::Simple
end

class Sass::Selector::SimpleSequence
  def base(); end

  def do_extend(extends, parent_directives, replace, seen); end

  def initialize(selectors, subject, source_range=T.unsafe(nil)); end

  def members(); end

  def members=(members); end

  def pseudo_elements(); end

  def resolve_parent_refs(super_cseq); end

  def rest(); end

  def selector_pseudo_classes(); end

  def source_range(); end

  def source_range=(source_range); end

  def sources(); end

  def sources=(sources); end

  def subject=(subject); end

  def subject?(); end

  def superselector?(their_sseq, parents=T.unsafe(nil)); end

  def unify(other); end

  def with_more_sources(sources); end
end

class Sass::Selector::SimpleSequence
end

class Sass::Selector::Universal
  def initialize(namespace); end

  def namespace(); end

  def specificity(); end
end

class Sass::Selector::Universal
end

module Sass::Selector
end

class Sass::SemiGlobalEnvironment
end

class Sass::SemiGlobalEnvironment
end

module Sass::Shared
  def balance(scanner, start, finish, count=T.unsafe(nil)); end

  def handle_interpolation(str); end

  def human_indentation(indentation, was=T.unsafe(nil)); end
end

module Sass::Shared
  extend ::Sass::Shared
end

module Sass::Source
end

class Sass::Source::Map
  def add(input, output); end

  def data(); end

  def shift_output_lines(delta); end

  def shift_output_offsets(delta); end

  def to_json(options); end
end

class Sass::Source::Map::Mapping
end

class Sass::Source::Map::Mapping
end

class Sass::Source::Map
end

class Sass::Source::Position
  def after(str); end

  def initialize(line, offset); end

  def line(); end

  def line=(line); end

  def offset(); end

  def offset=(offset); end
end

class Sass::Source::Position
end

class Sass::Source::Range
  def end_pos(); end

  def end_pos=(end_pos); end

  def file(); end

  def file=(file); end

  def importer(); end

  def importer=(importer); end

  def initialize(start_pos, end_pos, file, importer=T.unsafe(nil)); end

  def start_pos(); end

  def start_pos=(start_pos); end
end

class Sass::Source::Range
end

module Sass::Source
end

class Sass::Stack
  def frames(); end

  def with_base(filename, line); end

  def with_directive(filename, line, name); end

  def with_function(filename, line, name); end

  def with_import(filename, line); end

  def with_mixin(filename, line, name); end
end

class Sass::Stack::Frame
  def filename(); end

  def initialize(filename, line, type, name=T.unsafe(nil)); end

  def is_base?(); end

  def is_import?(); end

  def is_mixin?(); end

  def line(); end

  def name(); end

  def type(); end
end

class Sass::Stack::Frame
end

class Sass::Stack
end

module Sass::Supports
end

class Sass::Supports::Condition
  def deep_copy(); end

  def options=(options); end

  def perform(environment); end

  def to_css(); end

  def to_src(options); end
end

class Sass::Supports::Condition
end

class Sass::Supports::Declaration
  def initialize(name, value); end

  def name(); end

  def name=(name); end

  def perform(env); end

  def resolved_name(); end

  def resolved_name=(resolved_name); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def value(); end

  def value=(value); end
end

class Sass::Supports::Declaration
end

class Sass::Supports::Interpolation
  def initialize(value); end

  def perform(env); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def value(); end

  def value=(value); end
end

class Sass::Supports::Interpolation
end

class Sass::Supports::Negation
  def condition(); end

  def condition=(condition); end

  def initialize(condition); end

  def perform(env); end
end

class Sass::Supports::Negation
end

class Sass::Supports::Operator
  def initialize(left, right, op); end

  def left(); end

  def left=(left); end

  def op(); end

  def op=(op); end

  def perform(env); end

  def right(); end

  def right=(right); end
end

class Sass::Supports::Operator
end

module Sass::Supports
end

class Sass::SyntaxError
  def add_backtrace(attrs); end

  def initialize(msg, attrs=T.unsafe(nil)); end

  def modify_backtrace(attrs); end

  def sass_backtrace(); end

  def sass_backtrace=(sass_backtrace); end

  def sass_backtrace_str(default_filename=T.unsafe(nil)); end

  def sass_filename(); end

  def sass_line(); end

  def sass_mixin(); end

  def sass_template(); end

  def sass_template=(sass_template); end
end

class Sass::SyntaxError
  def self.exception_to_css(e, line_offset=T.unsafe(nil)); end
end

module Sass::Tree
end

class Sass::Tree::AtRootNode
  def exclude?(directive); end

  def exclude_node?(node); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(query=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def resolved_type(); end

  def resolved_type=(resolved_type); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end
end

class Sass::Tree::AtRootNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::CharsetNode
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Sass::Tree::CharsetNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::CommentNode
  def initialize(value, type); end

  def lines(); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
end

class Sass::Tree::CommentNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ContentNode
end

class Sass::Tree::ContentNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::CssImportNode
  def initialize(uri, query=T.unsafe(nil), supports_condition=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def resolved_query(); end

  def resolved_query=(resolved_query); end

  def resolved_uri(); end

  def resolved_uri=(resolved_uri); end

  def supports_condition(); end

  def supports_condition=(supports_condition); end

  def uri(); end

  def uri=(uri); end
end

class Sass::Tree::CssImportNode
  def self.resolved(uri); end
end

class Sass::Tree::DebugNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::DebugNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::DirectiveNode
  def group_end(); end

  def group_end=(group_end); end

  def initialize(value); end

  def name(); end

  def normalized_name(); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end

  def value(); end

  def value=(value); end
end

class Sass::Tree::DirectiveNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.resolved(value); end

  def self.visit_method(); end
end

class Sass::Tree::EachNode
  def initialize(vars, list); end

  def list(); end

  def list=(list); end

  def vars(); end
end

class Sass::Tree::EachNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ErrorNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::ErrorNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ExtendNode
  def initialize(selector, optional, selector_source_range); end

  def optional?(); end

  def resolved_selector(); end

  def resolved_selector=(resolved_selector); end

  def selector(); end

  def selector=(selector); end

  def selector_source_range(); end

  def selector_source_range=(selector_source_range); end
end

class Sass::Tree::ExtendNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ForNode
  def exclusive(); end

  def from(); end

  def from=(from); end

  def initialize(var, from, to, exclusive); end

  def to(); end

  def to=(to); end

  def var(); end
end

class Sass::Tree::ForNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::FunctionNode
  def args(); end

  def args=(args); end

  def initialize(name, args, splat); end

  def name(); end

  def normalized_name(); end

  def splat(); end

  def splat=(splat); end
end

class Sass::Tree::FunctionNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::IfNode
  def _dump(f); end

  def add_else(node); end

  def else(); end

  def else=(_); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::IfNode
  def self._load(data); end

  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ImportNode
  def css_import?(); end

  def imported_file(); end

  def imported_file=(imported_file); end

  def imported_filename(); end

  def initialize(imported_filename); end
end

class Sass::Tree::ImportNode
end

class Sass::Tree::KeyframeRuleNode
  def initialize(resolved_value); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end
end

class Sass::Tree::KeyframeRuleNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::MediaNode
  def initialize(query); end

  def query(); end

  def query=(query); end

  def resolved_query(); end

  def resolved_query=(resolved_query); end
end

class Sass::Tree::MediaNode
end

class Sass::Tree::MixinDefNode
  def args(); end

  def args=(args); end

  def has_content(); end

  def has_content=(has_content); end

  def initialize(name, args, splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end
end

class Sass::Tree::MixinDefNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::MixinNode
  def args(); end

  def args=(args); end

  def initialize(name, args, keywords, splat, kwarg_splat); end

  def keywords(); end

  def keywords=(keywords); end

  def kwarg_splat(); end

  def kwarg_splat=(kwarg_splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end
end

class Sass::Tree::MixinNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::Node
  include ::Enumerable
  def <<(child); end

  def ==(other); end

  def balance(*args); end

  def bubbles?(); end

  def children(); end

  def children=(children); end

  def css(); end

  def css_with_sourcemap(); end

  def deep_copy(); end

  def each(&blk); end

  def filename(); end

  def filename=(filename); end

  def has_children(); end

  def has_children=(has_children); end

  def invisible?(); end

  def line(); end

  def line=(line); end

  def options(); end

  def options=(options); end

  def source_range(); end

  def source_range=(source_range); end

  def style(); end

  def to_sass(options=T.unsafe(nil)); end

  def to_scss(options=T.unsafe(nil)); end
end

class Sass::Tree::Node
  def self.inherited(base); end
end

class Sass::Tree::PropNode
  def custom_property?(); end

  def declaration(opts=T.unsafe(nil), fmt=T.unsafe(nil)); end

  def initialize(name, value, prop_syntax); end

  def name(); end

  def name=(name); end

  def name_source_range(); end

  def name_source_range=(name_source_range); end

  def pseudo_class_selector_message(); end

  def resolved_name(); end

  def resolved_name=(resolved_name); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end

  def value(); end

  def value=(value); end

  def value_source_range(); end

  def value_source_range=(value_source_range); end
end

class Sass::Tree::PropNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::ReturnNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::ReturnNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::RootNode
  def initialize(template); end

  def render(); end

  def render_with_sourcemap(); end

  def template(); end
end

class Sass::Tree::RootNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::RuleNode
  def add_rules(node); end

  def continued?(); end

  def debug_info(); end

  def filename=(filename); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(rule, selector_source_range=T.unsafe(nil)); end

  def line=(line); end

  def parsed_rules(); end

  def parsed_rules=(parsed_rules); end

  def resolved_rules(); end

  def resolved_rules=(resolved_rules); end

  def rule(); end

  def rule=(rule); end

  def selector_source_range(); end

  def selector_source_range=(selector_source_range); end

  def stack_trace(); end

  def stack_trace=(stack_trace); end

  def tabs(); end

  def tabs=(tabs); end
  PARENT = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::RuleNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::SupportsNode
  def condition(); end

  def condition=(condition); end

  def initialize(name, condition); end

  def name=(name); end
end

class Sass::Tree::SupportsNode
end

class Sass::Tree::TraceNode
  def initialize(name); end

  def name(); end
end

class Sass::Tree::TraceNode
  def self.from_node(name, node); end

  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::VariableNode
  def expr(); end

  def expr=(expr); end

  def global(); end

  def guarded(); end

  def initialize(name, expr, guarded, global); end

  def name(); end
end

class Sass::Tree::VariableNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

module Sass::Tree::Visitors
end

class Sass::Tree::Visitors::Base
  def visit(node); end

  def visit_children(parent); end

  def visit_if(node); end
end

class Sass::Tree::Visitors::Base
  def self.node_name(node); end

  def self.visit(root); end
end

class Sass::Tree::Visitors::CheckNesting
  def invalid_charset_parent?(parent, child); end

  def invalid_content_parent?(parent, child); end

  def invalid_extend_parent?(parent, child); end

  def invalid_function_child?(parent, child); end

  def invalid_function_parent?(parent, child); end

  def invalid_import_parent?(parent, child); end

  def invalid_mixindef_parent?(parent, child); end

  def invalid_prop_child?(parent, child); end

  def invalid_prop_parent?(parent, child); end

  def invalid_return_parent?(parent, child); end

  def visit_import(node); end

  def visit_mixindef(node); end

  def visit_root(node); end
  CONTROL_NODES = ::T.let(nil, ::T.untyped)
  INVALID_IMPORT_PARENTS = ::T.let(nil, ::T.untyped)
  SCRIPT_NODES = ::T.let(nil, ::T.untyped)
  VALID_EXTEND_PARENTS = ::T.let(nil, ::T.untyped)
  VALID_FUNCTION_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_PARENTS = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::Visitors::CheckNesting
end

class Sass::Tree::Visitors::Convert
  def initialize(options, format); end

  def visit_atroot(node); end

  def visit_charset(node); end

  def visit_comment(node); end

  def visit_content(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sass::Tree::Visitors::Convert
  def self.visit(root, options, format); end
end

class Sass::Tree::Visitors::Cssize
  def parent(); end

  def visit_atroot(node); end

  def visit_children_without_parent(node); end

  def visit_directive(node); end

  def visit_extend(node); end

  def visit_import(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_prop(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_trace(node); end

  def with_parent(parent); end
end

class Sass::Tree::Visitors::Cssize::Bubble
  def bubbles?(); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(node); end

  def node(); end

  def node=(node); end

  def tabs(); end

  def tabs=(tabs); end
end

class Sass::Tree::Visitors::Cssize::Bubble
end

class Sass::Tree::Visitors::Cssize::Extend
  def directives(); end

  def directives=(_); end

  def extender(); end

  def extender=(_); end

  def node(); end

  def node=(_); end

  def success(); end

  def success=(_); end

  def target(); end

  def target=(_); end
end

class Sass::Tree::Visitors::Cssize::Extend
  def self.[](*_); end

  def self.members(); end
end

class Sass::Tree::Visitors::Cssize
end

class Sass::Tree::Visitors::DeepCopy
  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sass::Tree::Visitors::DeepCopy
end

class Sass::Tree::Visitors::Extend
  def initialize(extends); end

  def visit_rule(node); end
end

class Sass::Tree::Visitors::Extend
  def self.visit(root, extends); end
end

class Sass::Tree::Visitors::Perform
  def initialize(env); end

  def visit_atroot(node); end

  def visit_comment(node); end

  def visit_content(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end

  def with_environment(env); end
end

class Sass::Tree::Visitors::Perform
  def self.perform_arguments(callable, args, splat, environment); end

  def self.perform_splat(splat, performed_keywords, kwarg_splat, environment); end

  def self.visit(root, environment=T.unsafe(nil)); end
end

class Sass::Tree::Visitors::SetOptions
  def initialize(options); end

  def visit_comment(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sass::Tree::Visitors::SetOptions
  def self.visit(root, options); end
end

class Sass::Tree::Visitors::ToCss
  def erase!(chars); end

  def for_node(node, attr_prefix=T.unsafe(nil)); end

  def initialize(build_source_mapping=T.unsafe(nil)); end

  def lstrip(); end

  def output(s); end

  def prepend!(prefix); end

  def rstrip!(); end

  def source_mapping(); end

  def trailing_semicolon?(); end

  def visit_charset(node); end

  def visit_comment(node); end

  def visit_cssimport(node); end

  def visit_directive(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_prop(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def with_tabs(tabs); end
  NEWLINE = ::T.let(nil, ::T.untyped)
end

class Sass::Tree::Visitors::ToCss
end

module Sass::Tree::Visitors
end

class Sass::Tree::WarnNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::WarnNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sass::Tree::WhileNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sass::Tree::WhileNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

module Sass::Tree
end

class Sass::UnitConversionError
end

class Sass::UnitConversionError
end

module Sass::Util
  ATOMIC_WRITE_MUTEX = ::T.let(nil, ::T.untyped)
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_DIGIT_MAP = ::T.let(nil, ::T.untyped)
  CHARSET_REGEXP = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
  UTF_16BE_BOM = ::T.let(nil, ::T.untyped)
  UTF_16LE_BOM = ::T.let(nil, ::T.untyped)
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

class Sass::Util::MultibyteStringScanner
  def byte_matched_size(); end

  def byte_pos(); end

  def check(pattern); end

  def check_until(pattern); end

  def initialize(str); end

  def match?(pattern); end

  def peek(len); end

  def peep(len); end

  def pos=(n); end

  def scan(pattern); end

  def scan_full(pattern, advance_pointer_p, return_string_p); end

  def scan_until(pattern); end

  def search_full(pattern, advance_pointer_p, return_string_p); end

  def skip(pattern); end

  def skip_until(pattern); end

  def string=(str); end
end

class Sass::Util::MultibyteStringScanner
  def self.new(str); end
end

class Sass::Util::NormalizedMap
  def [](k); end

  def []=(k, v); end

  def as_stored(); end

  def delete(k); end

  def denormalize(key); end

  def each(&blk); end

  def empty?(); end

  def has_key?(k); end

  def initialize(map=T.unsafe(nil)); end

  def keys(); end

  def map(); end

  def method_missing(method, *args, &block); end

  def normalize(key); end

  def size(); end

  def sort_by(); end

  def to_a(); end

  def to_hash(); end

  def update(map); end

  def values(); end
end

class Sass::Util::NormalizedMap
end

class Sass::Util::StaticConditionalContext
  def initialize(set); end

  def method_missing(name, *args); end
end

class Sass::Util::StaticConditionalContext
end

class Sass::Util::SubsetMap
  def [](set); end

  def []=(set, value); end

  def each_value(); end

  def empty?(); end

  def get(set); end
end

class Sass::Util::SubsetMap
end

module Sass::Util
  extend ::Sass::Util
end

module Sass::Version
  def version(); end
end

module Sass::Version
end

module Sass
  extend ::Sass::Version
  extend ::Sass::Features
  def self.compile(contents, options=T.unsafe(nil)); end

  def self.compile_file(filename, *args); end

  def self.load_paths(); end

  def self.logger(); end

  def self.logger=(l); end

  def self.tests_running(); end

  def self.tests_running=(tests_running); end
end

module Sawyer
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def allow_undefined_methods(); end

  def allow_undefined_methods=(allow_undefined_methods); end

  def allow_undefined_methods?(); end

  def call(method, url, data=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_body(str); end

  def encode_body(data); end

  def expand_url(url, options=T.unsafe(nil)); end

  def initialize(endpoint, options=T.unsafe(nil)); end

  def links_parser(); end

  def links_parser=(links_parser); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def parse_links(data); end

  def rels(); end

  def root(); end

  def start(); end

  def to_yaml_properties(); end
  NO_BODY = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def self.decode(data); end

  def self.encode(data); end

  def self.serializer(); end

  def self.serializer=(serializer); end
end

class Sawyer::Error
end

class Sawyer::Error
end

module Sawyer::LinkParsers
end

class Sawyer::LinkParsers::Hal
  def parse(data); end
end

class Sawyer::LinkParsers::Hal
end

class Sawyer::LinkParsers::Simple
  def parse(data); end
  LINK_REGEX = ::T.let(nil, ::T.untyped)
end

class Sawyer::LinkParsers::Simple
end

module Sawyer::LinkParsers
end

class Sawyer::Relation
  def agent(); end

  def available_methods(); end

  def call(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil)); end

  def head(options=T.unsafe(nil)); end

  def href_template(); end

  def initialize(agent, name, href, method=T.unsafe(nil)); end

  def method(); end

  def name(); end

  def options(data=T.unsafe(nil), opt=T.unsafe(nil)); end

  def patch(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def post(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def put(data=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Sawyer::Relation::Map
  def <<(rel); end

  def [](key); end

  def keys(); end

  def size(); end

  def to_h(); end

  def to_hash(); end
end

class Sawyer::Relation::Map
end

class Sawyer::Relation
  def self.from_link(agent, name, options); end

  def self.from_links(agent, index, rels=T.unsafe(nil)); end
end

class Sawyer::Resource
  include ::Enumerable
  def [](method); end

  def []=(method, value); end

  def _agent(); end

  def _fields(); end

  def _rels(); end

  def attrs(); end

  def each(&block); end

  def initialize(agent, data=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def method_missing(method, *args); end

  def process_value(value); end

  def to_attrs(); end

  def to_h(); end

  def to_hash(); end

  def to_yaml_properties(); end
  ATTR_PREDICATE = ::T.let(nil, ::T.untyped)
  ATTR_SETTER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
end

class Sawyer::Resource
  def self.attr_accessor(*attrs); end
end

class Sawyer::Response
  def agent(); end

  def body(); end

  def data(); end

  def env(); end

  def headers(); end

  def initialize(agent, res, options=T.unsafe(nil)); end

  def process_data(data); end

  def process_rels(); end

  def rels(); end

  def status(); end

  def time(); end

  def timing(); end
end

class Sawyer::Response
end

class Sawyer::Serializer
  def decode(data); end

  def decode_hash(hash); end

  def decode_hash_value(key, value); end

  def decode_object(data); end

  def dump(data); end

  def encode(data); end

  def encode_hash(hash); end

  def encode_object(data); end

  def initialize(format, dump_method_name=T.unsafe(nil), load_method_name=T.unsafe(nil)); end

  def load(data); end

  def time_field?(key, value); end
end

class Sawyer::Serializer
  def self.any_json(); end

  def self.json(); end

  def self.message_pack(); end

  def self.multi_json(); end

  def self.yajl(); end
end

module Sawyer
end

ScanError = StringScanner::Error

class SchemaConstraintsCleanup
end

module SecureCompare
  VERSION = ::T.let(nil, ::T.untyped)
end

module SecureCompare
  def self.compare(a, b); end

  def self.secure_compare(a, b); end
end

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end

  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class Shipit::Api::BaseController
  include ::Shipit::Api::Rendering
  include ::Shipit::Api::Cacheable
  include ::Shipit::Api::Paginable
  def default_order(); end

  def default_order=(val); end

  def default_order?(); end

  def default_page_size(); end

  def default_page_size=(val); end

  def default_page_size?(); end

  def index(); end

  def max_page_size(); end

  def max_page_size=(val); end

  def max_page_size?(); end
end

class Shipit::Api::BaseController
  def self.default_order(); end

  def self.default_order=(val); end

  def self.default_order?(); end

  def self.default_page_size(); end

  def self.default_page_size=(val); end

  def self.default_page_size?(); end

  def self.max_page_size(); end

  def self.max_page_size=(val); end

  def self.max_page_size?(); end

  def self.require_permission(operation, scope, options=T.unsafe(nil)); end
end

class Shipit::Api::CCMenuController
end

class Shipit::Api::CommitsController
end

class Shipit::Api::DeploysController
end

class Shipit::Api::DeploysController::CreateParameters
end

class Shipit::Api::DeploysController::CreateParameters
end

class Shipit::Api::HooksController
end

class Shipit::Api::HooksController::CreateParameters
end

class Shipit::Api::HooksController::CreateParameters
end

class Shipit::Api::HooksController::UpdateParameters
end

class Shipit::Api::HooksController::UpdateParameters
end

class Shipit::Api::LocksController
end

class Shipit::Api::LocksController::CreateParameters
end

class Shipit::Api::LocksController::CreateParameters
end

class Shipit::Api::LocksController::UpdateParameters
end

class Shipit::Api::LocksController::UpdateParameters
end

class Shipit::Api::OutputsController
end

module Shipit::Api::Paginable
  extend ::ActiveSupport::Concern
end

class Shipit::Api::PullRequestsController
end

class Shipit::Api::ReleaseStatusesController
end

class Shipit::Api::ReleaseStatusesController::CreateParameters
end

class Shipit::Api::ReleaseStatusesController::CreateParameters
end

class Shipit::Api::StacksController
end

class Shipit::Api::StacksController::CreateParameters
end

class Shipit::Api::StacksController::CreateParameters
end

class Shipit::Api::TasksController
end

class Shipit::Api::TasksController::TriggerParameters
end

class Shipit::Api::TasksController::TriggerParameters
end

class Shipit::ApiClient
  def autosave_associated_records_for_creator(*args); end

  def autosave_associated_records_for_stack(*args); end
end

module Shipit::ApiClient::GeneratedAssociationMethods
  def build_creator(*args, &block); end

  def build_stack(*args, &block); end

  def create_creator(*args, &block); end

  def create_creator!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_creator(); end

  def reload_stack(); end
end

module Shipit::ApiClient::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::ApiClientsController
  def default_order(); end

  def default_order=(val); end

  def default_order?(); end

  def default_page_size(); end

  def default_page_size=(val); end

  def default_page_size?(); end

  def max_page_size(); end

  def max_page_size=(val); end

  def max_page_size?(); end
end

class Shipit::ApiClientsController
  def self.default_order(); end

  def self.default_order=(val); end

  def self.default_order?(); end

  def self.default_page_size(); end

  def self.default_page_size=(val); end

  def self.default_page_size?(); end

  def self.max_page_size(); end

  def self.max_page_size=(val); end

  def self.max_page_size?(); end
end

class Shipit::ApplicationRecord
  include ::Shipit::ApplicationRecord::GeneratedAttributeMethods
  include ::Shipit::ApplicationRecord::GeneratedAssociationMethods
end

module Shipit::ApplicationRecord::GeneratedAssociationMethods
end

module Shipit::ApplicationRecord::GeneratedAssociationMethods
end

module Shipit::ApplicationRecord::GeneratedAttributeMethods
end

module Shipit::ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::Authentication
  extend ::ActiveSupport::Concern
end

class Shipit::BackgroundJob
end

module Shipit::BackgroundJob::Unique
  extend ::ActiveSupport::Concern
end

class Shipit::CCMenuUrlController
end

class Shipit::CacheDeploySpecJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::CheckRun
  def autosave_associated_records_for_commit(*args); end

  def autosave_associated_records_for_stack(*args); end
end

module Shipit::CheckRun::GeneratedAssociationMethods
  def build_commit(*args, &block); end

  def build_stack(*args, &block); end

  def create_commit(*args, &block); end

  def create_commit!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_commit(); end

  def reload_stack(); end
end

module Shipit::CheckRun::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::CheckRun
  extend ::Shipit::DeferredTouch::ClassMethods
  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::ChunkRollupJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::Commit
  def after_add_for_check_runs(); end

  def after_add_for_check_runs=(val); end

  def after_add_for_check_runs?(); end

  def after_add_for_commit_deployments(); end

  def after_add_for_commit_deployments=(val); end

  def after_add_for_commit_deployments?(); end

  def after_add_for_deploys(); end

  def after_add_for_deploys=(val); end

  def after_add_for_deploys?(); end

  def after_add_for_release_statuses(); end

  def after_add_for_release_statuses=(val); end

  def after_add_for_release_statuses?(); end

  def after_add_for_statuses(); end

  def after_add_for_statuses=(val); end

  def after_add_for_statuses?(); end

  def after_remove_for_check_runs(); end

  def after_remove_for_check_runs=(val); end

  def after_remove_for_check_runs?(); end

  def after_remove_for_commit_deployments(); end

  def after_remove_for_commit_deployments=(val); end

  def after_remove_for_commit_deployments?(); end

  def after_remove_for_deploys(); end

  def after_remove_for_deploys=(val); end

  def after_remove_for_deploys?(); end

  def after_remove_for_release_statuses(); end

  def after_remove_for_release_statuses=(val); end

  def after_remove_for_release_statuses?(); end

  def after_remove_for_statuses(); end

  def after_remove_for_statuses=(val); end

  def after_remove_for_statuses?(); end

  def autosave_associated_records_for_author(*args); end

  def autosave_associated_records_for_check_runs(*args); end

  def autosave_associated_records_for_commit_deployments(*args); end

  def autosave_associated_records_for_committer(*args); end

  def autosave_associated_records_for_deploys(*args); end

  def autosave_associated_records_for_lock_author(*args); end

  def autosave_associated_records_for_pull_request(*args); end

  def autosave_associated_records_for_release_statuses(*args); end

  def autosave_associated_records_for_stack(*args); end

  def autosave_associated_records_for_statuses(*args); end

  def before_add_for_check_runs(); end

  def before_add_for_check_runs=(val); end

  def before_add_for_check_runs?(); end

  def before_add_for_commit_deployments(); end

  def before_add_for_commit_deployments=(val); end

  def before_add_for_commit_deployments?(); end

  def before_add_for_deploys(); end

  def before_add_for_deploys=(val); end

  def before_add_for_deploys?(); end

  def before_add_for_release_statuses(); end

  def before_add_for_release_statuses=(val); end

  def before_add_for_release_statuses?(); end

  def before_add_for_statuses(); end

  def before_add_for_statuses=(val); end

  def before_add_for_statuses?(); end

  def before_remove_for_check_runs(); end

  def before_remove_for_check_runs=(val); end

  def before_remove_for_check_runs?(); end

  def before_remove_for_commit_deployments(); end

  def before_remove_for_commit_deployments=(val); end

  def before_remove_for_commit_deployments?(); end

  def before_remove_for_deploys(); end

  def before_remove_for_deploys=(val); end

  def before_remove_for_deploys?(); end

  def before_remove_for_release_statuses(); end

  def before_remove_for_release_statuses=(val); end

  def before_remove_for_release_statuses?(); end

  def before_remove_for_statuses(); end

  def before_remove_for_statuses=(val); end

  def before_remove_for_statuses?(); end

  def validate_associated_records_for_check_runs(*args); end

  def validate_associated_records_for_commit_deployments(*args); end

  def validate_associated_records_for_deploys(*args); end

  def validate_associated_records_for_release_statuses(*args); end

  def validate_associated_records_for_statuses(*args); end
end

module Shipit::Commit::GeneratedAssociationMethods
  def build_author(*args, &block); end

  def build_committer(*args, &block); end

  def build_lock_author(*args, &block); end

  def build_pull_request(*args, &block); end

  def build_stack(*args, &block); end

  def check_run_ids(); end

  def check_run_ids=(ids); end

  def commit_deployment_ids(); end

  def commit_deployment_ids=(ids); end

  def create_author(*args, &block); end

  def create_author!(*args, &block); end

  def create_committer(*args, &block); end

  def create_committer!(*args, &block); end

  def create_lock_author(*args, &block); end

  def create_lock_author!(*args, &block); end

  def create_pull_request(*args, &block); end

  def create_pull_request!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def deploy_ids(); end

  def deploy_ids=(ids); end

  def release_status_ids(); end

  def release_status_ids=(ids); end

  def reload_author(); end

  def reload_committer(); end

  def reload_lock_author(); end

  def reload_pull_request(); end

  def reload_stack(); end

  def status_ids(); end

  def status_ids=(ids); end
end

module Shipit::Commit::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Commit
  extend ::Shipit::DeferredTouch::ClassMethods
  def self.after_add_for_check_runs(); end

  def self.after_add_for_check_runs=(val); end

  def self.after_add_for_check_runs?(); end

  def self.after_add_for_commit_deployments(); end

  def self.after_add_for_commit_deployments=(val); end

  def self.after_add_for_commit_deployments?(); end

  def self.after_add_for_deploys(); end

  def self.after_add_for_deploys=(val); end

  def self.after_add_for_deploys?(); end

  def self.after_add_for_release_statuses(); end

  def self.after_add_for_release_statuses=(val); end

  def self.after_add_for_release_statuses?(); end

  def self.after_add_for_statuses(); end

  def self.after_add_for_statuses=(val); end

  def self.after_add_for_statuses?(); end

  def self.after_remove_for_check_runs(); end

  def self.after_remove_for_check_runs=(val); end

  def self.after_remove_for_check_runs?(); end

  def self.after_remove_for_commit_deployments(); end

  def self.after_remove_for_commit_deployments=(val); end

  def self.after_remove_for_commit_deployments?(); end

  def self.after_remove_for_deploys(); end

  def self.after_remove_for_deploys=(val); end

  def self.after_remove_for_deploys?(); end

  def self.after_remove_for_release_statuses(); end

  def self.after_remove_for_release_statuses=(val); end

  def self.after_remove_for_release_statuses?(); end

  def self.after_remove_for_statuses(); end

  def self.after_remove_for_statuses=(val); end

  def self.after_remove_for_statuses?(); end

  def self.before_add_for_check_runs(); end

  def self.before_add_for_check_runs=(val); end

  def self.before_add_for_check_runs?(); end

  def self.before_add_for_commit_deployments(); end

  def self.before_add_for_commit_deployments=(val); end

  def self.before_add_for_commit_deployments?(); end

  def self.before_add_for_deploys(); end

  def self.before_add_for_deploys=(val); end

  def self.before_add_for_deploys?(); end

  def self.before_add_for_release_statuses(); end

  def self.before_add_for_release_statuses=(val); end

  def self.before_add_for_release_statuses?(); end

  def self.before_add_for_statuses(); end

  def self.before_add_for_statuses=(val); end

  def self.before_add_for_statuses?(); end

  def self.before_remove_for_check_runs(); end

  def self.before_remove_for_check_runs=(val); end

  def self.before_remove_for_check_runs?(); end

  def self.before_remove_for_commit_deployments(); end

  def self.before_remove_for_commit_deployments=(val); end

  def self.before_remove_for_commit_deployments?(); end

  def self.before_remove_for_deploys(); end

  def self.before_remove_for_deploys=(val); end

  def self.before_remove_for_deploys?(); end

  def self.before_remove_for_release_statuses(); end

  def self.before_remove_for_release_statuses=(val); end

  def self.before_remove_for_release_statuses?(); end

  def self.before_remove_for_statuses(); end

  def self.before_remove_for_statuses=(val); end

  def self.before_remove_for_statuses?(); end

  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::CommitChecksController
end

class Shipit::CommitChecksController::TailParameters
end

class Shipit::CommitChecksController::TailParameters
end

class Shipit::CommitDeployment
  def after_add_for_statuses(); end

  def after_add_for_statuses=(val); end

  def after_add_for_statuses?(); end

  def after_remove_for_statuses(); end

  def after_remove_for_statuses=(val); end

  def after_remove_for_statuses?(); end

  def autosave_associated_records_for_statuses(*args); end

  def autosave_associated_records_for_task(*args); end

  def before_add_for_statuses(); end

  def before_add_for_statuses=(val); end

  def before_add_for_statuses?(); end

  def before_remove_for_statuses(); end

  def before_remove_for_statuses=(val); end

  def before_remove_for_statuses?(); end

  def validate_associated_records_for_statuses(*args); end
end

module Shipit::CommitDeployment::GeneratedAssociationMethods
  def build_task(*args, &block); end

  def create_task(*args, &block); end

  def create_task!(*args, &block); end

  def reload_task(); end

  def status_ids(); end

  def status_ids=(ids); end
end

module Shipit::CommitDeployment::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::CommitDeployment
  def self.after_add_for_statuses(); end

  def self.after_add_for_statuses=(val); end

  def self.after_add_for_statuses?(); end

  def self.after_remove_for_statuses(); end

  def self.after_remove_for_statuses=(val); end

  def self.after_remove_for_statuses?(); end

  def self.before_add_for_statuses(); end

  def self.before_add_for_statuses=(val); end

  def self.before_add_for_statuses?(); end

  def self.before_remove_for_statuses(); end

  def self.before_remove_for_statuses=(val); end

  def self.before_remove_for_statuses?(); end
end

class Shipit::CommitDeploymentStatus
  def autosave_associated_records_for_commit_deployment(*args); end
end

module Shipit::CommitDeploymentStatus::GeneratedAssociationMethods
  def build_commit_deployment(*args, &block); end

  def create_commit_deployment(*args, &block); end

  def create_commit_deployment!(*args, &block); end

  def reload_commit_deployment(); end
end

module Shipit::CommitDeploymentStatus::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::CommitSerializer
  def additions(); end

  def author(); end

  def authored_at(); end

  def committed_at(); end

  def committer(); end

  def deletions(); end
end

class Shipit::CommitSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::CommitsController
end

module Shipit::ConditionalAttributes
  extend ::ActiveSupport::Concern
end

class Shipit::ContinuousDeliveryJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::CreateOnGithubJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::CreateReleaseStatusesJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

module Shipit::DeferredTouch
  extend ::ActiveSupport::Concern
end

class Shipit::DeferredTouchJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::Delivery
  def autosave_associated_records_for_hook(*args); end
end

module Shipit::Delivery::GeneratedAssociationMethods
  def build_hook(*args, &block); end

  def create_hook(*args, &block); end

  def create_hook!(*args, &block); end

  def reload_hook(); end
end

module Shipit::Delivery::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Deploy
  def after_add_for_commit_deployments(); end

  def after_add_for_commit_deployments=(val); end

  def after_add_for_commit_deployments?(); end

  def after_remove_for_commit_deployments(); end

  def after_remove_for_commit_deployments=(val); end

  def after_remove_for_commit_deployments?(); end

  def autosave_associated_records_for_commit_deployments(*args); end

  def before_add_for_commit_deployments(); end

  def before_add_for_commit_deployments=(val); end

  def before_add_for_commit_deployments?(); end

  def before_remove_for_commit_deployments(); end

  def before_remove_for_commit_deployments=(val); end

  def before_remove_for_commit_deployments?(); end

  def validate_associated_records_for_commit_deployments(*args); end
end

class Shipit::Deploy::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
end

class Shipit::Deploy::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
end

class Shipit::Deploy::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
end

module Shipit::Deploy::CommitDeploymentsAssociationExtension
  def append_status(task_status); end
end

module Shipit::Deploy::CommitDeploymentsAssociationExtension
end

module Shipit::Deploy::GeneratedAssociationMethods
  def build_since_commit(*args, &block); end

  def build_until_commit(*args, &block); end

  def commit_deployment_ids(); end

  def commit_deployment_ids=(ids); end

  def create_since_commit(*args, &block); end

  def create_since_commit!(*args, &block); end

  def create_until_commit(*args, &block); end

  def create_until_commit!(*args, &block); end

  def reload_since_commit(); end

  def reload_until_commit(); end
end

module Shipit::Deploy::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::Deploy::GeneratedRelationMethods
end

module Shipit::Deploy::GeneratedRelationMethods
  extend ::Mutex_m
end

class Shipit::Deploy
  def self.after_add_for_commit_deployments(); end

  def self.after_add_for_commit_deployments=(val); end

  def self.after_add_for_commit_deployments?(); end

  def self.after_remove_for_commit_deployments(); end

  def self.after_remove_for_commit_deployments=(val); end

  def self.after_remove_for_commit_deployments?(); end

  def self.before_add_for_commit_deployments(); end

  def self.before_add_for_commit_deployments=(val); end

  def self.before_add_for_commit_deployments?(); end

  def self.before_remove_for_commit_deployments(); end

  def self.before_remove_for_commit_deployments=(val); end

  def self.before_remove_for_commit_deployments?(); end
end

class Shipit::DeploySerializer
  def additions(); end

  def commits(); end

  def deletions(); end
end

class Shipit::DeploysController
end

class Shipit::Engine
end

class Shipit::GitHubApp
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Shipit::GitHubHTTPCacheMiddleware
end

class Shipit::GithubAuthenticationController
  def callback(); end

  def logout(); end
end

class Shipit::GithubAuthenticationController
end

class Shipit::GithubHook
  def autosave_associated_records_for_stack(*args); end
end

module Shipit::GithubHook::GeneratedAssociationMethods
  def build_stack(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_stack(); end
end

module Shipit::GithubHook::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::GithubHook::Organization::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::GithubHook::Repo::GeneratedAssociationMethods
  def build_stack(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_stack(); end
end

module Shipit::GithubHook::Repo::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::GithubSyncJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::Hook
  def after_add_for_deliveries(); end

  def after_add_for_deliveries=(val); end

  def after_add_for_deliveries?(); end

  def after_remove_for_deliveries(); end

  def after_remove_for_deliveries=(val); end

  def after_remove_for_deliveries?(); end

  def autosave_associated_records_for_deliveries(*args); end

  def autosave_associated_records_for_stack(*args); end

  def before_add_for_deliveries(); end

  def before_add_for_deliveries=(val); end

  def before_add_for_deliveries?(); end

  def before_remove_for_deliveries(); end

  def before_remove_for_deliveries=(val); end

  def before_remove_for_deliveries?(); end

  def validate_associated_records_for_deliveries(*args); end
end

module Shipit::Hook::GeneratedAssociationMethods
  def build_stack(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def delivery_ids(); end

  def delivery_ids=(ids); end

  def reload_stack(); end
end

module Shipit::Hook::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Hook
  def self.after_add_for_deliveries(); end

  def self.after_add_for_deliveries=(val); end

  def self.after_add_for_deliveries?(); end

  def self.after_remove_for_deliveries(); end

  def self.after_remove_for_deliveries=(val); end

  def self.after_remove_for_deliveries?(); end

  def self.before_add_for_deliveries(); end

  def self.before_add_for_deliveries=(val); end

  def self.before_add_for_deliveries?(); end

  def self.before_remove_for_deliveries(); end

  def self.before_remove_for_deliveries=(val); end

  def self.before_remove_for_deliveries?(); end
end

class Shipit::HookSerializer
  def content_type(); end

  def created_at(); end

  def delivery_url(); end

  def events(); end

  def id(); end

  def insecure_ssl(); end

  def stack(); end

  def updated_at(); end
end

class Shipit::HookSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::MarkDeployHealthyJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::Membership
  def autosave_associated_records_for_team(*args); end

  def autosave_associated_records_for_user(*args); end
end

module Shipit::Membership::GeneratedAssociationMethods
  def build_team(*args, &block); end

  def build_user(*args, &block); end

  def create_team(*args, &block); end

  def create_team!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_team(); end

  def reload_user(); end
end

module Shipit::Membership::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::MergePullRequestsJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::MergeStatusController
end

class Shipit::OutputChunk
  def autosave_associated_records_for_task(*args); end
end

module Shipit::OutputChunk::GeneratedAssociationMethods
  def build_task(*args, &block); end

  def create_task(*args, &block); end

  def create_task!(*args, &block); end

  def reload_task(); end
end

module Shipit::OutputChunk::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::Pagination
  extend ::ActiveSupport::Concern
end

class Shipit::PerformCommitChecksJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::PullRequest
  include ::StateMachines::InstanceMethods
  def autosave_associated_records_for_base_commit(*args); end

  def autosave_associated_records_for_head(*args); end

  def autosave_associated_records_for_merge_commit(); end

  def autosave_associated_records_for_merge_requested_by(*args); end

  def autosave_associated_records_for_stack(*args); end
end

module Shipit::PullRequest::GeneratedAssociationMethods
  def build_base_commit(*args, &block); end

  def build_head(*args, &block); end

  def build_merge_commit(*args, &block); end

  def build_merge_requested_by(*args, &block); end

  def build_stack(*args, &block); end

  def create_base_commit(*args, &block); end

  def create_base_commit!(*args, &block); end

  def create_head(*args, &block); end

  def create_head!(*args, &block); end

  def create_merge_commit(*args, &block); end

  def create_merge_commit!(*args, &block); end

  def create_merge_requested_by(*args, &block); end

  def create_merge_requested_by!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_base_commit(); end

  def reload_head(); end

  def reload_merge_commit(); end

  def reload_merge_requested_by(); end

  def reload_stack(); end
end

module Shipit::PullRequest::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::PullRequest
  extend ::Shipit::DeferredTouch::ClassMethods
  extend ::StateMachines::ClassMethods
  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::PullRequestSerializer
  def additions(); end

  def base_ref(); end

  def branch(); end

  def deletions(); end

  def github_id(); end

  def head(); end

  def id(); end

  def merge_requested_at(); end

  def merge_requested_by(); end

  def merge_status(); end

  def mergeable(); end

  def number(); end

  def rejection_reason(); end

  def state(); end

  def title(); end
end

class Shipit::PullRequestSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::PullRequestsController
end

class Shipit::PurgeOldDeliveriesJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::ReapDeadTasksJob
  extend ::Shipit::BackgroundJob::Unique::ClassMethods
end

class Shipit::ReleaseStatus
  def autosave_associated_records_for_commit(*args); end

  def autosave_associated_records_for_stack(*args); end

  def autosave_associated_records_for_user(*args); end
end

module Shipit::ReleaseStatus::GeneratedAssociationMethods
  def build_commit(*args, &block); end

  def build_stack(*args, &block); end

  def build_user(*args, &block); end

  def create_commit(*args, &block); end

  def create_commit!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_commit(); end

  def reload_stack(); end

  def reload_user(); end
end

module Shipit::ReleaseStatus::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::ReleaseStatus
  extend ::Shipit::DeferredTouch::ClassMethods
  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::ReleaseStatusesController
end

class Shipit::Repository
  def after_add_for_stacks(); end

  def after_add_for_stacks=(val); end

  def after_add_for_stacks?(); end

  def after_remove_for_stacks(); end

  def after_remove_for_stacks=(val); end

  def after_remove_for_stacks?(); end

  def autosave_associated_records_for_stacks(*args); end

  def before_add_for_stacks(); end

  def before_add_for_stacks=(val); end

  def before_add_for_stacks?(); end

  def before_remove_for_stacks(); end

  def before_remove_for_stacks=(val); end

  def before_remove_for_stacks?(); end

  def validate_associated_records_for_stacks(*args); end
end

module Shipit::Repository::GeneratedAssociationMethods
  def stack_ids(); end

  def stack_ids=(ids); end
end

module Shipit::Repository::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Repository
  def self.after_add_for_stacks(); end

  def self.after_add_for_stacks=(val); end

  def self.after_add_for_stacks?(); end

  def self.after_remove_for_stacks(); end

  def self.after_remove_for_stacks=(val); end

  def self.after_remove_for_stacks?(); end

  def self.before_add_for_stacks(); end

  def self.before_add_for_stacks=(val); end

  def self.before_add_for_stacks?(); end

  def self.before_remove_for_stacks(); end

  def self.before_remove_for_stacks=(val); end

  def self.before_remove_for_stacks?(); end
end

class Shipit::Rollback::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
  include ::Shipit::Rollback::GeneratedRelationMethods
end

class Shipit::Rollback::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
  include ::Shipit::Rollback::GeneratedRelationMethods
end

class Shipit::Rollback::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Shipit::Task::GeneratedRelationMethods
  include ::Shipit::Deploy::GeneratedRelationMethods
  include ::Shipit::Rollback::GeneratedRelationMethods
end

module Shipit::Rollback::GeneratedAssociationMethods
  def build_deploy(*args, &block); end

  def create_deploy(*args, &block); end

  def create_deploy!(*args, &block); end

  def reload_deploy(); end
end

module Shipit::Rollback::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::Rollback::GeneratedRelationMethods
end

module Shipit::Rollback::GeneratedRelationMethods
  extend ::Mutex_m
end

class Shipit::RollbacksController
end

class Shipit::ShipitController
  include ::Shipit::Authentication
end

class Shipit::ShipitController
  extend ::Shipit::Authentication::ClassMethods
end

class Shipit::ShortCommitSerializer
  def sha(); end
end

class Shipit::SimpleMessageVerifier
end

class Shipit::Stack
  def after_add_for_api_clients(); end

  def after_add_for_api_clients=(val); end

  def after_add_for_api_clients?(); end

  def after_add_for_commits(); end

  def after_add_for_commits=(val); end

  def after_add_for_commits?(); end

  def after_add_for_deploys(); end

  def after_add_for_deploys=(val); end

  def after_add_for_deploys?(); end

  def after_add_for_deploys_and_rollbacks(); end

  def after_add_for_deploys_and_rollbacks=(val); end

  def after_add_for_deploys_and_rollbacks?(); end

  def after_add_for_github_hooks(); end

  def after_add_for_github_hooks=(val); end

  def after_add_for_github_hooks?(); end

  def after_add_for_hooks(); end

  def after_add_for_hooks=(val); end

  def after_add_for_hooks?(); end

  def after_add_for_pull_requests(); end

  def after_add_for_pull_requests=(val); end

  def after_add_for_pull_requests?(); end

  def after_add_for_rollbacks(); end

  def after_add_for_rollbacks=(val); end

  def after_add_for_rollbacks?(); end

  def after_add_for_tasks(); end

  def after_add_for_tasks=(val); end

  def after_add_for_tasks?(); end

  def after_remove_for_api_clients(); end

  def after_remove_for_api_clients=(val); end

  def after_remove_for_api_clients?(); end

  def after_remove_for_commits(); end

  def after_remove_for_commits=(val); end

  def after_remove_for_commits?(); end

  def after_remove_for_deploys(); end

  def after_remove_for_deploys=(val); end

  def after_remove_for_deploys?(); end

  def after_remove_for_deploys_and_rollbacks(); end

  def after_remove_for_deploys_and_rollbacks=(val); end

  def after_remove_for_deploys_and_rollbacks?(); end

  def after_remove_for_github_hooks(); end

  def after_remove_for_github_hooks=(val); end

  def after_remove_for_github_hooks?(); end

  def after_remove_for_hooks(); end

  def after_remove_for_hooks=(val); end

  def after_remove_for_hooks?(); end

  def after_remove_for_pull_requests(); end

  def after_remove_for_pull_requests=(val); end

  def after_remove_for_pull_requests?(); end

  def after_remove_for_rollbacks(); end

  def after_remove_for_rollbacks=(val); end

  def after_remove_for_rollbacks?(); end

  def after_remove_for_tasks(); end

  def after_remove_for_tasks=(val); end

  def after_remove_for_tasks?(); end

  def autosave_associated_records_for_api_clients(*args); end

  def autosave_associated_records_for_commits(*args); end

  def autosave_associated_records_for_deploys(*args); end

  def autosave_associated_records_for_deploys_and_rollbacks(*args); end

  def autosave_associated_records_for_github_hooks(*args); end

  def autosave_associated_records_for_hooks(*args); end

  def autosave_associated_records_for_lock_author(*args); end

  def autosave_associated_records_for_pull_requests(*args); end

  def autosave_associated_records_for_repository(*args); end

  def autosave_associated_records_for_rollbacks(*args); end

  def autosave_associated_records_for_tasks(*args); end

  def before_add_for_api_clients(); end

  def before_add_for_api_clients=(val); end

  def before_add_for_api_clients?(); end

  def before_add_for_commits(); end

  def before_add_for_commits=(val); end

  def before_add_for_commits?(); end

  def before_add_for_deploys(); end

  def before_add_for_deploys=(val); end

  def before_add_for_deploys?(); end

  def before_add_for_deploys_and_rollbacks(); end

  def before_add_for_deploys_and_rollbacks=(val); end

  def before_add_for_deploys_and_rollbacks?(); end

  def before_add_for_github_hooks(); end

  def before_add_for_github_hooks=(val); end

  def before_add_for_github_hooks?(); end

  def before_add_for_hooks(); end

  def before_add_for_hooks=(val); end

  def before_add_for_hooks?(); end

  def before_add_for_pull_requests(); end

  def before_add_for_pull_requests=(val); end

  def before_add_for_pull_requests?(); end

  def before_add_for_rollbacks(); end

  def before_add_for_rollbacks=(val); end

  def before_add_for_rollbacks?(); end

  def before_add_for_tasks(); end

  def before_add_for_tasks=(val); end

  def before_add_for_tasks?(); end

  def before_remove_for_api_clients(); end

  def before_remove_for_api_clients=(val); end

  def before_remove_for_api_clients?(); end

  def before_remove_for_commits(); end

  def before_remove_for_commits=(val); end

  def before_remove_for_commits?(); end

  def before_remove_for_deploys(); end

  def before_remove_for_deploys=(val); end

  def before_remove_for_deploys?(); end

  def before_remove_for_deploys_and_rollbacks(); end

  def before_remove_for_deploys_and_rollbacks=(val); end

  def before_remove_for_deploys_and_rollbacks?(); end

  def before_remove_for_github_hooks(); end

  def before_remove_for_github_hooks=(val); end

  def before_remove_for_github_hooks?(); end

  def before_remove_for_hooks(); end

  def before_remove_for_hooks=(val); end

  def before_remove_for_hooks?(); end

  def before_remove_for_pull_requests(); end

  def before_remove_for_pull_requests=(val); end

  def before_remove_for_pull_requests?(); end

  def before_remove_for_rollbacks(); end

  def before_remove_for_rollbacks=(val); end

  def before_remove_for_rollbacks?(); end

  def before_remove_for_tasks(); end

  def before_remove_for_tasks=(val); end

  def before_remove_for_tasks?(); end

  def validate_associated_records_for_api_clients(*args); end

  def validate_associated_records_for_commits(*args); end

  def validate_associated_records_for_deploys(*args); end

  def validate_associated_records_for_deploys_and_rollbacks(*args); end

  def validate_associated_records_for_github_hooks(*args); end

  def validate_associated_records_for_hooks(*args); end

  def validate_associated_records_for_pull_requests(*args); end

  def validate_associated_records_for_rollbacks(*args); end

  def validate_associated_records_for_tasks(*args); end
end

module Shipit::Stack::GeneratedAssociationMethods
  def api_client_ids(); end

  def api_client_ids=(ids); end

  def build_lock_author(*args, &block); end

  def build_repository(*args, &block); end

  def commit_ids(); end

  def commit_ids=(ids); end

  def create_lock_author(*args, &block); end

  def create_lock_author!(*args, &block); end

  def create_repository(*args, &block); end

  def create_repository!(*args, &block); end

  def deploy_ids(); end

  def deploy_ids=(ids); end

  def deploys_and_rollback_ids(); end

  def deploys_and_rollback_ids=(ids); end

  def github_hook_ids(); end

  def github_hook_ids=(ids); end

  def hook_ids(); end

  def hook_ids=(ids); end

  def pull_request_ids(); end

  def pull_request_ids=(ids); end

  def reload_lock_author(); end

  def reload_repository(); end

  def rollback_ids(); end

  def rollback_ids=(ids); end

  def task_ids(); end

  def task_ids=(ids); end
end

module Shipit::Stack::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Stack
  def self.after_add_for_api_clients(); end

  def self.after_add_for_api_clients=(val); end

  def self.after_add_for_api_clients?(); end

  def self.after_add_for_commits(); end

  def self.after_add_for_commits=(val); end

  def self.after_add_for_commits?(); end

  def self.after_add_for_deploys(); end

  def self.after_add_for_deploys=(val); end

  def self.after_add_for_deploys?(); end

  def self.after_add_for_deploys_and_rollbacks(); end

  def self.after_add_for_deploys_and_rollbacks=(val); end

  def self.after_add_for_deploys_and_rollbacks?(); end

  def self.after_add_for_github_hooks(); end

  def self.after_add_for_github_hooks=(val); end

  def self.after_add_for_github_hooks?(); end

  def self.after_add_for_hooks(); end

  def self.after_add_for_hooks=(val); end

  def self.after_add_for_hooks?(); end

  def self.after_add_for_pull_requests(); end

  def self.after_add_for_pull_requests=(val); end

  def self.after_add_for_pull_requests?(); end

  def self.after_add_for_rollbacks(); end

  def self.after_add_for_rollbacks=(val); end

  def self.after_add_for_rollbacks?(); end

  def self.after_add_for_tasks(); end

  def self.after_add_for_tasks=(val); end

  def self.after_add_for_tasks?(); end

  def self.after_remove_for_api_clients(); end

  def self.after_remove_for_api_clients=(val); end

  def self.after_remove_for_api_clients?(); end

  def self.after_remove_for_commits(); end

  def self.after_remove_for_commits=(val); end

  def self.after_remove_for_commits?(); end

  def self.after_remove_for_deploys(); end

  def self.after_remove_for_deploys=(val); end

  def self.after_remove_for_deploys?(); end

  def self.after_remove_for_deploys_and_rollbacks(); end

  def self.after_remove_for_deploys_and_rollbacks=(val); end

  def self.after_remove_for_deploys_and_rollbacks?(); end

  def self.after_remove_for_github_hooks(); end

  def self.after_remove_for_github_hooks=(val); end

  def self.after_remove_for_github_hooks?(); end

  def self.after_remove_for_hooks(); end

  def self.after_remove_for_hooks=(val); end

  def self.after_remove_for_hooks?(); end

  def self.after_remove_for_pull_requests(); end

  def self.after_remove_for_pull_requests=(val); end

  def self.after_remove_for_pull_requests?(); end

  def self.after_remove_for_rollbacks(); end

  def self.after_remove_for_rollbacks=(val); end

  def self.after_remove_for_rollbacks?(); end

  def self.after_remove_for_tasks(); end

  def self.after_remove_for_tasks=(val); end

  def self.after_remove_for_tasks?(); end

  def self.before_add_for_api_clients(); end

  def self.before_add_for_api_clients=(val); end

  def self.before_add_for_api_clients?(); end

  def self.before_add_for_commits(); end

  def self.before_add_for_commits=(val); end

  def self.before_add_for_commits?(); end

  def self.before_add_for_deploys(); end

  def self.before_add_for_deploys=(val); end

  def self.before_add_for_deploys?(); end

  def self.before_add_for_deploys_and_rollbacks(); end

  def self.before_add_for_deploys_and_rollbacks=(val); end

  def self.before_add_for_deploys_and_rollbacks?(); end

  def self.before_add_for_github_hooks(); end

  def self.before_add_for_github_hooks=(val); end

  def self.before_add_for_github_hooks?(); end

  def self.before_add_for_hooks(); end

  def self.before_add_for_hooks=(val); end

  def self.before_add_for_hooks?(); end

  def self.before_add_for_pull_requests(); end

  def self.before_add_for_pull_requests=(val); end

  def self.before_add_for_pull_requests?(); end

  def self.before_add_for_rollbacks(); end

  def self.before_add_for_rollbacks=(val); end

  def self.before_add_for_rollbacks?(); end

  def self.before_add_for_tasks(); end

  def self.before_add_for_tasks=(val); end

  def self.before_add_for_tasks?(); end

  def self.before_remove_for_api_clients(); end

  def self.before_remove_for_api_clients=(val); end

  def self.before_remove_for_api_clients?(); end

  def self.before_remove_for_commits(); end

  def self.before_remove_for_commits=(val); end

  def self.before_remove_for_commits?(); end

  def self.before_remove_for_deploys(); end

  def self.before_remove_for_deploys=(val); end

  def self.before_remove_for_deploys?(); end

  def self.before_remove_for_deploys_and_rollbacks(); end

  def self.before_remove_for_deploys_and_rollbacks=(val); end

  def self.before_remove_for_deploys_and_rollbacks?(); end

  def self.before_remove_for_github_hooks(); end

  def self.before_remove_for_github_hooks=(val); end

  def self.before_remove_for_github_hooks?(); end

  def self.before_remove_for_hooks(); end

  def self.before_remove_for_hooks=(val); end

  def self.before_remove_for_hooks?(); end

  def self.before_remove_for_pull_requests(); end

  def self.before_remove_for_pull_requests=(val); end

  def self.before_remove_for_pull_requests?(); end

  def self.before_remove_for_rollbacks(); end

  def self.before_remove_for_rollbacks=(val); end

  def self.before_remove_for_rollbacks?(); end

  def self.before_remove_for_tasks(); end

  def self.before_remove_for_tasks=(val); end

  def self.before_remove_for_tasks?(); end
end

class Shipit::StackSerializer
  def archived_since(); end

  def branch(); end

  def continuous_deployment(); end

  def created_at(); end

  def deploy_url(); end

  def environment(); end

  def id(); end

  def last_deployed_at(); end

  def lock_author(); end

  def lock_reason(); end

  def locked_since(); end

  def merge_queue_enabled(); end

  def repo_name(); end

  def repo_owner(); end

  def undeployed_commits_count(); end

  def updated_at(); end
end

class Shipit::StackSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::StacksController
end

class Shipit::Status
  def autosave_associated_records_for_commit(*args); end

  def autosave_associated_records_for_stack(*args); end
end

module Shipit::Status::GeneratedAssociationMethods
  def build_commit(*args, &block); end

  def build_stack(*args, &block); end

  def create_commit(*args, &block); end

  def create_commit!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def reload_commit(); end

  def reload_stack(); end
end

module Shipit::Status::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Status::Unknown
  include ::GlobalID::Identification
end

class Shipit::Status
  extend ::Shipit::DeferredTouch::ClassMethods
  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::TailTaskSerializer
  def status(); end
end

class Shipit::TailTaskSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::Task
  include ::StateMachines::InstanceMethods
  def after_add_for_chunks(); end

  def after_add_for_chunks=(val); end

  def after_add_for_chunks?(); end

  def after_remove_for_chunks(); end

  def after_remove_for_chunks=(val); end

  def after_remove_for_chunks?(); end

  def autosave_associated_records_for_aborted_by(*args); end

  def autosave_associated_records_for_chunks(*args); end

  def autosave_associated_records_for_deploy(*args); end

  def autosave_associated_records_for_since_commit(*args); end

  def autosave_associated_records_for_stack(*args); end

  def autosave_associated_records_for_until_commit(*args); end

  def autosave_associated_records_for_user(*args); end

  def before_add_for_chunks(); end

  def before_add_for_chunks=(val); end

  def before_add_for_chunks?(); end

  def before_remove_for_chunks(); end

  def before_remove_for_chunks=(val); end

  def before_remove_for_chunks?(); end

  def validate_associated_records_for_chunks(*args); end
end

module Shipit::Task::GeneratedAssociationMethods
  def build_aborted_by(*args, &block); end

  def build_deploy(*args, &block); end

  def build_since_commit(*args, &block); end

  def build_stack(*args, &block); end

  def build_until_commit(*args, &block); end

  def build_user(*args, &block); end

  def chunk_ids(); end

  def chunk_ids=(ids); end

  def create_aborted_by(*args, &block); end

  def create_aborted_by!(*args, &block); end

  def create_deploy(*args, &block); end

  def create_deploy!(*args, &block); end

  def create_since_commit(*args, &block); end

  def create_since_commit!(*args, &block); end

  def create_stack(*args, &block); end

  def create_stack!(*args, &block); end

  def create_until_commit(*args, &block); end

  def create_until_commit!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_aborted_by(); end

  def reload_deploy(); end

  def reload_since_commit(); end

  def reload_stack(); end

  def reload_until_commit(); end

  def reload_user(); end
end

module Shipit::Task::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Shipit::Task::GeneratedRelationMethods
  def active(*args, &block); end

  def completed(*args, &block); end

  def due_for_rollup(*args, &block); end

  def exclusive(*args, &block); end

  def last_seven_days(*args, &block); end

  def not_active(*args, &block); end

  def previous_seven_days(*args, &block); end

  def success(*args, &block); end

  def unsuccessful(*args, &block); end
end

module Shipit::Task::GeneratedRelationMethods
  extend ::Mutex_m
end

class Shipit::Task
  extend ::Shipit::DeferredTouch::ClassMethods
  extend ::StateMachines::ClassMethods
  def self.after_add_for_chunks(); end

  def self.after_add_for_chunks=(val); end

  def self.after_add_for_chunks?(); end

  def self.after_remove_for_chunks(); end

  def self.after_remove_for_chunks=(val); end

  def self.after_remove_for_chunks?(); end

  def self.before_add_for_chunks(); end

  def self.before_add_for_chunks=(val); end

  def self.before_add_for_chunks?(); end

  def self.before_remove_for_chunks(); end

  def self.before_remove_for_chunks=(val); end

  def self.before_remove_for_chunks?(); end

  def self.deferred_touches(); end

  def self.deferred_touches=(val); end

  def self.deferred_touches?(); end
end

class Shipit::TaskSerializer
  def author(); end

  def created_at(); end

  def ended_at(); end

  def env(); end

  def id(); end

  def ignored_safeties(); end

  def started_at(); end

  def status(); end

  def title(); end

  def updated_at(); end
end

class Shipit::TaskSerializer
  extend ::Shipit::ConditionalAttributes::ClassMethods
end

class Shipit::TasksController
  def default_order(); end

  def default_order=(val); end

  def default_order?(); end

  def default_page_size(); end

  def default_page_size=(val); end

  def default_page_size?(); end

  def max_page_size(); end

  def max_page_size=(val); end

  def max_page_size?(); end
end

class Shipit::TasksController
  def self.default_order(); end

  def self.default_order=(val); end

  def self.default_order?(); end

  def self.default_page_size(); end

  def self.default_page_size=(val); end

  def self.default_page_size?(); end

  def self.max_page_size(); end

  def self.max_page_size=(val); end

  def self.max_page_size?(); end
end

class Shipit::Team
  def after_add_for_github_hooks(); end

  def after_add_for_github_hooks=(val); end

  def after_add_for_github_hooks?(); end

  def after_add_for_members(); end

  def after_add_for_members=(val); end

  def after_add_for_members?(); end

  def after_add_for_memberships(); end

  def after_add_for_memberships=(val); end

  def after_add_for_memberships?(); end

  def after_remove_for_github_hooks(); end

  def after_remove_for_github_hooks=(val); end

  def after_remove_for_github_hooks?(); end

  def after_remove_for_members(); end

  def after_remove_for_members=(val); end

  def after_remove_for_members?(); end

  def after_remove_for_memberships(); end

  def after_remove_for_memberships=(val); end

  def after_remove_for_memberships?(); end

  def autosave_associated_records_for_github_hooks(*args); end

  def autosave_associated_records_for_members(*args); end

  def autosave_associated_records_for_memberships(*args); end

  def before_add_for_github_hooks(); end

  def before_add_for_github_hooks=(val); end

  def before_add_for_github_hooks?(); end

  def before_add_for_members(); end

  def before_add_for_members=(val); end

  def before_add_for_members?(); end

  def before_add_for_memberships(); end

  def before_add_for_memberships=(val); end

  def before_add_for_memberships?(); end

  def before_remove_for_github_hooks(); end

  def before_remove_for_github_hooks=(val); end

  def before_remove_for_github_hooks?(); end

  def before_remove_for_members(); end

  def before_remove_for_members=(val); end

  def before_remove_for_members?(); end

  def before_remove_for_memberships(); end

  def before_remove_for_memberships=(val); end

  def before_remove_for_memberships?(); end

  def validate_associated_records_for_github_hooks(*args); end

  def validate_associated_records_for_members(*args); end

  def validate_associated_records_for_memberships(*args); end
end

module Shipit::Team::GeneratedAssociationMethods
  def github_hook_ids(); end

  def github_hook_ids=(ids); end

  def member_ids(); end

  def member_ids=(ids); end

  def membership_ids(); end

  def membership_ids=(ids); end
end

module Shipit::Team::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::Team
  def self.after_add_for_github_hooks(); end

  def self.after_add_for_github_hooks=(val); end

  def self.after_add_for_github_hooks?(); end

  def self.after_add_for_members(); end

  def self.after_add_for_members=(val); end

  def self.after_add_for_members?(); end

  def self.after_add_for_memberships(); end

  def self.after_add_for_memberships=(val); end

  def self.after_add_for_memberships?(); end

  def self.after_remove_for_github_hooks(); end

  def self.after_remove_for_github_hooks=(val); end

  def self.after_remove_for_github_hooks?(); end

  def self.after_remove_for_members(); end

  def self.after_remove_for_members=(val); end

  def self.after_remove_for_members?(); end

  def self.after_remove_for_memberships(); end

  def self.after_remove_for_memberships=(val); end

  def self.after_remove_for_memberships?(); end

  def self.before_add_for_github_hooks(); end

  def self.before_add_for_github_hooks=(val); end

  def self.before_add_for_github_hooks?(); end

  def self.before_add_for_members(); end

  def self.before_add_for_members=(val); end

  def self.before_add_for_members?(); end

  def self.before_add_for_memberships(); end

  def self.before_add_for_memberships=(val); end

  def self.before_add_for_memberships?(); end

  def self.before_remove_for_github_hooks(); end

  def self.before_remove_for_github_hooks=(val); end

  def self.before_remove_for_github_hooks?(); end

  def self.before_remove_for_members(); end

  def self.before_remove_for_members=(val); end

  def self.before_remove_for_members?(); end

  def self.before_remove_for_memberships(); end

  def self.before_remove_for_memberships=(val); end

  def self.before_remove_for_memberships?(); end
end

class Shipit::UndeployedCommit
  def blocked?(); end

  def deploy_disallowed?(); end

  def deploy_discouraged?(); end

  def deploy_state(bypass_safeties=T.unsafe(nil)); end

  def expected_to_be_deployed?(); end

  def index(); end

  def initialize(commit, index:, next_expected_commit_to_deploy: T.unsafe(nil)); end

  def redeploy_state(bypass_safeties=T.unsafe(nil)); end
end

class Shipit::UndeployedCommit
end

class Shipit::User
  def after_add_for_authored_commits(); end

  def after_add_for_authored_commits=(val); end

  def after_add_for_authored_commits?(); end

  def after_add_for_commits(); end

  def after_add_for_commits=(val); end

  def after_add_for_commits?(); end

  def after_add_for_memberships(); end

  def after_add_for_memberships=(val); end

  def after_add_for_memberships?(); end

  def after_add_for_tasks(); end

  def after_add_for_tasks=(val); end

  def after_add_for_tasks?(); end

  def after_add_for_teams(); end

  def after_add_for_teams=(val); end

  def after_add_for_teams?(); end

  def after_remove_for_authored_commits(); end

  def after_remove_for_authored_commits=(val); end

  def after_remove_for_authored_commits?(); end

  def after_remove_for_commits(); end

  def after_remove_for_commits=(val); end

  def after_remove_for_commits?(); end

  def after_remove_for_memberships(); end

  def after_remove_for_memberships=(val); end

  def after_remove_for_memberships?(); end

  def after_remove_for_tasks(); end

  def after_remove_for_tasks=(val); end

  def after_remove_for_tasks?(); end

  def after_remove_for_teams(); end

  def after_remove_for_teams=(val); end

  def after_remove_for_teams?(); end

  def autosave_associated_records_for_authored_commits(*args); end

  def autosave_associated_records_for_commits(*args); end

  def autosave_associated_records_for_memberships(*args); end

  def autosave_associated_records_for_tasks(*args); end

  def autosave_associated_records_for_teams(*args); end

  def before_add_for_authored_commits(); end

  def before_add_for_authored_commits=(val); end

  def before_add_for_authored_commits?(); end

  def before_add_for_commits(); end

  def before_add_for_commits=(val); end

  def before_add_for_commits?(); end

  def before_add_for_memberships(); end

  def before_add_for_memberships=(val); end

  def before_add_for_memberships?(); end

  def before_add_for_tasks(); end

  def before_add_for_tasks=(val); end

  def before_add_for_tasks?(); end

  def before_add_for_teams(); end

  def before_add_for_teams=(val); end

  def before_add_for_teams?(); end

  def before_remove_for_authored_commits(); end

  def before_remove_for_authored_commits=(val); end

  def before_remove_for_authored_commits?(); end

  def before_remove_for_commits(); end

  def before_remove_for_commits=(val); end

  def before_remove_for_commits?(); end

  def before_remove_for_memberships(); end

  def before_remove_for_memberships=(val); end

  def before_remove_for_memberships?(); end

  def before_remove_for_tasks(); end

  def before_remove_for_tasks=(val); end

  def before_remove_for_tasks?(); end

  def before_remove_for_teams(); end

  def before_remove_for_teams=(val); end

  def before_remove_for_teams?(); end

  def validate_associated_records_for_authored_commits(*args); end

  def validate_associated_records_for_commits(*args); end

  def validate_associated_records_for_memberships(*args); end

  def validate_associated_records_for_tasks(*args); end

  def validate_associated_records_for_teams(*args); end
end

module Shipit::User::GeneratedAssociationMethods
  def authored_commit_ids(); end

  def authored_commit_ids=(ids); end

  def commit_ids(); end

  def commit_ids=(ids); end

  def membership_ids(); end

  def membership_ids=(ids); end

  def task_ids(); end

  def task_ids=(ids); end

  def team_ids(); end

  def team_ids=(ids); end
end

module Shipit::User::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shipit::User
  def self.after_add_for_authored_commits(); end

  def self.after_add_for_authored_commits=(val); end

  def self.after_add_for_authored_commits?(); end

  def self.after_add_for_commits(); end

  def self.after_add_for_commits=(val); end

  def self.after_add_for_commits?(); end

  def self.after_add_for_memberships(); end

  def self.after_add_for_memberships=(val); end

  def self.after_add_for_memberships?(); end

  def self.after_add_for_tasks(); end

  def self.after_add_for_tasks=(val); end

  def self.after_add_for_tasks?(); end

  def self.after_add_for_teams(); end

  def self.after_add_for_teams=(val); end

  def self.after_add_for_teams?(); end

  def self.after_remove_for_authored_commits(); end

  def self.after_remove_for_authored_commits=(val); end

  def self.after_remove_for_authored_commits?(); end

  def self.after_remove_for_commits(); end

  def self.after_remove_for_commits=(val); end

  def self.after_remove_for_commits?(); end

  def self.after_remove_for_memberships(); end

  def self.after_remove_for_memberships=(val); end

  def self.after_remove_for_memberships?(); end

  def self.after_remove_for_tasks(); end

  def self.after_remove_for_tasks=(val); end

  def self.after_remove_for_tasks?(); end

  def self.after_remove_for_teams(); end

  def self.after_remove_for_teams=(val); end

  def self.after_remove_for_teams?(); end

  def self.before_add_for_authored_commits(); end

  def self.before_add_for_authored_commits=(val); end

  def self.before_add_for_authored_commits?(); end

  def self.before_add_for_commits(); end

  def self.before_add_for_commits=(val); end

  def self.before_add_for_commits?(); end

  def self.before_add_for_memberships(); end

  def self.before_add_for_memberships=(val); end

  def self.before_add_for_memberships?(); end

  def self.before_add_for_tasks(); end

  def self.before_add_for_tasks=(val); end

  def self.before_add_for_tasks?(); end

  def self.before_add_for_teams(); end

  def self.before_add_for_teams=(val); end

  def self.before_add_for_teams?(); end

  def self.before_remove_for_authored_commits(); end

  def self.before_remove_for_authored_commits=(val); end

  def self.before_remove_for_authored_commits?(); end

  def self.before_remove_for_commits(); end

  def self.before_remove_for_commits=(val); end

  def self.before_remove_for_commits?(); end

  def self.before_remove_for_memberships(); end

  def self.before_remove_for_memberships=(val); end

  def self.before_remove_for_memberships?(); end

  def self.before_remove_for_tasks(); end

  def self.before_remove_for_tasks=(val); end

  def self.before_remove_for_tasks?(); end

  def self.before_remove_for_teams(); end

  def self.before_remove_for_teams=(val); end

  def self.before_remove_for_teams?(); end
end

class Shipit::UserSerializer
  def avatar_url(); end

  def created_at(); end

  def email(); end

  def github_id(); end

  def id(); end

  def login(); end

  def name(); end

  def updated_at(); end
end

module Shipit
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.use_relative_model_naming?(); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::Combine
end

module SimpleCov::Combine::BranchesCombiner
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def refuse_coverage_drop(); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Configuration
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  include ::Enumerable
  def branch_covered_percent(); end

  def count(*args, &block); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, &block); end

  def lines_of_code(); end

  def map(*args, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, &block); end

  def skipped_lines(); end

  def to_a(*args, &block); end

  def to_ary(*args, &block); end

  def total_branches(); end
end

class SimpleCov::FileList
  extend ::Forwardable
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def branchable_result?(); end

  def format(result); end

  def line_status?(source_file, line); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, &block); end

  def covered_branches(*args, &block); end

  def covered_lines(*args, &block); end

  def covered_percent(*args, &block); end

  def covered_percentages(*args, &block); end

  def covered_strength(*args, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result); end

  def least_covered_file(*args, &block); end

  def missed_branches(*args, &block); end

  def missed_lines(*args, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_branches(*args, &block); end

  def total_lines(*args, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.clear_resultset(); end

  def self.merge_and_store(*results); end

  def self.merge_results(*results); end

  def self.merged_result(); end

  def self.results(); end

  def self.resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.stored_data(); end

  def self.synchronize_resultset(); end
end

module SimpleCov::SimulateCoverage
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Branch
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov::UselessResultsRemover
  ROOT_REGX = ::T.let(nil, ::T.untyped)
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), &block); end

  def self.exit_exception(); end

  def self.exit_status_from_exception(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.process_result(result, exit_status); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result, covered_percent); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.set_exit_exception(); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(covered_percent); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SorbetRails::Config
  def enabled_gem_plugins(*args, &blk); end

  def enabled_gem_plugins=(enabled_gem_plugins); end

  def enabled_model_plugins(*args, &blk); end

  def enabled_model_plugins=(enabled_model_plugins); end

  def enabled_plugins(*args, &blk); end

  def extra_helper_includes(*args, &blk); end

  def extra_helper_includes=(extra_helper_includes); end

  def initialize(&blk); end
end

class SorbetRails::Config
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::CustomFinderMethods
  def find_by_id(id); end

  def find_by_id!(id); end

  def find_n(*ids); end

  def first_n(n); end

  def last_n(n); end
end

module SorbetRails::CustomFinderMethods
end

module SorbetRails::CustomParamsMethods
  include ::Kernel
end

module SorbetRails::CustomParamsMethods
  extend ::T::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelPlugins
  include ::Kernel
  def get_plugin_by_name(*args, &blk); end

  def get_plugins(*args, &blk); end

  def register_plugin(*args, &blk); end

  def register_plugin_by_name(arg0, &blk); end

  def set_plugins(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc
  def assoc_should_be_untyped?(*args, &blk); end

  def polymorphic_assoc?(*args, &blk); end

  def populate_collection_assoc_getter_setter(*args, &blk); end

  def populate_single_assoc_getter_setter(*args, &blk); end

  def relation_should_be_untyped?(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute
  def active_record_type_to_sorbet_type(*args, &blk); end

  def generate_enum_methods(*args, &blk); end

  def time_zone_aware_column?(*args, &blk); end

  def type_for_column_def(*args, &blk); end

  def value_type_for_attr_writer(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute
end

class SorbetRails::ModelPlugins::ActiveRecordEnum
end

class SorbetRails::ModelPlugins::ActiveRecordEnum
end

class SorbetRails::ModelPlugins::ActiveRecordFinderMethods
  def create_finder_method_pair(*args, &blk); end

  def create_finder_methods_for(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveRecordFinderMethods
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot
end

class SorbetRails::ModelPlugins::ActiveStorageMethods
  def create_has_many_methods(*args, &blk); end

  def create_has_one_methods(*args, &blk); end
end

class SorbetRails::ModelPlugins::ActiveStorageMethods
end

class SorbetRails::ModelPlugins::Base
  include ::SorbetRails::ModelUtils
  def available_classes(*args, &blk); end
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::ModelPlugins::Base
end

class SorbetRails::ModelPlugins::CustomFinderMethods
end

class SorbetRails::ModelPlugins::CustomFinderMethods
end

class SorbetRails::ModelPlugins::EnumerableCollections
  def create_enumerable_methods_for(*args, &blk); end
end

class SorbetRails::ModelPlugins::EnumerableCollections
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName
end

module SorbetRails::ModelPlugins
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::ModelRbiFormatter
  include ::SorbetRails::ModelUtils
  def available_classes(*args, &blk); end

  def generate_base_rbi(*args, &blk); end

  def generate_rbi(*args, &blk); end

  def initialize(*args, &blk); end

  def run_plugins(*args, &blk); end
end

class SorbetRails::ModelRbiFormatter
  extend ::T::Sig
  extend ::SorbetRails::ModelPlugins
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelUtils
  def add_relation_query_method(*args, &blk); end

  def exists_class_method?(*args, &blk); end

  def exists_instance_method?(*args, &blk); end

  def model_assoc_proxy_class_name(*args, &blk); end

  def model_assoc_relation_class_name(*args, &blk); end

  def model_class(*args, &blk); end

  def model_class_name(*args, &blk); end

  def model_module_name(*args, &blk); end

  def model_relation_class_name(*args, &blk); end
end

module SorbetRails::ModelUtils
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::PluckToTStruct
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::Railtie
end

class SorbetRails::Railtie
end

class SorbetRails::TypedEnumConfig
  def class_name(); end

  def initialize(hash=T.unsafe(nil)); end

  def strict_mode(); end
end

class SorbetRails::TypedEnumConfig
  def self.inherited(s); end
end

module SorbetRails::Utils
end

module SorbetRails::Utils
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.rails_eager_load_all!(*args, &blk); end

  def self.valid_method_name?(*args, &blk); end
end

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.config(&blk); end

  def self.configure(*args, &blk); end

  def self.register_configured_plugins(&blk); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module SourceAnnotationExtractor
end

module SourceAnnotationExtractor
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ArgumentError
end

class Sprockets::ArgumentError
end

class Sprockets::Asset
  def ==(other); end

  def base64digest(); end

  def bytesize(); end

  def charset(); end

  def content_type(); end

  def dependencies(); end

  def digest(); end

  def digest_path(); end

  def each(&blk); end

  def eql?(other); end

  def etag(); end

  def filename(); end

  def hexdigest(); end

  def id(); end

  def included(); end

  def initialize(environment, attributes=T.unsafe(nil)); end

  def integrity(); end

  def length(); end

  def links(); end

  def logical_path(); end

  def metadata(); end

  def mtime(); end

  def pathname(); end

  def source(); end

  def to_a(); end

  def to_hash(); end

  def uri(); end

  def write_to(filename); end
end

class Sprockets::Asset
end

module Sprockets::Autoload
end

Sprockets::Autoload::CoffeeScript = CoffeeScript

Sprockets::Autoload::Sass = Sass

module Sprockets::Autoload
end

class Sprockets::Base
  include ::Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Server
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::Bower
  def [](*args); end

  def cache(); end

  def cache=(cache); end

  def cache_get(key); end

  def cache_set(key, value); end

  def cached(); end

  def compress_from_root(uri); end

  def each_logical_path(*args, &block); end

  def expand_from_root(uri); end

  def find_all_linked_assets(path, options=T.unsafe(nil)); end

  def find_asset(path, options=T.unsafe(nil)); end

  def index(); end

  def logical_paths(); end

  def normalize_logical_path(path); end

  def resolve_with_compat(path, options=T.unsafe(nil)); end

  def resolve_without_compat(path, options=T.unsafe(nil)); end
end

class Sprockets::Base
end

module Sprockets::Bower
  def read_bower_main(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
end

class Sprockets::Bundle
end

class Sprockets::Bundle
  def self.call(input); end

  def self.process_bundle_reducers(assets, reducers); end
end

class Sprockets::Cache
  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::GetWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::MemoryStore
  def get(key); end

  def initialize(max_size=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
end

class Sprockets::Cache::NullStore
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::Cache::ReadWriteWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::CachedEnvironment
  def _entries(path); end

  def _load(uri); end

  def _processor_cache_key(processor); end

  def _resolve_dependency(str); end

  def _stat(path); end

  def initialize(environment); end

  def processor_cache_key(str); end
end

class Sprockets::CachedEnvironment
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::CoffeeScriptTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::Compressing
  include ::Sprockets::Utils
  def compressors(); end

  def css_compressor(); end

  def css_compressor=(compressor); end

  def gzip=(gzip); end

  def gzip?(); end

  def js_compressor(); end

  def js_compressor=(compressor); end

  def register_compressor(mime_type, sym, klass); end

  def skip_gzip?(); end
end

module Sprockets::Compressing
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Engines
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def computed_config(); end

  def computed_config=(computed_config); end

  def config(); end

  def config=(config); end

  def context_class(); end

  def digest_class(); end

  def digest_class=(klass); end

  def initialize_configuration(parent); end

  def logger(); end

  def logger=(logger); end

  def version(); end

  def version=(version); end
end

module Sprockets::Configuration
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::Context
  def __LINE__(); end

  def __LINE__=(_); end

  def asset_data_uri(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def content_type(); end

  def depend_on(path); end

  def depend_on_asset(path); end

  def environment(); end

  def filename(); end

  def font_path(path); end

  def image_path(path); end

  def initialize(input); end

  def javascript_path(path); end

  def link_asset(path); end

  def load(uri); end

  def load_path(); end

  def logical_path(); end

  def metadata(); end

  def pathname(); end

  def require_asset(path); end

  def resolve(path, options=T.unsafe(nil)); end

  def resolve_with_compat(path, options=T.unsafe(nil)); end

  def resolve_without_compat(path, options=T.unsafe(nil)); end

  def root_path(); end

  def stub_asset(path); end

  def stylesheet_path(path); end

  def video_path(path); end
end

class Sprockets::Context
end

class Sprockets::ConversionError
end

class Sprockets::ConversionError
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def add_dependency(uri); end

  def depend_on(uri); end

  def dependencies(); end

  def dependency_resolvers(); end

  def register_dependency_resolver(scheme, &block); end

  def resolve_dependency(str); end
end

module Sprockets::Dependencies
end

module Sprockets::DigestUtils
  def detect_digest_class(bytes); end

  def digest(obj); end

  def digest_class(); end

  def hexdigest_integrity_uri(hexdigest); end

  def integrity_uri(digest); end

  def pack_base64digest(bin); end

  def pack_hexdigest(bin); end

  def pack_urlsafe_base64digest(bin); end

  def unpack_hexdigest(hex); end
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::Sprockets::DigestUtils
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(options=T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::ERBProcessor
  def call(input); end

  def initialize(&block); end
end

class Sprockets::ERBProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::ERBTemplate
  def call(*args); end
end

class Sprockets::ERBTemplate
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EcoTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EjsTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsTemplate
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EncodingUtils
  def base64(str); end

  def charlock_detect(str); end

  def deflate(str); end

  def detect(str); end

  def detect_css(str); end

  def detect_html(str); end

  def detect_unicode(str); end

  def detect_unicode_bom(str); end

  def gzip(str); end

  def scan_css_charset(str); end

  def unmarshaled_deflated(str, window_bits=T.unsafe(nil)); end
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::Sprockets::EncodingUtils
end

module Sprockets::Engines
  include ::Sprockets::Utils
  def engine_mime_types(); end

  def engines(); end

  def register_engine(ext, klass, options=T.unsafe(nil)); end
end

module Sprockets::Engines
end

class Sprockets::Environment
  def find_all_linked_assets(*args, &block); end

  def find_asset(*args); end

  def initialize(root=T.unsafe(nil)); end

  def load(*args); end
end

class Sprockets::Environment
end

class Sprockets::Error
end

class Sprockets::Error
end

class Sprockets::FileNotFound
end

class Sprockets::FileNotFound
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileReader
end

class Sprockets::FileReader
  def self.call(input); end
end

module Sprockets::HTTPUtils
  def find_best_mime_type_match(q_value_header, available); end

  def find_best_q_match(q_values, available, &matcher); end

  def find_mime_type_matches(q_value_header, available); end

  def find_q_matches(q_values, available, &matcher); end

  def match_mime_type?(value, matcher); end

  def match_mime_type_keys(hash, mime_type); end

  def parse_q_values(values); end
end

module Sprockets::HTTPUtils
  extend ::Sprockets::HTTPUtils
end

Sprockets::Index = Sprockets::CachedEnvironment

class Sprockets::JstProcessor
  def call(input); end

  def initialize(options=T.unsafe(nil)); end
end

class Sprockets::JstProcessor
  def self.call(input); end

  def self.default_namespace(); end

  def self.instance(); end
end

class Sprockets::LegacyProcProcessor
  def call(input); end

  def initialize(name, proc); end

  def name(); end

  def to_s(); end
end

class Sprockets::LegacyProcProcessor
end

class Sprockets::LegacyTiltProcessor
  def call(input); end

  def initialize(klass); end
end

class Sprockets::LegacyTiltProcessor
end

module Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def load(uri); end
end

module Sprockets::Loader
end

class Sprockets::Manifest
  include ::Sprockets::ManifestUtils
  def assets(); end

  def clean(count=T.unsafe(nil), age=T.unsafe(nil)); end

  def clobber(); end

  def compile(*args); end

  def dir(); end

  def directory(); end

  def environment(); end

  def filename(); end

  def files(); end

  def filter_logical_paths(*args); end

  def find(*args); end

  def find_logical_paths(*args); end

  def find_sources(*args); end

  def initialize(*args); end

  def path(); end

  def remove(filename); end

  def save(); end
end

class Sprockets::Manifest
  def self.compile_match_filter(filter); end

  def self.compute_alias_logical_path(path); end

  def self.simple_logical_path?(str); end
end

module Sprockets::ManifestUtils
  def find_directory_manifest(dirname); end

  def generate_manifest_path(); end
  LEGACY_MANIFEST_RE = ::T.let(nil, ::T.untyped)
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::Sprockets::ManifestUtils
end

module Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::HTTPUtils
  def mime_exts(); end

  def mime_type_charset_detecter(mime_type); end

  def mime_types(); end

  def read_file(filename, content_type=T.unsafe(nil)); end

  def register_mime_type(mime_type, options=T.unsafe(nil)); end
end

module Sprockets::Mime
end

class Sprockets::NotFound
end

class Sprockets::NotFound
end

class Sprockets::NotImplementedError
end

class Sprockets::NotImplementedError
end

module Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  def entries_with_dependencies(path); end

  def file_digest_dependency_set(path); end

  def stat_directory_with_dependencies(dir); end

  def stat_sorted_tree_with_dependencies(dir); end
end

module Sprockets::PathDependencyUtils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def file_digest(path); end

  def files_digest(paths); end

  def stat_digest(path, stat); end
end

module Sprockets::PathDigestUtils
end

module Sprockets::PathUtils
  def absolute_path?(path); end

  def atomic_write(filename); end

  def directory?(path); end

  def entries(path); end

  def file?(path); end

  def find_upwards(basename, path, root=T.unsafe(nil)); end

  def match_path_extname(path, extensions); end

  def path_extnames(path); end

  def path_parents(path, root=T.unsafe(nil)); end

  def paths_split(paths, filename); end

  def relative_path?(path); end

  def split_subpath(path, subpath); end

  def stat(path); end

  def stat_directory(dir); end

  def stat_sorted_tree(dir, &block); end

  def stat_tree(dir, &block); end
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::Sprockets::PathUtils
end

module Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::PathUtils
  def append_path(path); end

  def clear_paths(); end

  def each_file(); end

  def paths(); end

  def prepend_path(path); end

  def root(); end
end

module Sprockets::Paths
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  def build_processors_uri(type, file_type, engine_extnames, pipeline); end

  def bundle_processors(); end

  def default_processors_for(type, file_type, engine_extnames); end

  def pipelines(); end

  def postprocessors(); end

  def preprocessors(); end

  def processors(); end

  def processors_for(type, file_type, engine_extnames, pipeline); end

  def register_bundle_metadata_reducer(mime_type, key, *args, &block); end

  def register_bundle_processor(*args, &block); end

  def register_pipeline(name, proc=T.unsafe(nil), &block); end

  def register_postprocessor(*args, &block); end

  def register_preprocessor(*args, &block); end

  def register_processor(*args, &block); end

  def resolve_processors_cache_key_uri(uri); end

  def self_processors_for(type, file_type, engine_extnames); end

  def unregister_bundle_processor(*args); end

  def unregister_postprocessor(*args); end

  def unregister_preprocessor(*args); end

  def unregister_processor(*args); end
end

module Sprockets::Processing
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def valid_processor_metadata_value?(value); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  def self.included(klass); end
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::Sprockets::Rails::Utils
  def asset_digest_path(path, options=T.unsafe(nil)); end

  def asset_integrity(path, options=T.unsafe(nil)); end

  def asset_resolver_strategies(); end

  def compute_asset_path(path, options=T.unsafe(nil)); end

  def compute_integrity?(options); end

  def javascript_include_tag(*sources); end

  def legacy_debug_path(path, debug); end

  def lookup_debug_asset(path, options=T.unsafe(nil)); end

  def path_with_extname(path, options); end

  def request_debug_assets?(); end

  def resolve_asset(); end

  def resolve_asset_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def secure_subresource_integrity_context?(); end

  def stylesheet_link_tag(*sources); end
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  def self.extended(obj); end

  def self.included(klass); end
end

module Sprockets::Rails::HelperAssetResolvers
end

class Sprockets::Rails::HelperAssetResolvers::Environment
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Environment
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
end

module Sprockets::Rails::HelperAssetResolvers
  def self.[](name); end
end

class Sprockets::Rails::QuietAssets
  def call(env); end

  def initialize(app); end
end

class Sprockets::Rails::QuietAssets
end

module Sprockets::Rails::RouteWrapper
  def internal?(); end

  def internal_assets_path?(); end
end

module Sprockets::Rails::RouteWrapper
  def self.included(klass); end
end

module Sprockets::Rails::Utils
  def using_sprockets4?(); end
end

module Sprockets::Rails::Utils
end

module Sprockets::Rails
end

class Sprockets::Railtie
  include ::Sprockets::Rails::Utils
  def build_environment(app, initialized=T.unsafe(nil)); end
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie::ManifestNeededError
  def initialize(); end
end

class Sprockets::Railtie::ManifestNeededError
end

class Sprockets::Railtie::OrderedOptions
  def configure(&block); end
end

class Sprockets::Railtie::OrderedOptions
end

class Sprockets::Railtie
  def self.build_manifest(app); end
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  include ::Sprockets::HTTPUtils
  def dirname_matches(dirname, basename); end

  def parse_accept_options(mime_type, types); end

  def parse_path_extnames(path); end

  def path_matches(load_path, logical_name, logical_basename); end

  def resolve(path, options=T.unsafe(nil)); end

  def resolve!(path, options=T.unsafe(nil)); end

  def resolve_absolute_path(paths, filename, accept); end

  def resolve_alternates(load_path, logical_name); end

  def resolve_asset_uri(uri); end

  def resolve_logical_path(paths, logical_path, accept); end

  def resolve_relative_path(paths, path, dirname, accept); end

  def resolve_under_paths(paths, logical_name, accepts); end
end

module Sprockets::Resolve
end

class Sprockets::SassCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

class Sprockets::SassProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

class Sprockets::SassProcessor::CacheStore
  def initialize(cache, version); end

  def path_to(key); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassProcessor::CacheStore
end

module Sprockets::SassProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SassProcessor::Functions
end

class Sprockets::SassProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::SassTemplate
end

class Sprockets::SassTemplate
  def self.call(*args); end
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssTemplate
end

class Sprockets::ScssTemplate
  def self.call(*args); end
end

module Sprockets::Server
  def call(env); end
end

module Sprockets::Server
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def compose_transformers(transformers, types); end

  def expand_transform_accepts(parsed_accepts); end

  def register_transformer(from, to, proc); end

  def resolve_transform_type(type, accept); end

  def transformers(); end
end

module Sprockets::Transformers
end

class Sprockets::URITar
  def absolute_path?(); end

  def compress(); end

  def compressed_path(); end

  def expand(); end

  def initialize(uri, env); end

  def path(); end

  def root(); end

  def scheme(); end
end

class Sprockets::URITar
end

module Sprockets::URIUtils
  def build_asset_uri(path, params=T.unsafe(nil)); end

  def build_file_digest_uri(path); end

  def encode_uri_query_params(params); end

  def join_file_uri(scheme, host, path, query); end

  def join_uri(scheme, userinfo, host, port, registry, path, opaque, query, fragment); end

  def parse_asset_uri(uri); end

  def parse_file_digest_uri(uri); end

  def parse_uri_query_params(query); end

  def split_file_uri(uri); end

  def split_uri(uri); end

  def valid_asset_uri?(str); end
end

module Sprockets::URIUtils
  extend ::Sprockets::URIUtils
end

class Sprockets::UglifierCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::UglifierCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::UnloadedAsset
  def asset_key(); end

  def compressed_path(); end

  def dependency_history_key(); end

  def digest_key(digest); end

  def file_digest_key(stat); end

  def filename(); end

  def initialize(uri, env); end

  def params(); end

  def uri(); end
end

class Sprockets::UnloadedAsset
end

module Sprockets::Utils
  def concat_javascript_sources(buf, source); end

  def dfs(initial); end

  def dfs_paths(path); end

  def duplicable?(obj); end

  def hash_reassoc(hash, *keys, &block); end

  def hash_reassoc1(hash, key); end

  def module_include(base, mod); end

  def normalize_extension(extension); end

  def string_end_with_semicolon?(str); end
  UNBOUND_METHODS_BIND_TO_ANY_OBJECT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  def can_compress?(mime_types); end

  def cannot_compress?(mime_types); end

  def compress(target); end

  def initialize(asset); end
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
end

module Sprockets::Utils
  extend ::Sprockets::Utils
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::Configuration
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Engines
  extend ::Sprockets::Mime
  extend ::Sprockets::Paths
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::ProcessorUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::PathUtils
  extend ::Sprockets::DigestUtils
end

module Spy
  VERSION = ::T.let(nil, ::T.untyped)
end

module Spy::API
  def assert_received(base_object, method_name); end

  def assert_received_with(base_object, method_name, *args, &block); end

  def have_received(method_name); end
end

module Spy::API
end

class Spy::Agency
  include ::Singleton
  def active?(spy); end

  def clear!(); end

  def dissolve!(); end

  def find(id); end

  def recruit(spy); end

  def retire(spy); end

  def spies(); end
end

class Spy::Agency
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Spy::AlreadyHookedError
end

class Spy::AlreadyHookedError
end

class Spy::AlreadyStubbedError
end

class Spy::AlreadyStubbedError
end

module Spy::Base
end

module Spy::Base
end

class Spy::CallLog
  def args(); end

  def block(); end

  def called_from(); end

  def initialize(object, called_from, args, block, result); end

  def object(); end

  def result(); end
end

class Spy::CallLog
end

class Spy::Constant
  include ::Spy::Base
  def and_hide(); end

  def and_return(value); end

  def base_module(); end

  def constant_name(); end

  def currently_defined?(); end

  def hidden?(); end

  def hook(opts=T.unsafe(nil)); end

  def hooked?(); end

  def initialize(base_module, constant_name); end

  def name(); end

  def original_value(); end

  def previously_defined?(); end

  def unhook(); end
end

class Spy::Constant
  def self.get(base_module, constant_name); end

  def self.off(base_module, constant_name); end

  def self.on(base_module, constant_name); end
end

class Spy::Error
end

class Spy::Error
end

module Spy::MiniTestAdapter
  include ::Spy::API
  def after_teardown(); end
end

module Spy::MiniTestAdapter
end

module Spy::Mock
  include ::Spy::Base
  def initialize(&mock_method); end

  def instance_of?(other); end

  def method(method_name); end
  CLASSES_NOT_TO_OVERRIDE = ::T.let(nil, ::T.untyped)
  METHODS_NOT_TO_OVERRIDE = ::T.let(nil, ::T.untyped)
end

module Spy::Mock
  def self.new(klass); end
end

class Spy::Nest
  def add(spy); end

  def base_module(); end

  def get(constant_name); end

  def hooked?(constant_name); end

  def hooked_constants(); end

  def initialize(base_module); end

  def remove(spy); end
end

class Spy::Nest
  def self.all(); end

  def self.fetch(base_module); end

  def self.get(base_module); end
end

class Spy::NeverHookedError
end

class Spy::NeverHookedError
end

class Spy::NoSpyError
end

class Spy::NoSpyError
end

class Spy::NotHookedError
end

class Spy::NotHookedError
end

class Spy::RspecAdapter
  include ::Spy::API
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

class Spy::RspecAdapter
end

class Spy::Subroutine
  include ::Spy::Base
  def and_call_through(); end

  def and_raise(exception=T.unsafe(nil), message=T.unsafe(nil)); end

  def and_return(value=T.unsafe(nil)); end

  def and_throw(*args); end

  def and_yield(*args); end

  def base_object(); end

  def calls(); end

  def has_been_called?(); end

  def has_been_called_with?(*args); end

  def hook(opts=T.unsafe(nil)); end

  def hook_opts(); end

  def hooked?(); end

  def initialize(object, method_name, singleton_method=T.unsafe(nil)); end

  def invoke(object, args, block, called_from); end

  def method_name(); end

  def original_method(); end

  def original_method_visibility(); end

  def reset!(); end

  def singleton_method(); end

  def unhook(); end
  SPY_ARGS_PREFIX = ::T.let(nil, ::T.untyped)
end

class Spy::Subroutine
  def self.get(base_object, method_name, singleton_method=T.unsafe(nil)); end

  def self.get_spies(base_object, singleton_methods=T.unsafe(nil)); end

  def self.get_spy_id(method); end

  def self.off(base_object, method_name, singleton_method=T.unsafe(nil)); end

  def self.on(base_object, method_name, singleton_method=T.unsafe(nil)); end
end

module Spy
  def self.get(base_object, *method_names); end

  def self.get_const(base_module, *constant_names); end

  def self.mock(klass, *stubs); end

  def self.mock_all(klass, *stubs); end

  def self.off(base_object, *method_names); end

  def self.off_const(base_module, *constant_names); end

  def self.off_instance_method(base_class, *method_names); end

  def self.on(base_object, *method_names); end

  def self.on_const(base_module, *constant_names); end

  def self.on_instance_method(base_class, *method_names); end

  def self.teardown(); end
end

module StateMachines
  VERSION = ::T.let(nil, ::T.untyped)
end

class StateMachines::AllMatcher
  include ::Singleton
  def -(blacklist); end

  def description(); end

  def matches?(value, context=T.unsafe(nil)); end
end

class StateMachines::AllMatcher
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class StateMachines::AttributeTransitionCollection
end

class StateMachines::AttributeTransitionCollection
end

class StateMachines::BlacklistMatcher
  def description(); end

  def matches?(value, context=T.unsafe(nil)); end
end

class StateMachines::Branch
  include ::StateMachines::EvalHelpers
  def build_matcher(options, whitelist_option, blacklist_option); end

  def draw(graph, event, valid_states); end

  def event_requirement(); end

  def if_condition(); end

  def initialize(options=T.unsafe(nil)); end

  def known_states(); end

  def match(object, query=T.unsafe(nil)); end

  def match_event(query); end

  def match_query(query); end

  def match_states(query); end

  def matches?(object, query=T.unsafe(nil)); end

  def matches_conditions?(object, query); end

  def matches_requirement?(query, option, requirement); end

  def state_requirements(); end

  def unless_condition(); end
end

class StateMachines::Branch
end

class StateMachines::Callback
  include ::StateMachines::EvalHelpers
  def branch(); end

  def call(object, context=T.unsafe(nil), *args, &block); end

  def initialize(type, *args, &block); end

  def known_states(); end

  def terminator(); end

  def type(); end

  def type=(type); end
end

class StateMachines::Callback
  def self.bind_to_object(); end

  def self.bind_to_object=(bind_to_object); end

  def self.terminator(); end

  def self.terminator=(terminator); end
end

module StateMachines::ClassMethods
  def state_machines(); end
end

module StateMachines::ClassMethods
  def self.extended(base); end
end

class StateMachines::Error
  def initialize(object, message=T.unsafe(nil)); end

  def object(); end
end

class StateMachines::Error
end

module StateMachines::EvalHelpers
  def evaluate_method(object, method, *args, &block); end
end

module StateMachines::EvalHelpers
end

class StateMachines::Event
  def add_actions(); end

  def branches(); end

  def can_fire?(object, requirements=T.unsafe(nil)); end

  def context(&block); end

  def draw(graph, options=T.unsafe(nil)); end

  def fire(object, *args); end

  def human_name(klass=T.unsafe(nil)); end

  def human_name=(human_name); end

  def initialize(machine, name, options=T.unsafe(nil)); end

  def known_states(); end

  def machine(); end

  def machine=(machine); end

  def name(); end

  def on_failure(object); end

  def qualified_name(); end

  def reset(); end

  def transition_for(object, requirements=T.unsafe(nil)); end
end

class StateMachines::EventCollection
  def attribute_transition_for(object, invalidate=T.unsafe(nil)); end

  def initialize(machine); end

  def transitions_for(object, requirements=T.unsafe(nil)); end

  def valid_for(object, requirements=T.unsafe(nil)); end
end

class StateMachines::EventCollection
end

class StateMachines::HelperModule
  def initialize(machine, kind); end
end

class StateMachines::HelperModule
end

module StateMachines::InstanceMethods
  def fire_events(*events); end

  def fire_events!(*events); end

  def initialize_state_machines(options=T.unsafe(nil), &block); end
end

module StateMachines::InstanceMethods
end

class StateMachines::IntegrationError
end

class StateMachines::IntegrationError
end

class StateMachines::IntegrationNotFound
  def error_message(); end

  def initialize(name); end

  def no_integrations(); end

  def valid_integrations(); end

  def valid_integrations_name(); end
end

class StateMachines::IntegrationNotFound
end

module StateMachines::Integrations
end

module StateMachines::Integrations::ActiveModel
  include ::StateMachines::Integrations::Base
  def add_callback(type, options, &block); end

  def add_events(*_); end

  def add_states(*_); end

  def ancestors_for(klass); end

  def around_validation(object); end

  def callback_terminator(); end

  def default_error_message_options(_object, _attribute, message); end

  def define_action_helpers(); end

  def define_state_accessor(); end

  def define_state_initializer(); end

  def define_validation_hook(); end

  def errors_for(object); end

  def i18n_scope(klass); end

  def invalidate(object, attribute, message, values=T.unsafe(nil)); end

  def reset(object); end

  def runs_validations_on_action?(); end

  def supports_validations?(); end

  def translate(klass, key, value); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module StateMachines::Integrations::ActiveModel
  extend ::StateMachines::Integrations::Base::ClassMethods
end

module StateMachines::Integrations::ActiveRecord
  include ::StateMachines::Integrations::ActiveModel
  include ::StateMachines::Integrations::Base
  def around_save(object); end

  def attribute_column(); end

  def create_with_scope(name); end

  def create_without_scope(name); end

  def define_action_hook(); end

  def define_state_initializer(); end

  def locale_path(); end

  def owner_class_attribute_default(); end

  def runs_validations_on_action?(); end

  def transaction(object); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module StateMachines::Integrations::ActiveRecord
  extend ::StateMachines::Integrations::Base::ClassMethods
end

module StateMachines::Integrations::Base
end

module StateMachines::Integrations::Base::ClassMethods
  def defaults(); end

  def integration_name(); end

  def matches?(klass); end

  def matches_ancestors?(ancestors); end

  def matching_ancestors(); end
end

module StateMachines::Integrations::Base::ClassMethods
end

module StateMachines::Integrations::Base
  def self.included(base); end
end

module StateMachines::Integrations
  def self.find_by_name(name); end

  def self.integrations(); end

  def self.list(); end

  def self.match(klass); end

  def self.match_ancestors(ancestors); end

  def self.register(name_or_module); end

  def self.reset(); end
end

class StateMachines::InvalidContext
end

class StateMachines::InvalidContext
end

class StateMachines::InvalidEvent
  def event(); end

  def initialize(object, event_name); end
end

class StateMachines::InvalidEvent
end

class StateMachines::InvalidParallelTransition
  def events(); end

  def initialize(object, events); end
end

class StateMachines::InvalidParallelTransition
end

class StateMachines::InvalidTransition
  def event(); end

  def from(); end

  def from_name(); end

  def initialize(object, machine, event); end

  def machine(); end

  def qualified_event(); end

  def qualified_from_name(); end
end

class StateMachines::InvalidTransition
end

class StateMachines::LoopbackMatcher
  include ::Singleton
  def description(); end

  def matches?(value, context); end
end

class StateMachines::LoopbackMatcher
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class StateMachines::Machine
  include ::StateMachines::EvalHelpers
  def action(); end

  def action_hook(); end

  def action_hook?(self_only=T.unsafe(nil)); end

  def add_callback(type, options, &block); end

  def add_events(new_events); end

  def add_sibling_machine_configs(); end

  def add_states(new_states); end

  def after_failure(*args, &block); end

  def after_initialize(); end

  def attribute(name=T.unsafe(nil)); end

  def callbacks(); end

  def create_with_scope(name); end

  def create_without_scope(name); end

  def define_action_helpers(); end

  def define_action_helpers?(); end

  def define_action_hook(); end

  def define_event_helpers(); end

  def define_helper(scope, method, *args, &block); end

  def define_helpers(); end

  def define_name_helpers(); end

  def define_path_helpers(); end

  def define_scopes(custom_plural=T.unsafe(nil)); end

  def define_state_accessor(); end

  def define_state_initializer(); end

  def define_state_predicate(); end

  def draw(*_); end

  def dynamic_initial_state?(); end

  def errors_for(_object); end

  def events(); end

  def generate_message(name, values=T.unsafe(nil)); end

  def initial_state(object); end

  def initial_state=(new_initial_state); end

  def initialize(owner_class, *args, &block); end

  def initialize_state(object, options=T.unsafe(nil)); end

  def initialize_state?(object); end

  def invalidate(_object, _attribute, _message, _values=T.unsafe(nil)); end

  def name(); end

  def namespace(); end

  def on(*names, &block); end

  def other_states(*names, &block); end

  def owner_class(); end

  def owner_class=(klass); end

  def owner_class_ancestor_has_method?(scope, method); end

  def owner_class_attribute_default(); end

  def owner_class_attribute_default_matches?(state); end

  def owner_class_has_method?(scope, method); end

  def paths_for(object, requirements=T.unsafe(nil)); end

  def pluralize(word); end

  def read(object, attribute, ivar=T.unsafe(nil)); end

  def reset(_object); end

  def run_scope(scope, machine, klass, states); end

  def sibling_machines(); end

  def states(); end

  def transaction(object); end

  def transition(options); end

  def use_transactions(); end

  def within_transaction(object); end

  def write(object, attribute, value, ivar=T.unsafe(nil)); end
end

class StateMachines::Machine
  def self.default_messages(); end

  def self.default_messages=(default_messages); end

  def self.draw(*_); end

  def self.find_or_create(owner_class, *args, &block); end

  def self.ignore_method_conflicts(); end

  def self.ignore_method_conflicts=(ignore_method_conflicts); end
end

class StateMachines::MachineCollection
  def fire_events(object, *events); end

  def initialize_states(object, options=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def resolve_use_transactions(); end

  def transitions(object, action, options=T.unsafe(nil)); end
end

class StateMachines::MachineCollection
end

class StateMachines::Matcher
  def filter(values); end

  def initialize(values=T.unsafe(nil)); end

  def values(); end
end

class StateMachines::NodeCollection
  include ::Enumerable
  def <<(node); end

  def [](key, index_name=T.unsafe(nil)); end

  def add_to_index(name, key, node); end

  def at(index); end

  def concat(nodes); end

  def context(nodes, &block); end

  def each(&blk); end

  def eval_context(context, node); end

  def fetch(key, index_name=T.unsafe(nil)); end

  def index(name); end

  def initialize(machine, options=T.unsafe(nil)); end

  def keys(index_name=T.unsafe(nil)); end

  def length(); end

  def machine(); end

  def machine=(new_machine); end

  def remove_from_index(name, key); end

  def to_sym?(value); end

  def update(node); end

  def update_index(name, node); end

  def value(node, attribute); end
end

class StateMachines::NodeCollection
end

class StateMachines::Path
  def complete?(); end

  def events(); end

  def from_name(); end

  def from_states(); end

  def initialize(object, machine, options=T.unsafe(nil)); end

  def machine(); end

  def object(); end

  def to_name(); end

  def to_states(); end

  def walk(); end
end

class StateMachines::Path
end

class StateMachines::PathCollection
  def events(); end

  def from_name(); end

  def from_states(); end

  def initialize(object, machine, options=T.unsafe(nil)); end

  def machine(); end

  def object(); end

  def to_name(); end

  def to_states(); end
end

class StateMachines::PathCollection
end

class StateMachines::State
  def cache(); end

  def cache=(cache); end

  def call(object, method, *args, &block); end

  def context(&block); end

  def context_methods(); end

  def description(options=T.unsafe(nil)); end

  def draw(graph, options=T.unsafe(nil)); end

  def final?(); end

  def human_name(klass=T.unsafe(nil)); end

  def human_name=(human_name); end

  def initial(); end

  def initial=(initial); end

  def initial?(); end

  def initialize(machine, name, options=T.unsafe(nil)); end

  def machine(); end

  def machine=(machine); end

  def matcher(); end

  def matcher=(matcher); end

  def matches?(other_value); end

  def name(); end

  def qualified_name(); end

  def value(eval=T.unsafe(nil)); end

  def value=(value); end
end

class StateMachines::State
end

class StateMachines::StateCollection
  def by_priority(); end

  def initialize(machine); end

  def match(object); end

  def match!(object); end

  def matches?(object, name); end
end

class StateMachines::StateCollection
end

class StateMachines::StateContext
  include ::StateMachines::EvalHelpers
  def initialize(state); end

  def machine(); end

  def method_missing(*args, &block); end

  def state(); end

  def transition(options); end
end

class StateMachines::Transition
  def ==(other); end

  def action(); end

  def args(); end

  def args=(args); end

  def attribute(); end

  def attributes(); end

  def event(); end

  def from(); end

  def from_name(); end

  def human_event(); end

  def human_from_name(); end

  def human_to_name(); end

  def initialize(object, machine, event, from_name, to_name, read_state=T.unsafe(nil)); end

  def loopback?(); end

  def machine(); end

  def object(); end

  def perform(*args); end

  def persist(); end

  def qualified_event(); end

  def qualified_from_name(); end

  def qualified_to_name(); end

  def reset(); end

  def result(); end

  def rollback(); end

  def run_callbacks(options=T.unsafe(nil), &block); end

  def to(); end

  def to_name(); end

  def transient=(transient); end

  def transient?(); end

  def within_transaction(); end
end

class StateMachines::Transition
  def self.pause_supported?(); end
end

class StateMachines::TransitionCollection
  def initialize(transitions=T.unsafe(nil), options=T.unsafe(nil)); end

  def perform(&block); end

  def results(); end

  def skip_actions(); end

  def skip_after(); end

  def use_transactions(); end
end

class StateMachines::TransitionCollection
end

class StateMachines::WhitelistMatcher
  def description(); end

  def matches?(value, context=T.unsafe(nil)); end
end

class StopIteration
  def result(); end
end

class Stream
  def <<(data); end

  def close(); end

  def closed?(); end

  def each(&front); end

  def initialize(&callback); end
end

class Stream
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::IntegerStringImpl
  include ::BooleanStringImpl
  def []=(*_); end

  def ascii_only(); end

  def ascii_only!(); end

  def casecmp?(_); end

  def display_length(*args); end

  def display_size(*args); end

  def display_width(ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def format(*args); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def remove_prefix(pattern); end

  def remove_prefix!(pattern); end

  def remove_suffix(pattern); end

  def remove_suffix!(pattern); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def strip_indent(); end

  def strip_margin(margin_characters); end

  def succ!(); end

  def to_blob(); end

  def to_d(); end

  def truncate_bytes(truncate_at, omission: T.unsafe(nil)); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class StubSocket
  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def initialize(*args); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readuntil(*args); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class StubSocket
end

class SubsetValidator
end

class SubstitutionContext
  def match(matches, attribute, matcher); end

  def substitute!(selector, values, format_for_presentation=T.unsafe(nil)); end
end

class SubstitutionContext
end

class SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class SynchronizedDelegator
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TA
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module TZInfo
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.data_source(); end

  def self.get(identifier); end

  def self.init_countries(); end

  def self.new(identifier); end
end

module TZInfo::CountryIndexDefinition
end

module TZInfo::CountryIndexDefinition::ClassMethods
  def countries(); end

  def country(code, name, &block); end
end

module TZInfo::CountryIndexDefinition::ClassMethods
end

module TZInfo::CountryIndexDefinition
  def self.append_features(base); end
end

class TZInfo::CountryInfo
  def code(); end

  def initialize(code, name); end

  def name(); end

  def zone_identifiers(); end

  def zones(); end
end

class TZInfo::CountryInfo
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
  def self.new(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def self.new!(*_); end
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def timezone_identifiers(); end
end

class TZInfo::DataSource
  def self.create_default_data_source(); end

  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezoneInfo
  def period_for_utc(utc); end

  def periods_for_local(local); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end
end

class TZInfo::DataTimezoneInfo
end

class TZInfo::InfoTimezone
  def info(); end

  def setup(info); end
end

class TZInfo::InfoTimezone
  def self.new(info); end
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::LinkedTimezoneInfo
end

class TZInfo::NoOffsetsDefined
end

class TZInfo::NoOffsetsDefined
end

module TZInfo::OffsetRationals
end

module TZInfo::OffsetRationals
  def self.rational_for_offset(offset); end
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  def self.datetime_new(y=T.unsafe(nil), m=T.unsafe(nil), d=T.unsafe(nil), h=T.unsafe(nil), min=T.unsafe(nil), s=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.datetime_new!(ajd=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.force_encoding(str, encoding); end

  def self.open_file(file_name, mode, opts, &block); end

  def self.rational_new!(numerator, denominator=T.unsafe(nil)); end

  def self.time_nsec(time); end

  def self.time_supports_64bit(); end

  def self.time_supports_negative(); end
end

class TZInfo::RubyCountryInfo
  def initialize(code, name, &block); end
end

class TZInfo::RubyCountryInfo::Zones
  def list(); end

  def timezone(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end
end

class TZInfo::RubyCountryInfo::Zones
end

class TZInfo::RubyCountryInfo
end

class TZInfo::RubyDataSource
end

class TZInfo::RubyDataSource
end

class TZInfo::TimeOrDateTime
  include ::Comparable
  def +(seconds); end

  def -(seconds); end

  def add_with_convert(seconds); end

  def day(); end

  def eql?(todt); end

  def hour(); end

  def initialize(timeOrDateTime); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def sec(); end

  def to_datetime(); end

  def to_i(); end

  def to_orig(); end

  def to_time(); end

  def usec(); end

  def year(); end
end

class TZInfo::TimeOrDateTime
  def self.wrap(timeOrDateTime); end
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

module TZInfo::TimezoneDefinition
end

module TZInfo::TimezoneDefinition::ClassMethods
  def get(); end

  def linked_timezone(identifier, link_to_identifier); end

  def timezone(identifier); end
end

module TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::TimezoneDefinition
  def self.append_features(base); end
end

module TZInfo::TimezoneIndexDefinition
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  def data_timezones(); end

  def linked_timezone(identifier); end

  def linked_timezones(); end

  def timezone(identifier); end

  def timezones(); end
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
end

module TZInfo::TimezoneIndexDefinition
  def self.append_features(base); end
end

class TZInfo::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::TimezoneInfo
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbreviation(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(utc_offset, std_offset, abbreviation); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def ==(p); end

  def abbreviation(); end

  def dst?(); end

  def end_transition(); end

  def eql?(p); end

  def initialize(start_transition, end_transition, offset=T.unsafe(nil)); end

  def local_after_start?(local); end

  def local_before_end?(local); end

  def local_end(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_time(); end

  def offset(); end

  def start_transition(); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_after_start?(utc); end

  def utc_before_end?(utc); end

  def utc_end(); end

  def utc_end_time(); end

  def utc_offset(); end

  def utc_start(); end

  def utc_start_time(); end

  def utc_total_offset(); end

  def utc_total_offset_rational(); end

  def valid_for_local?(local); end

  def valid_for_utc?(utc); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def transitions_up_to(to, from=T.unsafe(nil)); end
end

class TZInfo::TimezoneProxy
  def self.new(identifier); end
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def datetime(); end

  def eql?(tti); end

  def initialize(offset, previous_offset); end

  def local_end(); end

  def local_end_at(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_at(); end

  def local_start_time(); end

  def offset(); end

  def previous_offset(); end

  def time(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TimezoneTransitionDefinition
  def denominator(); end

  def initialize(offset, previous_offset, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end

  def numerator_or_time(); end
end

class TZInfo::TimezoneTransitionDefinition
end

class TZInfo::TransitionDataTimezoneInfo
  def offset(id, utc_offset, std_offset, abbreviation); end

  def transition(year, month, offset_id, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end
end

class TZInfo::TransitionDataTimezoneInfo
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class TZInfo::ZoneinfoCountryInfo
  def initialize(code, name, zones); end
end

class TZInfo::ZoneinfoCountryInfo
end

class TZInfo::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.process_search_path(path, default); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoTimezoneInfo
  def initialize(identifier, file_path); end
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
end

module TZInfo
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

Thor::Correctable = DidYouMean::Correctable

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Thor::NestedContext
end

class Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Thor::NoKwargSpellChecker
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UndefinedCommandError::SpellChecker
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UnknownArgumentError::SpellChecker
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::MriCacheBackend
end

class ThreadSafe::NonConcurrentCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end

  def value?(value); end
end

class ThreadSafe::NonConcurrentCacheBackend
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module ThreadSafe
end

module Threadsafe
end

module Threadsafe
  def self.const_missing(name); end
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::Cache
end

class Tilt::CoffeeScriptLiterateTemplate
end

class Tilt::CoffeeScriptLiterateTemplate
end

class Tilt::CoffeeScriptTemplate
  def allows_script?(); end
end

class Tilt::CoffeeScriptTemplate
  def self.default_bare(); end

  def self.default_bare=(value); end

  def self.default_no_wrap(); end

  def self.default_no_wrap=(value); end

  def self.literate?(); end
end

module Tilt::CompiledTemplates
end

module Tilt::CompiledTemplates
end

class Tilt::Dummy
end

class Tilt::Dummy
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  def [](file); end

  def extensions_for(template_class); end

  def lazy_map(); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def registered?(ext); end

  def template_for(file); end

  def template_map(); end

  def templates_for(file); end
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::Mapping
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = Sass

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.current_template(); end

  def self.default_mapping(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class Time
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  include ::Mocha::TimeMethods
  def acts_like_time?(); end

  def ago(seconds); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_year(years=T.unsafe(nil)); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_year(years=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.current(); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone(); end

  def self.zone=(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end

end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::SafeType::BooleanMixin
end

module TypeCoerce
end

class TypeCoerce::CoercionError
end

class TypeCoerce::CoercionError
end

module TypeCoerce::Configuration
end

module TypeCoerce::Configuration
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.raise_coercion_error(*args, &blk); end

  def self.raise_coercion_error=(raise_coercion_error); end
end

module TypeCoerce::Private
end

class TypeCoerce::Private::Converter
  def _build_args(*args, &blk); end

  def _convert(*args, &blk); end

  def _convert_simple(*args, &blk); end

  def _convert_to_a(*args, &blk); end

  def _nil_like?(*args, &blk); end
  PRIMITIVE_TYPES = ::T.let(nil, ::T.untyped)
end

class TypeCoerce::Private::Converter
  extend ::T::Sig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module TypeCoerce::Private
end

class TypeCoerce::ShapeError
end

class TypeCoerce::ShapeError
end

module TypeCoerce
  def self.[](type); end
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.parser(); end

end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

module Virtus
  EXTRA_CONST_ARGS = ::T.let(nil, ::T.untyped)
  Undefined = ::T.let(nil, ::T.untyped)
end

class Virtus::Attribute
  include ::Equalizer::Methods
  def coerce(input); end

  def coercer(); end

  def coercible?(); end

  def default_value(); end

  def define_accessor_methods(attribute_set); end

  def finalize(); end

  def finalized?(); end

  def initialize(type, options); end

  def lazy?(); end

  def nullify_blank?(); end

  def options(); end

  def primitive(); end

  def rename(name); end

  def required?(); end

  def strict?(); end

  def type(); end

  def value_coerced?(value); end
end

module Virtus::Attribute::Accessor
  def defined?(instance); end

  def get(instance); end

  def instance_variable_name(); end

  def name(); end

  def public_reader?(); end

  def public_writer?(); end

  def set(instance, value); end

  def set_default_value(instance); end
end

module Virtus::Attribute::Accessor
  def self.extended(descendant); end
end

class Virtus::Attribute::Boolean
end

class Virtus::Attribute::Boolean
  def self.build_type(*_); end
end

class Virtus::Attribute::Builder
  def attribute(); end

  def initialize(type_definition, options); end

  def klass(); end

  def options(); end

  def type(); end

  def type_definition(); end
end

class Virtus::Attribute::Builder
  def self.call(type, options=T.unsafe(nil)); end

  def self.determine_type(klass, default=T.unsafe(nil)); end
end

class Virtus::Attribute::Coercer
  def call(value); end

  def coercers(); end

  def initialize(type, coercers); end

  def method(); end

  def success?(primitive, value); end
end

class Virtus::Attribute::Coercer
end

module Virtus::Attribute::Coercible
  def set(instance, value); end
end

module Virtus::Attribute::Coercible
end

class Virtus::Attribute::Collection
  def coerce(value); end

  def member_type(); end
end

class Virtus::Attribute::Collection::Type
  def coercion_method(); end

  def member_type(); end

  def member_type=(_); end

  def primitive(); end

  def primitive=(_); end
end

class Virtus::Attribute::Collection::Type
  def self.[](*_); end

  def self.axiom_type?(type); end

  def self.infer(type, primitive); end

  def self.infer_member_type(type); end

  def self.members(); end

  def self.pending?(primitive); end
end

class Virtus::Attribute::Collection
  def self.merge_options!(type, options); end
end

class Virtus::Attribute::DefaultValue
  def call(*_); end

  def initialize(value); end

  def value(); end
end

class Virtus::Attribute::DefaultValue::FromCallable
  def call(*args); end
end

class Virtus::Attribute::DefaultValue::FromCallable
  def self.handle?(value); end
end

class Virtus::Attribute::DefaultValue::FromClonable
  SINGLETON_CLASSES = ::T.let(nil, ::T.untyped)
end

class Virtus::Attribute::DefaultValue::FromClonable
  def self.handle?(value); end
end

class Virtus::Attribute::DefaultValue::FromSymbol
  def call(instance, _); end
end

class Virtus::Attribute::DefaultValue::FromSymbol
  def self.handle?(value); end
end

class Virtus::Attribute::DefaultValue
  extend ::DescendantsTracker
  def self.build(*args); end
end

class Virtus::Attribute::EmbeddedValue
  TYPES = ::T.let(nil, ::T.untyped)
end

class Virtus::Attribute::EmbeddedValue::FromOpenStruct
end

class Virtus::Attribute::EmbeddedValue::FromOpenStruct
end

class Virtus::Attribute::EmbeddedValue::FromStruct
end

class Virtus::Attribute::EmbeddedValue::FromStruct
end

class Virtus::Attribute::EmbeddedValue
  def self.build_coercer(type, _options); end

  def self.handles?(klass); end
end

class Virtus::Attribute::Hash
  def coerce(*_); end

  def key_type(); end

  def value_type(); end
end

class Virtus::Attribute::Hash::Type
  def coercion_method(); end

  def key_type(); end

  def key_type=(_); end

  def primitive(); end

  def value_type(); end

  def value_type=(_); end
end

class Virtus::Attribute::Hash::Type
  def self.[](*_); end

  def self.axiom_type?(type); end

  def self.determine_type(type); end

  def self.infer(type); end

  def self.infer_key_and_value_types(type); end

  def self.members(); end

  def self.pending?(primitive); end
end

class Virtus::Attribute::Hash
  def self.merge_options!(type, options); end
end

module Virtus::Attribute::LazyDefault
  def get(instance); end
end

module Virtus::Attribute::LazyDefault
end

module Virtus::Attribute::NullifyBlank
  def coerce(input); end
end

module Virtus::Attribute::NullifyBlank
end

module Virtus::Attribute::Strict
  def coerce(*_); end
end

module Virtus::Attribute::Strict
end

class Virtus::Attribute
  extend ::Virtus::TypeLookup
  extend ::Virtus::Options
  extend ::DescendantsTracker
  def self.accessor(value=T.unsafe(nil)); end

  def self.build(type, options=T.unsafe(nil)); end

  def self.build_coercer(type, options=T.unsafe(nil)); end

  def self.build_type(definition); end

  def self.coerce(value=T.unsafe(nil)); end

  def self.default(value=T.unsafe(nil)); end

  def self.finalize(value=T.unsafe(nil)); end

  def self.lazy(value=T.unsafe(nil)); end

  def self.merge_options!(*_); end

  def self.nullify_blank(value=T.unsafe(nil)); end

  def self.primitive(value=T.unsafe(nil)); end

  def self.required(value=T.unsafe(nil)); end

  def self.strict(value=T.unsafe(nil)); end
end

class Virtus::AttributeSet
  include ::Enumerable
  def <<(attribute); end

  def [](name); end

  def []=(name, attribute); end

  def coerce(attributes); end

  def define_reader_method(attribute, method_name, visibility); end

  def define_writer_method(attribute, method_name, visibility); end

  def each(&blk); end

  def finalize(); end

  def get(object); end

  def initialize(parent=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def merge(attributes); end

  def reset(); end

  def set(object, attributes); end

  def set_defaults(object, filter=T.unsafe(nil)); end
end

class Virtus::AttributeSet
  def self.create(descendant); end
end

class Virtus::Builder
  def config(); end

  def extensions(); end

  def initialize(conf, mod=T.unsafe(nil)); end

  def mod(); end

  def options(); end
end

class Virtus::Builder::HookContext
  def attribute_method(); end

  def builder(); end

  def config(); end

  def constructor?(); end

  def finalize?(); end

  def initialize(builder, config); end

  def initialize_attribute_method(); end

  def mass_assignment?(); end

  def modules(); end
end

class Virtus::Builder::HookContext
end

class Virtus::Builder
  def self.call(options, &block); end

  def self.pending(); end
end

module Virtus::ClassInclusions
end

module Virtus::ClassInclusions::Methods
  def allowed_writer_methods(); end
end

module Virtus::ClassInclusions::Methods
end

module Virtus::ClassInclusions
end

module Virtus::ClassMethods
  include ::Virtus::Extensions::Methods
  include ::Virtus::ConstMissingExtensions
  def attribute_set(); end

  def attributes(); end
end

module Virtus::ClassMethods
end

class Virtus::Coercer
  def call(input); end

  def initialize(type); end

  def primitive(); end

  def success?(primitive, input); end

  def type(); end
end

class Virtus::Coercer
end

class Virtus::CoercionError
  def attribute(); end

  def attribute_name(); end

  def attribute_name?(); end

  def build_message(); end

  def initialize(output, attribute); end

  def output(); end

  def target_type(); end
end

class Virtus::CoercionError
end

class Virtus::Configuration
  def coerce(); end

  def coerce=(coerce); end

  def coercer(&block); end

  def constructor(); end

  def constructor=(constructor); end

  def finalize(); end

  def finalize=(finalize); end

  def initialize(options=T.unsafe(nil)); end

  def mass_assignment(); end

  def mass_assignment=(mass_assignment); end

  def nullify_blank(); end

  def nullify_blank=(nullify_blank); end

  def required(); end

  def required=(required); end

  def strict(); end

  def strict=(strict); end

  def to_h(); end
end

class Virtus::Configuration
end

module Virtus::ConstMissingExtensions
  def const_missing(name); end
end

module Virtus::ConstMissingExtensions
end

class Virtus::Equalizer
  def <<(key); end

  def initialize(name, keys=T.unsafe(nil)); end
end

module Virtus::Equalizer::Methods
  def ==(other); end

  def eql?(other); end
end

module Virtus::Equalizer::Methods
end

class Virtus::Equalizer
end

module Virtus::Extensions
  INVALID_WRITER_METHODS = ::T.let(nil, ::T.untyped)
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
  WRITER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Virtus::Extensions::AllowedWriterMethods
  def allowed_writer_methods(); end
  INVALID_WRITER_METHODS = ::T.let(nil, ::T.untyped)
  WRITER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Virtus::Extensions::AllowedWriterMethods
end

module Virtus::Extensions::Methods
  def attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def values(&block); end
end

module Virtus::Extensions::Methods
end

module Virtus::Extensions
end

module Virtus::InstanceMethods
  def [](name); end

  def []=(name, value); end

  def freeze(); end

  def reset_attribute(attribute_name); end

  def set_default_attributes(); end

  def set_default_attributes!(); end
end

module Virtus::InstanceMethods::Constructor
  def initialize(attributes=T.unsafe(nil)); end
end

module Virtus::InstanceMethods::Constructor
end

module Virtus::InstanceMethods::MassAssignment
  def attributes(); end

  def attributes=(attributes); end

  def to_h(); end

  def to_hash(); end
end

module Virtus::InstanceMethods::MassAssignment
end

module Virtus::InstanceMethods
end

module Virtus::Model
end

module Virtus::Model::Constructor
end

module Virtus::Model::Constructor
end

module Virtus::Model::Core
end

module Virtus::Model::Core
  def self.extended(descendant); end
end

module Virtus::Model::MassAssignment
end

module Virtus::Model::MassAssignment
end

module Virtus::Model
  def self.extended(descendant); end

  def self.included(descendant); end
end

class Virtus::ModelBuilder
end

class Virtus::ModelBuilder
end

class Virtus::ModuleBuilder
end

class Virtus::ModuleBuilder
end

module Virtus::ModuleExtensions
  include ::Virtus::ConstMissingExtensions
  def attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Virtus::ModuleExtensions
  def self.extended(mod); end

  def self.setup(mod, inclusions=T.unsafe(nil), attribute_definitions=T.unsafe(nil)); end
end

module Virtus::Options
  def accept_options(*new_options); end

  def accepted_options(); end

  def add_accepted_options(new_options); end

  def define_option_method(option); end

  def options(); end

  def set_options(new_options); end
end

module Virtus::Options
end

class Virtus::PendingAttribute
  def determine_type(); end

  def finalize(); end

  def finalized?(); end

  def initialize(type, options); end

  def name(); end

  def options(); end

  def type(); end
end

class Virtus::PendingAttribute
end

class Virtus::TypeDefinition
  def initialize(type); end

  def pending?(); end

  def primitive(); end

  def type(); end
end

class Virtus::TypeDefinition
end

module Virtus::TypeLookup
  def determine_type(class_or_name); end

  def primitive(); end
  TYPE_FORMAT = ::T.let(nil, ::T.untyped)
end

module Virtus::TypeLookup
  def self.extended(model); end
end

module Virtus::ValueObject
end

module Virtus::ValueObject::AllowedWriterMethods
  def allowed_writer_methods(); end
end

module Virtus::ValueObject::AllowedWriterMethods
end

module Virtus::ValueObject::ClassMethods
  def attribute(name, type, options=T.unsafe(nil)); end

  def equalizer(); end
end

module Virtus::ValueObject::ClassMethods
end

module Virtus::ValueObject::InstanceMethods
  def clone(); end

  def dup(); end

  def with(attribute_updates); end
end

module Virtus::ValueObject::InstanceMethods
end

module Virtus::ValueObject
end

class Virtus::ValueObjectBuilder
end

class Virtus::ValueObjectBuilder
end

module Virtus
  def self.coerce(); end

  def self.coerce=(value); end

  def self.coercer(&block); end

  def self.config(&block); end

  def self.configuration(); end

  def self.finalize(); end

  def self.model(options=T.unsafe(nil), &block); end

  def self.module(options=T.unsafe(nil), &block); end

  def self.value_object(options=T.unsafe(nil), &block); end

  def self.warn(msg); end
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end

  def weakref_alive?(); end
end

class WeakRef::RefError
end

class WeakRef::RefError
end

class WeakRef
end

module WebMock
  include ::WebMock::API
  def after_request(*args, &block); end

  def allow_net_connect!(*args, &block); end

  def disable_net_connect!(*args, &block); end

  def net_connect_allowed?(*args, &block); end

  def registered_request?(*args, &block); end

  def reset_callbacks(*args, &block); end

  def reset_webmock(*args, &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module WebMock::API
  def a_request(method, uri); end

  def assert_not_requested(*args, &block); end

  def assert_requested(*args, &block); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def refute_requested(*args, &block); end

  def remove_request_stub(stub); end

  def reset_executed_requests!(); end

  def stub_http_request(method, uri); end

  def stub_request(method, uri); end
end

module WebMock::API
  extend ::WebMock::API
  def self.request(method, uri); end
end

class WebMock::AssertionFailure
end

class WebMock::AssertionFailure
  def self.error_class(); end

  def self.error_class=(error_class); end

  def self.failure(message); end
end

class WebMock::BodyPattern
  include ::WebMock::RSpecMatcherDetector
  def initialize(pattern); end

  def matches?(body, content_type=T.unsafe(nil)); end

  def pattern(); end
  BODY_FORMATS = ::T.let(nil, ::T.untyped)
end

class WebMock::BodyPattern
end

class WebMock::CallbackRegistry
end

class WebMock::CallbackRegistry
  def self.add_callback(options, block); end

  def self.any_callbacks?(); end

  def self.callbacks(); end

  def self.invoke_callbacks(options, request_signature, response); end

  def self.reset(); end
end

class WebMock::Config
  include ::Singleton
  def allow(); end

  def allow=(allow); end

  def allow_localhost(); end

  def allow_localhost=(allow_localhost); end

  def allow_net_connect(); end

  def allow_net_connect=(allow_net_connect); end

  def net_http_connect_on_start(); end

  def net_http_connect_on_start=(net_http_connect_on_start); end

  def query_values_notation(); end

  def query_values_notation=(query_values_notation); end

  def show_body_diff(); end

  def show_body_diff=(show_body_diff); end

  def show_stubbing_instructions(); end

  def show_stubbing_instructions=(show_stubbing_instructions); end
end

class WebMock::Config
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::Deprecation
end

class WebMock::Deprecation
  def self.warning(message); end
end

class WebMock::DynamicResponse
  def initialize(responder); end

  def responder(); end

  def responder=(responder); end
end

class WebMock::DynamicResponse
end

class WebMock::HashValidator
  def initialize(hash); end

  def validate_keys(*valid_keys); end
end

class WebMock::HashValidator
end

class WebMock::HeadersPattern
  def initialize(pattern); end

  def matches?(headers); end

  def pp_to_s(); end
end

class WebMock::HeadersPattern
end

class WebMock::HttpLibAdapter
end

class WebMock::HttpLibAdapter
  def self.adapter_for(lib); end
end

class WebMock::HttpLibAdapterRegistry
  include ::Singleton
  def each_adapter(&block); end

  def http_lib_adapters(); end

  def http_lib_adapters=(http_lib_adapters); end

  def register(lib, adapter); end
end

class WebMock::HttpLibAdapterRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module WebMock::HttpLibAdapters
end

class WebMock::HttpLibAdapters::NetHttpAdapter
end

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetBufferedIO = Net::BufferedIO

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP

class WebMock::HttpLibAdapters::NetHttpAdapter
  def self.disable!(); end

  def self.enable!(); end
end

module WebMock::HttpLibAdapters
end

module WebMock::Matchers
end

class WebMock::Matchers::AnyArgMatcher
  def ==(other); end

  def initialize(ignore); end
end

class WebMock::Matchers::AnyArgMatcher
end

class WebMock::Matchers::HashArgumentMatcher
  def ==(_actual, &block); end

  def initialize(expected); end
end

class WebMock::Matchers::HashArgumentMatcher
  def self.from_rspec_matcher(matcher); end
end

class WebMock::Matchers::HashExcludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashExcludingMatcher
end

class WebMock::Matchers::HashIncludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashIncludingMatcher
end

module WebMock::Matchers
end

class WebMock::MethodPattern
  def initialize(pattern); end

  def matches?(method); end
end

class WebMock::MethodPattern
end

class WebMock::NetConnectNotAllowedError
  def initialize(request_signature); end
end

class WebMock::NetConnectNotAllowedError
end

module WebMock::NetHTTPUtility
end

module WebMock::NetHTTPUtility
  def self.check_right_http_connection(); end

  def self.puts_warning_for_right_http_if_needed(); end

  def self.request_signature_from_request(net_http, request, body=T.unsafe(nil)); end

  def self.validate_headers(headers); end
end

module WebMock::RSpecMatcherDetector
  def rSpecHashExcludingMatcher?(matcher); end

  def rSpecHashIncludingMatcher?(matcher); end
end

module WebMock::RSpecMatcherDetector
end

class WebMock::RackResponse
  def body_from_rack_response(response); end

  def build_rack_env(request); end

  def evaluate(request); end

  def initialize(app); end

  def session(); end

  def session_options(); end
end

class WebMock::RackResponse
end

class WebMock::RequestBodyDiff
  def body_diff(); end

  def initialize(request_signature, request_stub); end
end

class WebMock::RequestBodyDiff
end

class WebMock::RequestExecutionVerifier
  def at_least_times_executed(); end

  def at_least_times_executed=(at_least_times_executed); end

  def at_most_times_executed(); end

  def at_most_times_executed=(at_most_times_executed); end

  def description(); end

  def does_not_match?(); end

  def expected_times_executed(); end

  def expected_times_executed=(expected_times_executed); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(request_pattern=T.unsafe(nil), expected_times_executed=T.unsafe(nil), at_least_times_executed=T.unsafe(nil), at_most_times_executed=T.unsafe(nil)); end

  def matches?(); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def times_executed(); end

  def times_executed=(times_executed); end
end

class WebMock::RequestExecutionVerifier
  def self.executed_requests_message(); end
end

class WebMock::RequestPattern
  def body_pattern(); end

  def headers_pattern(); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def matches?(request_signature); end

  def method_pattern(); end

  def uri_pattern(); end

  def with(options=T.unsafe(nil), &block); end
end

class WebMock::RequestPattern
end

class WebMock::RequestRegistry
  include ::Singleton
  def requested_signatures(); end

  def requested_signatures=(requested_signatures); end

  def reset!(); end

  def times_executed(request_pattern); end
end

class WebMock::RequestRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::RequestSignature
  def ==(other); end

  def body(); end

  def body=(body); end

  def eql?(other); end

  def headers(); end

  def headers=(headers); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def json_headers?(); end

  def method(); end

  def method=(method); end

  def uri(); end

  def uri=(uri); end

  def url_encoded?(); end
end

class WebMock::RequestSignature
end

class WebMock::RequestSignatureSnippet
  def initialize(request_signature); end

  def request_signature(); end

  def request_stub(); end

  def request_stubs(); end

  def stubbing_instructions(); end
end

class WebMock::RequestSignatureSnippet
end

class WebMock::RequestStub
  def and_raise(*exceptions); end

  def and_return(*response_hashes, &block); end

  def and_timeout(); end

  def has_responses?(); end

  def initialize(method, uri); end

  def matches?(request_signature); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def response(); end

  def times(number); end

  def to_rack(app, options=T.unsafe(nil)); end

  def to_raise(*exceptions); end

  def to_return(*response_hashes, &block); end

  def to_timeout(); end

  def with(params=T.unsafe(nil), &block); end
end

class WebMock::RequestStub
  def self.from_request_signature(signature); end
end

class WebMock::Response
  def ==(other); end

  def body(); end

  def body=(body); end

  def evaluate(request_signature); end

  def exception(); end

  def exception=(exception); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def options=(options); end

  def raise_error_if_any(); end

  def should_timeout(); end

  def status(); end

  def status=(status); end
end

class WebMock::Response::InvalidBody
end

class WebMock::Response::InvalidBody
end

class WebMock::Response
end

class WebMock::ResponseFactory
end

class WebMock::ResponseFactory
  def self.response_for(options); end
end

class WebMock::ResponsesSequence
  def end?(); end

  def initialize(responses); end

  def next_response(); end

  def times_to_repeat(); end

  def times_to_repeat=(times_to_repeat); end
end

class WebMock::ResponsesSequence
end

class WebMock::StubRegistry
  include ::Singleton
  def global_stubs(); end

  def register_global_stub(&block); end

  def register_request_stub(stub); end

  def registered_request?(request_signature); end

  def remove_request_stub(stub); end

  def request_stubs(); end

  def request_stubs=(request_stubs); end

  def reset!(); end

  def response_for_request(request_signature); end
end

class WebMock::StubRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::StubRequestSnippet
  def body_pattern(); end

  def initialize(request_stub); end

  def to_s(with_response=T.unsafe(nil)); end
end

class WebMock::StubRequestSnippet
end

class WebMock::URIAddressablePattern
  def matches?(uri); end
end

class WebMock::URIAddressablePattern
end

class WebMock::URIPattern
  include ::WebMock::RSpecMatcherDetector
  def add_query_params(query_params); end

  def initialize(pattern); end
end

class WebMock::URIPattern
end

class WebMock::URIRegexpPattern
  def matches?(uri); end
end

class WebMock::URIRegexpPattern
end

class WebMock::URIStringPattern
  def matches?(uri); end
end

class WebMock::URIStringPattern
end

module WebMock::Util
end

class WebMock::Util::HashCounter
  def each(&block); end

  def get(key); end

  def hash=(hash); end

  def put(key, num=T.unsafe(nil)); end

  def select(&block); end
end

class WebMock::Util::HashCounter
end

class WebMock::Util::HashKeysStringifier
end

class WebMock::Util::HashKeysStringifier
  def self.stringify_keys!(arg, options=T.unsafe(nil)); end
end

class WebMock::Util::Headers
end

class WebMock::Util::Headers
  def self.basic_auth_header(*credentials); end

  def self.decode_userinfo_from_header(header); end

  def self.normalize_headers(headers); end

  def self.pp_headers_string(headers); end

  def self.sorted_headers_string(headers); end
end

class WebMock::Util::JSON
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON
  def self.convert_json_to_yaml(json); end

  def self.parse(json); end

  def self.unescape(str); end
end

class WebMock::Util::QueryMapper
end

class WebMock::Util::QueryMapper
  def self.collect_query_hash(query_array, empty_accumulator, options); end

  def self.collect_query_parts(query); end

  def self.dehash(hash); end

  def self.fill_accumulator_for_dot(accumulator, key, value); end

  def self.fill_accumulator_for_flat(accumulator, key, value); end

  def self.fill_accumulator_for_flat_array(accumulator, key, value); end

  def self.fill_accumulator_for_subscript(accumulator, key, value); end

  def self.normalize_query_hash(query_hash, empty_accumulator, options); end

  def self.query_to_values(query, options=T.unsafe(nil)); end

  def self.to_query(parent, value, options=T.unsafe(nil)); end

  def self.values_to_query(new_query_values, options=T.unsafe(nil)); end
end

class WebMock::Util::URI
  ADDRESSABLE_URIS = ::T.let(nil, ::T.untyped)
  NORMALIZED_URIS = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
  USERINFO = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
end

class WebMock::Util::URI
  def self.encode_unsafe_chars_in_userinfo(userinfo); end

  def self.heuristic_parse(uri); end

  def self.is_uri_localhost?(uri); end

  def self.normalize_uri(uri); end

  def self.sort_query_values(query_values); end

  def self.strip_default_port_from_uri_string(uri_string); end

  def self.uris_encoded_and_unencoded(uris); end

  def self.uris_with_inferred_port_and_without(uris); end

  def self.uris_with_scheme_and_without(uris); end

  def self.uris_with_trailing_slash_and_without(uris); end

  def self.variations_of_uri_as_strings(uri_object, only_with_scheme: T.unsafe(nil)); end
end

class WebMock::Util::ValuesStringifier
end

class WebMock::Util::ValuesStringifier
  def self.stringify_values(value); end
end

module WebMock::Util
end

class WebMock::VersionChecker
  def check_version!(); end

  def initialize(library_name, library_version, min_patch_level, max_minor_version=T.unsafe(nil), unsupported_versions=T.unsafe(nil)); end
end

class WebMock::VersionChecker
end

module WebMock
  extend ::WebMock::API
  def self.after_request(options=T.unsafe(nil), &block); end

  def self.allow_net_connect!(options=T.unsafe(nil)); end

  def self.disable!(options=T.unsafe(nil)); end

  def self.disable_net_connect!(options=T.unsafe(nil)); end

  def self.disallow_net_connect!(options=T.unsafe(nil)); end

  def self.enable!(); end

  def self.enable_net_connect!(options=T.unsafe(nil)); end

  def self.globally_stub_request(&block); end

  def self.hide_body_diff!(); end

  def self.hide_stubbing_instructions!(); end

  def self.included(clazz); end

  def self.net_connect_allowed?(uri=T.unsafe(nil)); end

  def self.net_connect_explicit_allowed?(allowed, uri=T.unsafe(nil)); end

  def self.print_executed_requests(); end

  def self.registered_request?(request_signature); end

  def self.request(method, uri); end

  def self.reset!(); end

  def self.reset_callbacks(); end

  def self.reset_webmock(); end

  def self.show_body_diff!(); end

  def self.show_body_diff?(); end

  def self.show_stubbing_instructions!(); end

  def self.show_stubbing_instructions?(); end

  def self.version(); end
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module Zeitwerk
end

class Zeitwerk::Error
end

class Zeitwerk::Error
end

module Zeitwerk::ExplicitNamespace
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
  def self.cpaths(); end

  def self.disable_tracer_if_unneeded(); end

  def self.mutex(); end

  def self.register(cpath, loader); end

  def self.tracepoint_class_callback(event); end

  def self.tracer(); end

  def self.unregister(loader); end
end

class Zeitwerk::GemInflector
  def camelize(basename, abspath); end

  def initialize(root_file); end
end

class Zeitwerk::GemInflector
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end

  def inflect(inflections); end
end

class Zeitwerk::Inflector
end

class Zeitwerk::Loader
  include ::Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def autoloaded_dirs(); end

  def autoloads(); end

  def collapse(*glob_patterns); end

  def collapse_dirs(); end

  def collapse_glob_patterns(); end

  def dirs(); end

  def do_not_eager_load(*paths); end

  def eager_load(); end

  def eager_load_exclusions(); end

  def enable_reloading(); end

  def ignore(*glob_patterns); end

  def ignored_glob_patterns(); end

  def ignored_paths(); end

  def inflector(); end

  def inflector=(inflector); end

  def lazy_subdirs(); end

  def log!(); end

  def logger(); end

  def logger=(logger); end

  def manages?(dir); end

  def mutex(); end

  def mutex2(); end

  def preload(*paths); end

  def preloads(); end

  def push_dir(path); end

  def reload(); end

  def reloading_enabled?(); end

  def root_dirs(); end

  def setup(); end

  def tag(); end

  def tag=(tag); end

  def to_unload(); end

  def unload(); end

  def unloadable_cpath?(cpath); end

  def unloadable_cpaths(); end
end

module Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def on_dir_autoloaded(dir); end

  def on_file_autoloaded(file); end

  def on_namespace_loaded(namespace); end
end

module Zeitwerk::Loader::Callbacks
end

class Zeitwerk::Loader
  def self.all_dirs(); end

  def self.default_logger(); end

  def self.default_logger=(default_logger); end

  def self.eager_load_all(); end

  def self.for_gem(); end

  def self.mutex(); end

  def self.mutex=(mutex); end
end

class Zeitwerk::NameError
end

class Zeitwerk::NameError
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

module Zeitwerk::RealModName
end

module Zeitwerk::Registry
end

module Zeitwerk::Registry
  def self.autoloads(); end

  def self.inception?(cpath); end

  def self.inceptions(); end

  def self.loader_for(path); end

  def self.loader_for_gem(root_file); end

  def self.loaders(); end

  def self.loaders_managing_gems(); end

  def self.on_unload(loader); end

  def self.register_autoload(loader, realpath); end

  def self.register_inception(cpath, realpath, loader); end

  def self.register_loader(loader); end

  def self.unregister_autoload(realpath); end
end

class Zeitwerk::ReloadingDisabledError
end

class Zeitwerk::ReloadingDisabledError
end

module Zeitwerk
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
